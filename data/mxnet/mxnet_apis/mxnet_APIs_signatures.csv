API,Description,Example,,
"
class mxnet.ndarray.CachedOp(sym, flags=())[source]Â¶","['Bases: ', 'object', '\n', 'Cached operator handle.', '\n', '\n']",,,
"
mxnet.ndarray.Activation(data=None, act_type=_Null, out=None, name=None, **kwargs)Â¶","['Applies an activation function element-wise to the input.', '\n', 'The following activation functions are supported:', '\n', '\n', 'relu', '\n', 'sigmoid', '\n', 'tanh', '\n', 'softrelu', '\n', 'softsign', '\n', '\n', 'Defined in src/operator/nn/activation.cc:L164', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\nthe inverse of ', 'data_var', ', which are needed for the backward pass. Note that gradient of these\ntwo outputs are blocked.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is 1.  Specifying -1 sets the channel\naxis to be the last item in the input shape.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Note', '\n', 'When ', '\n', '\n', 'Defined in src/operator/nn/batch_norm.cc:L608', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BatchNorm_v1(data=None, gamma=None, beta=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'This operator is DEPRECATED. Perform BatchNorm on the input.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', 'Thereâ\x80\x99s no sparse support for this operator, and it will exhibit problematic behavior if used with\nsparse tensors.', '\n', 'Defined in src/operator/batch_norm_v1.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BilinearSampler(data=None, grid=None, cudnn_off=_Null, out=None, name=None, **kwargs)Â¶","['Applies bilinear sampling to input feature map.', '\n', 'Bilinear Sampling is the key of  [NIPS2015] â\x80\x9cSpatial Transformer Networksâ\x80\x9d. The usage of the operator is very similar to remap function in OpenCV,\nexcept that the operator has the backward pass.', '\n', 'Given ', '\\(data\\)', ' and ', '\\(grid\\)', ', then the output is computed by', '\n', '\n\\[\\begin{split}x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\\\\ny_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\\\\noutput[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})\\end{split}\\]', '\n', '\\(x_{dst}\\)', ', ', '\\(y_{dst}\\)', ' enumerate all spatial locations in ', '\\(output\\)', ', and ', '\\(G()\\)', ' denotes the bilinear interpolation kernel.\nThe out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).', '\n', 'The operator assumes that ', '\\(data\\)', ' has â\x80\x98NCHWâ\x80\x99 layout and ', '\\(grid\\)', ' has been normalized to [-1, 1].', '\n', 'BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.\nGridGenerator supports two kinds of transformation: ', 'affine', ' and ', 'warp', '.\nIf users want to design a CustomOp to manipulate ', '\\(grid\\)', ', please firstly refer to the code of GridGenerator.', '\n', 'Example 1:', '\n', None, '\n', '\n', 'Example 2:', '\n', None, '\n', '\n', 'Defined in src/operator/bilinear_sampler.cc:L255', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BlockGrad(data=None, out=None, name=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Cast(data=None, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Convolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Compute ', 'N', '-D convolution on ', '(N+2)', '-D input.', '\n', 'In the 2-D convolution, given input data with shape ', '(batch_size,\nchannel, height, width)', ', the output is computed by', '\n', '\n\\[out[n,i,:,:] = bias[i] + \\sum_{j=0}^{channel} data[n,j,:,:] \\star\nweight[i,j,:,:]\\]', '\n', 'where ', '\\(\\star\\)', ' is the 2-D cross-correlation operator.', '\n', 'For general 2-D convolution, the shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channel, height,\nwidth)', '. We can choose other layouts such as ', 'NWC', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concatenating all\nthe ', 'g', ' results.', '\n', '1-D convolution does not have ', 'height', ' dimension but only ', 'width', ' in space.', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', '3-D convolution adds an additional ', 'depth', ' dimension besides ', 'height', ' and\n', 'width', '. The shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'There are other options to tune the performance.', '\n', '\n', 'cudnn_tune', '\n', 'workspace', '\n', '\n', 'Defined in src/operator/nn/convolution.cc:L475', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Convolution_v1(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['This operator is DEPRECATED. Apply convolution to input then add a bias.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Correlation(data1=None, data2=None, kernel_size=_Null, max_displacement=_Null, stride1=_Null, stride2=_Null, pad_size=_Null, is_multiply=_Null, out=None, name=None, **kwargs)Â¶","['Applies correlation to inputs.', '\n', 'The correlation layer performs multiplicative patch comparisons between two feature maps.', '\n', 'Given two multi-channel feature maps ', '\\(f_{1}, f_{2}\\)', ', with ', '\\(w\\)', ', ', '\\(h\\)', ', and ', '\\(c\\)', ' being their width, height, and number of channels,\nthe correlation layer lets the network compare each patch from ', '\\(f_{1}\\)', ' with each patch from ', '\\(f_{2}\\)', '.', '\n', 'For now we consider only a single comparison of two patches. The â\x80\x98correlationâ\x80\x99 of two patches centered at ', '\\(x_{1}\\)', ' in the first map and\n', '\\(x_{2}\\)', ' in the second map is then defined as:', '\n', '\n\\[c(x_{1}, x_{2}) = \\sum_{o \\in [-k,k] \\times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\\]', '\n', 'for a square patch of size ', '\\(K:=2k+1\\)', '.', '\n', 'Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other\ndata. For this reason, it has no training weights.', '\n', 'Computing ', '\\(c(x_{1}, x_{2})\\)', ' involves ', '\\(c * K^{2}\\)', ' multiplications. Comparing all patch combinations involves ', '\\(w^{2}*h^{2}\\)', ' such computations.', '\n', 'Given a maximum displacement ', '\\(d\\)', ', for each location ', '\\(x_{1}\\)', ' it computes correlations ', '\\(c(x_{1}, x_{2})\\)', ' only in a neighborhood of size ', '\\(D:=2d+1\\)', ',\nby limiting the range of ', '\\(x_{2}\\)', '. We use strides ', '\\(s_{1}, s_{2}\\)', ', to quantize ', '\\(x_{1}\\)', ' globally and to quantize ', '\\(x_{2}\\)', ' within the neighborhood\ncentered around ', '\\(x_{1}\\)', '.', '\n', 'The final output is defined by the following expression:', '\n', '\n\\[out[n, q, i, j] = c(x_{i, j}, x_{q})\\]', '\n', 'where ', '\\(i\\)', ' and ', '\\(j\\)', ' enumerate spatial locations in ', '\\(f_{1}\\)', ', and ', '\\(q\\)', ' denotes the ', '\\(q^{th}\\)', ' neighborhood of ', '\\(x_{i,j}\\)', '.', '\n', 'Defined in src/operator/correlation.cc:L197', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Crop(*data, **kwargs)Â¶","['\n', 'Note', '\n', 'Crop', '\n', '\n', 'Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or\nwith width and height of the second input symbol, i.e., with one input, we need h_w to\nspecify the crop height and width, otherwise the second input symbolâ\x80\x99s size will be used', '\n', 'Defined in src/operator/crop.cc:L49', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Custom(*data, **kwargs)Â¶","['Apply a custom operator implemented in a frontend language (like Python).', '\n', 'Custom operators should override required methods like ', 'forward', ' and ', 'backward', '.\nThe custom operator must be registered before it can be used.\nPlease check the tutorial here: ', 'https://mxnet.incubator.apache.org/api/faq/new_op', '\n', 'Defined in src/operator/custom/custom.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', 'Applies a custom operator named ', 'my_custom_operator', ' to ', 'input', '.', '\n', None, '\n', '\n', '\n']",">>> output=mx.symbol.Custom(op_type='my_custom_operator',data=input)
",,
"
mxnet.ndarray.Deconvolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, adj=_Null, target_shape=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Dropout(data=None, p=_Null, mode=_Null, axes=_Null, cudnn_off=_Null, out=None, name=None, **kwargs)Â¶","['Applies dropout operation to input array.', '\n', '\n', 'During training, each element of the input is set to zero with probability p.\nThe whole array is rescaled by ', '\n', 'During testing, this operator does not change the input if mode is â\x80\x98trainingâ\x80\x99.\nIf mode is â\x80\x98alwaysâ\x80\x99, the same computaion as during training will be applied.', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/dropout.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ElementWiseSum(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Embedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, out=None, name=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'When â\x80\x9csparse_gradâ\x80\x9d is False, if any index mentioned is too large, it is replaced by the index that\naddresses the last vector in an embedding matrix.\nWhen â\x80\x9csparse_gradâ\x80\x9d is True, an error will be raised if invalid indices are found.', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of weight can be either row_sparse or default.', '\n', '\n', 'Note', '\n', 'If â\x80\x9csparse_gradâ\x80\x9d is set to True, the storage type of gradient w.r.t weights will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L597', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Flatten(data=None, out=None, name=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.FullyConnected(data=None, weight=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out=None, name=None, **kwargs)Â¶","['Applies a linear transformation: ', '\\(Y = XW^T + b\\)', '.', '\n', 'If ', 'flatten', ' is set to be true, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'If ', 'flatten', ' is set to be false, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'The learnable parameters include both ', 'weight', ' and ', 'bias', '.', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', '\n', 'Note', '\n', 'The sparse support for FullyConnected is limited to forward evaluation with ', '\n', 'To compute linear transformation with â\x80\x98csrâ\x80\x99 sparse data, sparse.dot is recommended instead\nof sparse.FullyConnected.', '\n', '\n', 'Defined in src/operator/nn/fully_connected.cc:L286', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.GridGenerator(data=None, transform_type=_Null, target_shape=_Null, out=None, name=None, **kwargs)Â¶","['Generates 2D sampling grid for bilinear sampling.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.GroupNorm(data=None, gamma=None, beta=None, num_groups=_Null, eps=_Null, output_mean_var=_Null, out=None, name=None, **kwargs)Â¶","['Group normalization.', '\n', 'The input channels are separated into ', 'num_groups', ' groups, each containing ', 'num_channels', ' channels.\nThe mean and standard-deviation are calculated separately over the each group.', '\n', '\n\\[data = data.reshape((N, num_groups, C // num_groups, ...))\nout = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Defined in src/operator/nn/group_norm.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.IdentityAttachKLSparseReg(data=None, sparseness_target=_Null, penalty=_Null, momentum=_Null, out=None, name=None, **kwargs)Â¶","['Apply a sparse regularization to the output a sigmoid activation function.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.InstanceNorm(data=None, gamma=None, beta=None, eps=_Null, out=None, name=None, **kwargs)Â¶","['Applies instance normalization to the n-dimensional input array.', '\n', 'This operator takes an n-dimensional input array where (n>2) and normalizes\nthe input using the following formula:', '\n', '\n\\[out = \\frac{x - mean[data]}{ \\sqrt{Var[data]} + \\epsilon} * gamma + beta\\]', '\n', 'This layer is similar to batch normalization layer (', 'BatchNorm', ')\nwith two differences: first, the normalization is\ncarried out per example (instance), not over a batch. Second, the\nsame normalization is applied both at test and train time. This\noperation is also known as ', 'contrast normalization', '.', '\n', 'If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, â\x80¦],\n', 'gamma', ' and ', 'beta', ' parameters must be vectors of shape [channel].', '\n', 'This implementation is based on this paper ', '1', '\n', '\n', '1', '\n', 'Instance Normalization: The Missing Ingredient for Fast Stylization,\nD. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/instance_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.L2Normalization(data=None, eps=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Normalize the input array using the L2 norm.', '\n', 'For 1-D NDArray, it computes:', '\n', None, '\n', '\n', 'For N-D NDArray, if the input array has shape (N, N, â\x80¦, N),', '\n', 'with ', 'mode', ' = ', 'instance', ', it normalizes each instance in the multidimensional\narray by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'channel', ', it normalizes each channel in the array by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'spatial', ', it normalizes the cross channel norm for each position\nin the array by its L2 norm.:', '\n', None, '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/l2_normalization.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.LRN(data=None, alpha=_Null, beta=_Null, knorm=_Null, nsize=_Null, out=None, name=None, **kwargs)Â¶","['Applies local response normalization to the input.', '\n', 'The local response normalization layer performs â\x80\x9clateral inhibitionâ\x80\x9d by normalizing\nover local input regions.', '\n', 'If ', '\\(a_{x,y}^{i}\\)', ' is the activity of a neuron computed by applying kernel ', '\\(i\\)', ' at position\n', '\\((x, y)\\)', ' and then applying the ReLU nonlinearity, the response-normalized\nactivity ', '\\(b_{x,y}^{i}\\)', ' is given by the expression:', '\n', '\n\\[b_{x,y}^{i} = \\frac{a_{x,y}^{i}}{\\Bigg({k + \\frac{\\alpha}{n} \\sum_{j=max(0, i-\\frac{n}{2})}^{min(N-1, i+\\frac{n}{2})} (a_{x,y}^{j})^{2}}\\Bigg)^{\\beta}}\\]', '\n', 'where the sum runs over ', '\\(n\\)', ' â\x80\x9cadjacentâ\x80\x9d kernel maps at the same spatial position, and ', '\\(N\\)', ' is the total\nnumber of kernels in the layer.', '\n', 'Defined in src/operator/nn/lrn.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.LayerNorm(data=None, gamma=None, beta=None, axis=_Null, eps=_Null, output_mean_var=_Null, out=None, name=None, **kwargs)Â¶","['Layer normalization.', '\n', 'Normalizes the channels of the input tensor by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis and then\ncompute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Unlike BatchNorm and InstanceNorm,  the ', 'mean', ' and ', 'var', ' are computed along the channel dimension.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_std', '. Note that no gradient will be passed through these two outputs.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is -1, which sets the channel\naxis to be the last item in the input shape.', '\n', 'Defined in src/operator/nn/layer_norm.cc:L201', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.LeakyReLU(data=None, gamma=None, act_type=_Null, slope=_Null, lower_bound=_Null, upper_bound=_Null, out=None, name=None, **kwargs)Â¶","['Applies Leaky rectified linear unit activation element-wise to the input.', '\n', 'Leaky ReLUs attempt to fix the â\x80\x9cdying ReLUâ\x80\x9d problem by allowing a small ', 'slope', '\nwhen the input is negative and has a slope of one when input is positive.', '\n', 'The following modified ReLU Activation functions are supported:', '\n', '\n', 'elu', '\n', 'selu', '\n', 'leaky', '\n', 'prelu', '\n', 'rrelu', '\n', '\n', 'Defined in src/operator/leaky_relu.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.LinearRegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Computes and optimizes for squared loss during backward propagation.\nJust outputs ', 'data', ' during forward propagation.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the squared loss estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{SquaredLoss}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert  \\textbf{y}_i - \\hat{\\textbf{y}}_i  \\rVert_2\\)', '\n', '\n', 'Note', '\n', 'Use the LinearRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LinearRegressionOutput(default, default) = default', '\n', 'LinearRegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.LogisticRegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Applies a logistic function to the input.', '\n', 'The logistic function, also known as the sigmoid function, is computed as\n', '\\(\\frac{1}{1+exp(-\\textbf{x})}\\)', '.', '\n', 'Commonly, the sigmoid is used to squash the real-valued output of a linear model\n', '\\(wTx+b\\)', ' into the [0,1] range so that it can be interpreted as a probability.\nIt is suitable for binary classification or probability prediction tasks.', '\n', '\n', 'Note', '\n', 'Use the LogisticRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LogisticRegressionOutput(default, default) = default', '\n', 'LogisticRegressionOutput(default, csr) = default', '\n', '\n', 'The loss function used is the Binary Cross Entropy Loss:', '\n', '\\(-{(y\\log(p) + (1 - y)\\log(1 - p))}\\)', '\n', 'Where ', 'y', ' is the ground truth probability of positive outcome for a given example, and ', 'p', ' the probability predicted by the model. By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L152', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.MAERegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Computes mean absolute error of the input.', '\n', 'MAE is a risk metric corresponding to the expected value of the absolute error.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the mean absolute error (MAE) estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{MAE}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert \\textbf{y}_i - \\hat{\\textbf{y}}_i \\rVert_1\\)', '\n', '\n', 'Note', '\n', 'Use the MAERegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'MAERegressionOutput(default, default) = default', '\n', 'MAERegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L120', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.MakeLoss(data=None, grad_scale=_Null, valid_thresh=_Null, normalization=_Null, out=None, name=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'MakeLoss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'In addition, we can give a scale to the loss by setting ', 'grad_scale', ',\nso that the gradient of the loss will be rescaled in the backpropagation.', '\n', '\n', 'Note', '\n', 'This operator should be used as a Symbol instead of NDArray.', '\n', '\n', 'Defined in src/operator/make_loss.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, out=None, name=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Pooling(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Performs pooling on the input.', '\n', 'The shapes for 1-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The shapes for 2-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'When ', 'global_pool', ' is set to be true, then global pooling is performed. It will reset\n', 'kernel=(height,', ' and set the appropiate padding to 0.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', 'lp', '\n', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data and output will have shape ', '(batch_size, channel, depth,\nheight, width)', ' (NCDHW layout) or ', '(batch_size, depth, height, width, channel)', ' (NDHWC layout).', '\n', 'Notes on Lp pooling:', '\n', 'Lp pooling was first introduced by this paper: ', 'https://arxiv.org/pdf/1204.3968.pdf', '.\nL-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.\nWe can see that Lp pooling stands between those two, in practice the most common value for p is 2.', '\n', 'For each window ', 'X', ', the mathematical expression for Lp pooling is:', '\n', '\\(f(X) = \\sqrt[p]{\\sum_{x}^{X} x^p}\\)', '\n', 'Defined in src/operator/nn/pooling.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Pooling_v1(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, out=None, name=None, **kwargs)Â¶","['This operator is DEPRECATED.\nPerform pooling on the input.', '\n', 'The shapes for 2-D pooling is', '\n', '\n', 'data', '\n', 'out', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'But ', 'global_pool', ' is set to be true, then do a global pooling, namely reset\n', 'kernel=(height,', '.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', '\n', '1-D pooling is special case of 2-D pooling with ', 'weight=1', ' and\n', 'kernel[1]=1', '.', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data will have shape ', '(batch_size, channel, depth,\nheight, width)', '.', '\n', 'Defined in src/operator/pooling_v1.cc:L103', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.RNN(data=None, parameters=None, state=None, state_cell=None, sequence_length=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, out=None, name=None, **kwargs)Â¶","['Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are\nimplemented, with both multi-layer and bidirectional support.', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', 'Vanilla RNN', '\n', 'Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:\nReLU and Tanh.', '\n', 'With ReLU activation function:', '\n', '\n\\[h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'With Tanh activtion function:', '\n', '\n\\[h_t = \\tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'Reference paper: Finding structure in time - Elman, 1988.\n', 'https://crl.ucsd.edu/~elman/Papers/fsit.pdf', '\n', 'LSTM', '\n', 'Long Short-Term Memory - Hochreiter, 1997. ', 'http://www.bioinf.jku.at/publications/older/2604.pdf', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          \\end{array}\\end{split}\\]', '\n', 'With the projection size being set, LSTM could use the projection feature to reduce the parameters\nsize and give some speedups without significant damage to the accuracy.', '\n', 'Long Short-Term Memory Based Recurrent Neural Network Architectures for Large Vocabulary Speech\nRecognition - Sak et al. 2014. ', 'https://arxiv.org/abs/1402.1128', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{ri} r_{(t-1)} + b_{ri}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{rf} r_{(t-1)} + b_{rf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{rc} r_{(t-1)} + b_{rg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{o} + W_{ro} r_{(t-1)} + b_{ro}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          r_t = W_{hr} h_t\n          \\end{array}\\end{split}\\]', '\n', 'GRU', '\n', 'Gated Recurrent Unit - Cho et al. 2014. ', 'http://arxiv.org/abs/1406.1078', '\n', 'The definition of GRU here is slightly different from paper but compatible with CUDNN.', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          r_t = \\mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\\\\n          z_t = \\mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\\\\n          n_t = \\tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\\\\n          h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\\\\n          \\end{array}\\end{split}\\]', '\n', 'Defined in src/operator/rnn.cc:L375', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ROIPooling(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, out=None, name=None, **kwargs)Â¶","['Performs region of interest(ROI) pooling on the input array.', '\n', 'ROI pooling is a variant of a max pooling layer, in which the output size is fixed and\nregion of interest is a parameter. Its purpose is to perform max pooling on the inputs\nof non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net\nlayer mostly used in training a ', 'Fast R-CNN', ' network for object detection.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen it pools over sub-regions of input and produces a fixed-sized output array\nregardless of the ROI size.', '\n', 'To crop the feature map accordingly, you can resize the bounding box coordinates\nby changing the parameters ', 'rois', ' and ', 'spatial_scale', '.', '\n', 'The cropped feature maps are pooled by standard max pooling operation to a fixed size output\nindicated by a ', 'pooled_size', ' parameter. batch_size will change to the number of region\nbounding boxes after ', 'ROIPooling', '.', '\n', 'The size of each region of interest doesnâ\x80\x99t have to be perfectly divisible by\nthe number of pooling sections(', 'pooled_size', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/roi_pooling.cc:L224', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, out=None, name=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', 'Reshapes the input array into a new shape.', '\n', None, '\n', '\n', 'You can use ', '0', ' to copy a particular dimension from the input to the output shape\nand â\x80\x98-1â\x80\x99 to infer the dimensions of the output.', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.SVMOutput(data=None, label=None, margin=_Null, regularization_coefficient=_Null, use_linear=_Null, out=None, name=None, **kwargs)Â¶","['Computes support vector machine based transformation of the input.', '\n', 'This tutorial demonstrates using SVM as output layer for classification instead of softmax:\n', 'https://github.com/apache/mxnet/tree/v1.x/example/svm_mnist', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SequenceLast(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Takes the last element of a sequence.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array\nof the form [batch_size, other_feature_dims].', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', ' should be\nan input array of positive ints of dimension [batch_size]. To use this parameter,\nset ', 'use_sequence_length', ' to ', 'True', ', otherwise each example in the batch is assumed\nto have the max sequence length.', '\n', '\n', 'Note', '\n', 'Alternatively, you can also use ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_last.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SequenceMask(data=None, sequence_length=None, use_sequence_length=_Null, value=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Sets all elements outside the sequence to a constant value.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', '\nshould be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length and\nthis operator works as the ', 'identity', ' operator.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_mask.cc:L185', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SequenceReverse(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Reverses the elements of each sequence.', '\n', 'This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]\nand returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences.\n', 'sequence_length', ' should be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_reverse.cc:L121', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SliceChannel(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, out=None, name=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Softmax(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, out=None, name=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SoftmaxActivation(data=None, mode=_Null, out=None, name=None, **kwargs)Â¶","['Applies softmax activation to input. This is intended for internal layers.', '\n', '\n', 'Note', '\n', 'This operator has been deprecated, please use ', '\n', '\n', 'If ', 'mode', ' = ', 'instance', ', this operator will compute a softmax for each instance in the batch.\nThis is the default mode.', '\n', 'If ', 'mode', ' = ', 'channel', ', this operator will compute a k-class softmax at each position\nof each instance, where ', 'k', ' = ', 'num_channel', '. This mode can only be used when the input array\nhas at least 3 dimensions.\nThis can be used for ', 'fully convolutional network', ', ', 'image segmentation', ', etc.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax_activation.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SoftmaxOutput(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, out=None, name=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SpatialTransformer(data=None, loc=None, target_shape=_Null, transform_type=_Null, sampler_type=_Null, cudnn_off=_Null, out=None, name=None, **kwargs)Â¶","['Applies a spatial transformer to input feature map.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.SwapAxis(data=None, dim1=_Null, dim2=_Null, out=None, name=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.UpSampling(*data, **kwargs)Â¶","['Upsamples the given input data.', '\n', 'Two algorithms (', 'sample_type', ') are available for upsampling:', '\n', '\n', 'Nearest Neighbor', '\n', 'Bilinear', '\n', '\n', 'Nearest Neighbor Upsampling', '\n', 'Input data is expected to be NCHW.', '\n', 'Example:', '\n', None, '\n', '\n', 'Bilinear Upsampling', '\n', 'Uses ', 'deconvolution', ' algorithm under the hood. You need provide both input data and the kernel.', '\n', 'Input data is expected to be NCHW.', '\n', 'num_filter', ' is expected to be same as the number of channels.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/upsampling.cc:L172', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.abs(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise absolute value of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'abs', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L720', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.adam_update(weight=None, grad=None, mean=None, var=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Adam optimizer. Adam is seen as a generalization\nof AdaGrad.', '\n', 'Adam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nW_t = W_{t-1} - \\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon }\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and the storage\ntype of weight is the same as those of m and v,\nonly the row slices whose indices appear in grad.indices are updated (for w, m and v):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L687', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.add_n(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.all_finite(data=None, init_output=_Null, out=None, name=None, **kwargs)Â¶","['Check if all the float numbers in the array are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.amp_cast(data=None, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Cast function between low precision float/FP32 used by AMP.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L125', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.amp_multicast(*data, **kwargs)Â¶","['Cast function used by AMP, that casts its inputs to the common widest type.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L169', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.arccos(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse cosine of the input array.', '\n', 'The input should be in range ', '[-1, 1]', '.\nThe output is in the closed interval ', '\\([0, \\pi]\\)', '\n', '\n\\[arccos([-1, -.707, 0, .707, 1]) = [\\pi, 3\\pi/4, \\pi/2, \\pi/4, 0]\\]', '\n', 'The storage type of ', 'arccos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.arccosh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arccosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L535', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.arcsin(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse sine of the input array.', '\n', 'The input should be in the range ', '[-1, 1]', '.\nThe output is in the closed interval of [', '\\(-\\pi/2\\)', ', ', '\\(\\pi/2\\)', '].', '\n', '\n\\[arcsin([-1, -.707, 0, .707, 1]) = [-\\pi/2, -\\pi/4, 0, \\pi/4, \\pi/2]\\]', '\n', 'The storage type of ', 'arcsin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.arcsinh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arcsinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.arctan(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse tangent of the input array.', '\n', 'The output is in the closed interval ', '\\([-\\pi/2, \\pi/2]\\)', '\n', '\n\\[arctan([-1, 0, 1]) = [-\\pi/4, 0, \\pi/4]\\]', '\n', 'The storage type of ', 'arctan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L282', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.arctanh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.', '\n', 'The storage type of ', 'arctanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L579', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.argmax(data=None, axis=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Returns indices of the maximum values along an axis.', '\n', 'In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L51', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.argmax_channel(data=None, out=None, name=None, **kwargs)Â¶","['Returns argmax indices of each channel from the input array.', '\n', 'The result will be an NDArray of shape (num_channel,).', '\n', 'In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.argmin(data=None, axis=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Returns indices of the minimum values along an axis.', '\n', 'In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.argsort(data=None, axis=_Null, is_ascend=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Returns the indices that would sort an input array along the given axis.', '\n', 'This function performs sorting along the given axis and returns an array of indices having same shape\nas an input array that index data in sorted order.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L184', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.batch_dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, out=None, name=None, **kwargs)Â¶","['Batchwise dot product.', '\n', 'batch_dot', ' is used to compute dot product of ', 'x', ' and ', 'y', ' when ', 'x', ' and\n', 'y', ' are data in batch, namely N-D (N >= 3) arrays in shape of ', '(B0, â\x80¦, B_i, :, :)', '.', '\n', 'For example, given ', 'x', ' with shape ', '(B_0, â\x80¦, B_i, N, M)', ' and ', 'y', ' with shape\n', '(B_0, â\x80¦, B_i, M, K)', ', the result array will have shape ', '(B_0, â\x80¦, B_i, N, K)', ',\nwhich is computed by:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L127', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.batch_take(a=None, indices=None, out=None, name=None, **kwargs)Â¶","['Takes elements from a data batch.', '\n', '\n', 'Note', '\n', 'batch_take', '\n', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_add(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_axes(data=None, axis=_Null, size=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_axis(data=None, axis=_Null, size=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_div(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_div(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'equal to', ' (==) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L45', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_greater(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than', ' (>) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L81', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_greater_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than or equal to', ' (>=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_hypot(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the hypotenuse of a right angled triangle, given its â\x80\x9clegsâ\x80\x9d\nwith broadcasting.', '\n', 'It is equivalent to doing ', '\\(sqrt(x_1^2 + x_2^2)\\)', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_lesser(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than', ' (<) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L117', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_lesser_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than or equal to', ' (<=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_like(lhs=None, rhs=None, lhs_axes=_Null, rhs_axes=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts lhs to have the same shape as rhs.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_logical_and(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical and', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_logical_or(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical or', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L171', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_logical_xor(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical xor', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L189', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_maximum(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise maximum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise maxima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_minimum(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise minimum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise minima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_minus(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_mod(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise modulo of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_mul(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_mul(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L145', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_not_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'not equal to', ' (!=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L63', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_plus(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_power(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns result of first array elements raised to powers from second array, element-wise with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L44', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_sub(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.broadcast_to(data=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts the input array to a new shape.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'The dimension which you do not want to change can also be kept as ', '0', ' which means copy the original value.\nSo with ', 'shape=(2,0)', ', we will obtain the same result as in the above example.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.cast(data=None, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.cast_storage(data=None, stype=_Null, out=None, name=None, **kwargs)Â¶","['Casts tensor storage type to the new type.', '\n', 'When an NDArray with default storage type is cast to csr or row_sparse storage,\nthe result is compact, which means:', '\n', '\n', 'for csr, zero values will not be retained', '\n', 'for row_sparse, row slices of all zeros will not be retained', '\n', '\n', 'The storage type of ', 'cast_storage', ' output depends on stype parameter:', '\n', '\n', 'cast_storage(csr, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(row_sparse, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(default, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(default, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', 'cast_storage(csr, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(row_sparse, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/cast_storage.cc:L71', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.cbrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise cube-root value of the input.', '\n', '\n\\[cbrt(x) = \\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'cbrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L270', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ceil(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise ceiling of the input.', '\n', 'The ceil of the scalar x is the smallest integer i, such that i >= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'ceil', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L817', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.choose_element_0index(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.clip(data=None, a_min=_Null, a_max=_Null, out=None, name=None, **kwargs)Â¶","['Clips (limits) the values in an array.\nGiven an interval, values outside the interval are clipped to the interval edges.\nClipping ', 'x', ' between ', 'a_min', ' and ', 'a_max', ' would be::\n.. math:', '\n', None, '\n', '\n', '\n', 'Example::', 'x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nclip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]', '\n', '\n', 'The storage type of ', 'clip', ' output depends on storage types of inputs and the a_min, a_max parameter values:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L676', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.col2im(data=None, output_size=_Null, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, out=None, name=None, **kwargs)Â¶","['Combining the output column matrix of im2col back to image array.', '\n', 'Like ', 'im2col', ', this operator is also used in the vanilla convolution\nimplementation. Despite the name, col2im is not the reverse operation of im2col. Since there\nmay be overlaps between neighbouring sliding blocks, the column elements cannot be directly\nput back into image. Instead, they are accumulated (i.e., summed) in the input image\njust like the gradient computation, so col2im is the gradient of im2col and vice versa.', '\n', 'Using the notation in im2col, given an input column array of shape\n', '\\((N, C \\times  \\prod(\\text{kernel}), W)\\)', ', this operator accumulates the column elements\ninto output array of shape ', '\\((N, C, \\text{output_size}[0], \\text{output_size}[1], \\dots)\\)', '.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L181', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.cos(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise cosine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[cos([0, \\pi/4, \\pi/2]) = [1, 0.707, 0]\\]', '\n', 'The storage type of ', 'cos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.cosh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic cosine  of the input array, computed element-wise.', '\n', '\n\\[cosh(x) = 0.5\\times(exp(x) + exp(-x))\\]', '\n', 'The storage type of ', 'cosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L409', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.crop(data=None, begin=_Null, end=_Null, step=_Null, out=None, name=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.cumsum(a=None, axis=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Return the cumulative sum of the elements along a given axis.', '\n', 'Defined in src/operator/numpy/np_cumsum.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.degrees(data=None, out=None, name=None, **kwargs)Â¶","['Converts each element of the input array from radians to degrees.', '\n', '\n\\[degrees([0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]) = [0, 90, 180, 270, 360]\\]', '\n', 'The storage type of ', 'degrees', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.depth_to_space(data=None, block_size=_Null, out=None, name=None, **kwargs)Â¶","['Rearranges(permutes) data from depth into blocks of spatial data.\nSimilar to ONNX DepthToSpace operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace', '.\nThe output is a new tensor where the values from depth dimension are moved in spatial blocks\nto height and width dimension. The reverse of this operation is ', 'space_to_depth', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C / (block\\_size ^ 2), H * block\\_size, W * block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L971', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.diag(data=None, k=_Null, axis1=_Null, axis2=_Null, out=None, name=None, **kwargs)Â¶","['Extracts a diagonal or constructs a diagonal array.', '\n', 'diag', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.', '\n', 'N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/diag_op.cc:L86', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, out=None, name=None, **kwargs)Â¶","['Dot product of two arrays.', '\n', 'dot', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: inner product of vectors', '\n', '2-D arrays: matrix multiplication', '\n', 'N-D arrays: a sum product over the last axis of the first input and the first\naxis of the second input', '\n', '\n', 'The storage type of ', 'dot', ' output depends on storage types of inputs, transpose option and\nforward_stype option for output storage type. Implemented sparse operations include:', '\n', '\n', 'dot(default, default, transpose_a=True/False, transpose_b=True/False) = default', '\n', 'dot(csr, default, transpose_a=True) = default', '\n', 'dot(csr, default, transpose_a=True) = row_sparse', '\n', 'dot(csr, default) = default', '\n', 'dot(csr, row_sparse) = default', '\n', 'dot(default, csr) = csr (CPU only)', '\n', 'dot(default, csr, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', 'dot(default, csr, transpose_b=True, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', '\n', 'If the combination of input storage types and forward_stype does not match any of the\nabove patterns, ', 'dot', ' will fallback and generate output with default storage.', '\n', '\n', 'Note', '\n', 'If the storage type of the lhs is â\x80\x9ccsrâ\x80\x9d, the storage type of gradient w.r.t rhs will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.elemwise_add(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Adds arguments element-wise.', '\n', 'The storage type of ', 'elemwise_add', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> x=mx.nd.array([1,2,3,4])
>>> y=mx.nd.array([1.1,2.1,3.1,4.1])
>>> mx.nd.elemwise_add(x,y).asnumpy()
array([ 2.0999999 ,  4.0999999 ,  6.0999999 ,  8.10000038], dtype=float32)
",,
"
mxnet.ndarray.elemwise_div(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Divides arguments element-wise.', '\n', 'The storage type of ', 'elemwise_div', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.elemwise_mul(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Multiplies arguments element-wise.', '\n', 'The storage type of ', 'elemwise_mul', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.elemwise_sub(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Subtracts arguments element-wise.', '\n', 'The storage type of ', 'elemwise_sub', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.erf(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L886', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.erfinv(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L908', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.exp(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise exponential value of the input.', '\n', '\n\\[exp(x) = e^x \\approx 2.718^x\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'exp', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L64', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.expand_dims(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Inserts a new axis of size 1 into the array shape\nFor example, given ', 'x', ' with shape ', '(2,3,4)', ', then ', 'expand_dims(x,', '\nwill return a new array with shape ', '(2,1,3,4)', '.', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L394', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.expm1(data=None, out=None, name=None, **kwargs)Â¶","['Returns ', 'exp(x)', ' computed element-wise on the input.', '\n', 'This function provides greater precision than ', 'exp(x)', ' for small values of ', 'x', '.', '\n', 'The storage type of ', 'expm1', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.fill_element_0index(lhs=None, mhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.fix(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer towards zero of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'fix', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L874', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.flatten(data=None, out=None, name=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.flip(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.floor(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise floor of the input.', '\n', 'The floor of the scalar x is the largest integer i, such that i <= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'floor', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L836', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ftml_update(weight=None, grad=None, d=None, v=None, z=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, wd=_Null, rescale_grad=_Null, clip_grad=_Null, out=None, name=None, **kwargs)Â¶","['The FTML optimizer described in\n', 'FTML - Follow the Moving Leader in Deep Learning', ',\navailable at ', 'http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf', '.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nd_t = \\frac{ 1 - \\beta_1^t }{ \\eta_t } (\\sqrt{ \\frac{ v_t }{ 1 - \\beta_2^t } } + \\epsilon)\n\\sigma_t = d_t - \\beta_1 d_{t-1}\nz_t = \\beta_1 z_{ t-1 } + (1 - \\beta_1^t) g_t - \\sigma_t W_{t-1}\nW_t = - \\frac{ z_t }{ d_t }\\end{split}\\]', '\n', 'Defined in src/operator/optimizer_op.cc:L639', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ftrl_update(weight=None, grad=None, z=None, n=None, lr=_Null, lamda1=_Null, beta=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Ftrl optimizer.\nReferenced from ', 'Ad Click Prediction: a View from the Trenches', ', available at\n', 'http://dl.acm.org/citation.cfm?id=2488200', '.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'If w, z and n are all of ', 'row_sparse', ' storage type,\nonly the row slices whose indices appear in grad.indices are updated (for w, z and n):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L875', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.gamma(data=None, out=None, name=None, **kwargs)Â¶","['Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.', '\n', 'The storage type of ', 'gamma', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.gammaln(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise log of the absolute value of the gamma function of the input.', '\n', 'The storage type of ', 'gammaln', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.gather_nd(data=None, indices=None, out=None, name=None, **kwargs)Â¶","['Gather elements or slices from ', 'data', ' and store to a tensor whose\nshape is defined by ', 'indices', '.', '\n', 'Given ', 'data', ' with shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', output shape will simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.hard_sigmoid(data=None, alpha=_Null, beta=_Null, out=None, name=None, **kwargs)Â¶","['Computes hard sigmoid of x element-wise.', '\n', '\n\\[y = max(0, min(1, alpha * x + beta))\\]', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L161', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.identity(data=None, out=None, name=None, **kwargs)Â¶","['Returns a copy of the input.', '\n', 'From:src/operator/tensor/elemwise_unary_op_basic.cc:244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.im2col(data=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, out=None, name=None, **kwargs)Â¶","['Extract sliding blocks from input array.', '\n', 'This operator is used in vanilla convolution implementation to transform the sliding\nblocks on image to column matrix, then the convolution operation can be computed\nby matrix multiplication between column and convolution weight. Due to the close\nrelation between im2col and convolution, the concept of ', 'kernel', ', ', 'stride', ',\n', 'dilate', ' and ', 'pad', ' in this operator are inherited from convolution operation.', '\n', 'Given the input data of shape ', '\\((N, C, *)\\)', ', where ', '\\(N\\)', ' is the batch size,\n', '\\(C\\)', ' is the channel size, and ', '\\(*\\)', ' is the arbitrary spatial dimension,\nthe output column array is always with shape ', '\\((N, C \\times \\prod(\\text{kernel}), W)\\)', ',\nwhere ', '\\(C \\times \\prod(\\text{kernel})\\)', ' is the block size, and ', '\\(W\\)', ' is the\nblock number which is the spatial size of the convolution output with same input parameters.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.khatri_rao(*args, **kwargs)Â¶","['Computes the Khatri-Rao product of the input matrices.', '\n', 'Given a collection of ', '\\(n\\)', ' input matrices,', '\n', '\n\\[A_1 \\in \\mathbb{R}^{M_1 \\times M}, \\ldots, A_n \\in \\mathbb{R}^{M_n \\times N},\\]', '\n', 'the (column-wise) Khatri-Rao product is defined as the matrix,', '\n', '\n\\[X = A_1 \\otimes \\cdots \\otimes A_n \\in \\mathbb{R}^{(M_1 \\cdots M_n) \\times N},\\]', '\n', 'where the ', '\\(k\\)', ' th column is equal to the column-wise outer product\n', '\\({A_1}_k \\otimes \\cdots \\otimes {A_n}_k\\)', ' where ', '\\({A_i}_k\\)', ' is the kth\ncolumn of the ith matrix.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/krprod.cc:L108', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.lamb_update_phase1(weight=None, grad=None, mean=None, var=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Phase I of lamb update it performs the following operations and returns g:.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\ngrad = grad * rescale_grad\nif (grad < -clip_gradient)\nthen\n     grad = -clip_gradient\nif (grad > clip_gradient)\nthen\n     grad = clip_gradient\\\\mean = beta1 * mean + (1 - beta1) * grad;\nvariance = beta2 * variance + (1. - beta2) * grad ^ 2;\\\\if (bias_correction)\nthen\n     mean_hat = mean / (1. - beta1^t);\n     var_hat = var / (1 - beta2^t);\n     g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;\nelse\n     g = mean / (var_data^(1/2) + epsilon) + wd * weight;\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L952', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.lamb_update_phase2(weight=None, g=None, r1=None, r2=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, out=None, name=None, **kwargs)Â¶","['Phase II of lamb update it performs the following operations and updates grad.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\nif (lower_bound >= 0)\nthen\n     r1 = max(r1, lower_bound)\nif (upper_bound >= 0)\nthen\n     r1 = max(r1, upper_bound)\\\\if (r1 == 0 or r2 == 0)\nthen\n     lr = lr\nelse\n     lr = lr * (r1/r2)\nweight = weight - lr * g\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L991', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_det(A=None, out=None, name=None, **kwargs)Â¶","['Compute the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'det', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'There is no gradient backwarded when A is non-invertible (which is\nequivalent to det(A) = 0) because zero is rarely hit upon in float\npoint computation and the Jacobiâ\x80\x99s formula on determinant gradient\nis not computationally efficient when A is non-invertible.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L974', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_extractdiag(A=None, offset=_Null, out=None, name=None, **kwargs)Â¶","['Extracts the diagonal entries of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an ', 'n-1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_extracttrian(A=None, offset=_Null, lower=_Null, out=None, name=None, **kwargs)Â¶","['Extracts a triangular sub-matrix from a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an ', 'n-1', '-dimensional tensor.', '\n', 'The ', 'offset', ' and ', 'lower', ' parameters determine the triangle to be extracted:', '\n', '\n', 'When ', '\n', 'When ', '\n', 'When ', '\n', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L604', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_gelqf(A=None, out=None, name=None, **kwargs)Â¶","['LQ factorization for general matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', we compute the LQ factorization (LAPACK ', 'gelqf', ', followed by ', 'orglq', '). ', 'A', '\nmust have shape ', '(x, y)', ' with ', 'x <= y', ', and must have full rank ', '=x', '. The LQ\nfactorization consists of ', 'L', ' with shape ', '(x, x)', ' and ', 'Q', ' with shape ', '(x, y)', ', so\nthat:', '\n', '\n', 'A', '\n', 'Here, ', 'L', ' is lower triangular (upper triangle equal to zero) with nonzero diagonal,\nand ', 'Q', ' is row-orthonormal, meaning that', '\n', '\n', 'Q', '\n', 'is equal to the identity matrix of shape ', '(x, x)', '.', '\n', 'If ', 'n>2', ', ', 'gelqf', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L797', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_gemm(A=None, B=None, C=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, beta=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Performs general matrix multiplication and accumulation.\nInput are tensors ', 'A', ', ', 'B', ', ', 'C', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here, ', 'alpha', ' and ', 'beta', ' are scalar parameters, and ', 'op()', ' is either the identity or\nmatrix transposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ', ', 'C', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', ', 'C', ', axis=1) is equivalent\nto the following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_gemm2(A=None, B=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Performs general matrix multiplication.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here ', 'alpha', ' is a scalar parameter and ', 'op()', ' is either the identity or the matrix\ntransposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', axis=1) is equivalent to\nthe following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_inverse(A=None, out=None, name=None, **kwargs)Â¶","['Compute the inverse of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'inverse', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L919', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_makediag(A=None, offset=_Null, out=None, name=None, **kwargs)Â¶","['Constructs a square matrix with the input as diagonal.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.\nIf ', 'n>1', ', then ', 'A', ' represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_maketrian(A=None, offset=_Null, lower=_Null, out=None, name=None, **kwargs)Â¶","['Constructs a square matrix with the input representing a specific triangular sub-matrix.\nThis is basically the inverse of ', 'linalg.extracttrian', '. Input is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the entries of a triangular matrix which is lower triangular if ', 'offset<0', ' or ', 'offset=0', ', ', 'lower=true', '. The resulting matrix is derived by first constructing the square\nmatrix with the entries outside the triangle set to zero and then adding ', 'offset', '-times an additional\ndiagonal with zero entries to the square matrix.', '\n', 'If ', 'n>1', ', then ', 'A', ' represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L672', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_potrf(A=None, out=None, name=None, **kwargs)Â¶","['Performs Cholesky factorization of a symmetric positive-definite matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the Cholesky factor ', 'B', ' of the symmetric, positive definite matrix ', 'A', ' is\ncomputed. ', 'B', ' is triangular (entries of upper or lower triangle are all zero), has\npositive diagonal entries, and:', '\n', '\n', 'A', '\n', 'If ', 'n>2', ', ', 'potrf', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_potri(A=None, out=None, name=None, **kwargs)Â¶","['Performs matrix inversion from a Cholesky factorization.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a triangular matrix (entries of upper or lower triangle are all zero)\nwith positive diagonal. We compute:', '\n', '\n', 'out', '\n', 'In other words, if ', 'A', ' is the Cholesky factor of a symmetric positive definite matrix\n', 'B', ' (obtained by ', 'potrf', '), then', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'potri', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Use this operator only if you are certain you need the inverse of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L274', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_slogdet(A=None, out=None, name=None, **kwargs)Â¶","['Compute the sign and log of the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'sign', '\n', 'If ', 'n>2', ', ', 'slogdet', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'The gradient is not properly defined on sign, so the gradient of\nit is not backwarded.', '\n', '\n', '\n', 'Note', '\n', 'No gradient is backwarded when A is non-invertible. Please see\nthe docs of operator det for detail.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L1033', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_sumlogdiag(A=None, out=None, name=None, **kwargs)Â¶","['Computes the sum of the logarithms of the diagonal elements of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be square with positive diagonal entries. We sum the natural\nlogarithms of the diagonal elements, the result has shape (1,).', '\n', 'If ', 'n>2', ', ', 'sumlogdiag', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L444', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_syrk(A=None, transpose=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Multiplication of matrix with its transpose.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the operator performs the BLAS3 function ', 'syrk', ':', '\n', '\n', 'out', '\n', 'if ', 'transpose=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'transpose=True', '.', '\n', 'If ', 'n>2', ', ', 'syrk', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L729', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_trmm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Performs multiplication with a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trmm', ':', '\n', '\n', 'out', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trmm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg_trsm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Solves matrix equation involving a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trsm', ', solving for ', 'out', ' in:', '\n', '\n', 'op', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trsm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L395', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.log(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Natural logarithmic value of the input.', '\n', 'The natural logarithm is logarithm in base ', 'e', ', so that ', 'log(exp(x))', '\n', 'The storage type of ', 'log', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.log10(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Base-10 logarithmic value of the input.', '\n', '10**log10(x)', '\n', 'The storage type of ', 'log10', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.log1p(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise ', 'log(1', ' value of the input.', '\n', 'This function is more accurate than ', 'log(1', '  for small ', 'x', ' so that\n', '\\(1+x\\approx 1\\)', '\n', 'The storage type of ', 'log1p', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.log2(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Base-2 logarithmic value of the input.', '\n', '2**log2(x)', '\n', 'The storage type of ', 'log2', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.log_softmax(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, out=None, name=None, **kwargs)Â¶","['Computes the log softmax of the input.\nThis is equivalent to computing softmax followed by log.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.logical_not(data=None, out=None, name=None, **kwargs)Â¶","['Returns the result of logical NOT (!) function', '\n', 'Example', '\n', 'logical_not([-2., 0., 1.]) = [0., 1., 0.]', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.make_loss(data=None, out=None, name=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'make_loss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'The storage type of ', 'make_loss', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L358', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.max(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.max_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.mean(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the mean of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.min(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.min_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.moments(data=None, axes=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Calculate the mean and variance of ', 'data', '.', '\n', 'The mean and variance are calculated by aggregating the contents of data across axes.\nIf x is 1-D and axes = [0] this is just the mean and variance of a vector.', '\n', 'Example', '\n', 'x = [[1, 2, 3], [4, 5, 6]]\nmean, var = moments(data=x, axes=[0])\nmean = [2.5, 3.5, 4.5]\nvar = [2.25, 2.25, 2.25]\nmean, var = moments(data=x, axes=[1])\nmean = [2.0, 5.0]\nvar = [0.66666667, 0.66666667]\nmean, var = moments(data=x, axis=[0, 1])\nmean = [3.5]\nvar = [2.9166667]', '\n', 'Defined in src/operator/nn/moments.cc:L53', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.mp_lamb_update_phase1(weight=None, grad=None, mean=None, var=None, weight32=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Mixed Precision version of Phase I of lamb update\nit performs the following operations and returns g:.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1032', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.mp_lamb_update_phase2(weight=None, g=None, r1=None, r2=None, weight32=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, out=None, name=None, **kwargs)Â¶","['Mixed Precision version Phase II of lamb update\nit performs the following operations and updates grad.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1074', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.mp_nag_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.', '\n', 'Defined in src/operator/optimizer_op.cc:L744', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.mp_sgd_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.mp_sgd_update(weight=None, grad=None, weight32=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.multi_all_finite(*data, **kwargs)Â¶","['Check if all the float numbers in all the arrays are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.multi_lars(lrs=None, weights_sum_sq=None, grads_sum_sq=None, wds=None, eta=_Null, eps=_Null, rescale_grad=_Null, out=None, name=None, **kwargs)Â¶","['Compute the LARS coefficients of multiple weights and grads from their sums of squareâ\x80\x9d', '\n', 'Defined in src/operator/contrib/multi_lars.cc:L36', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L471', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L373', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L328', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.multi_sum_sq(*data, **kwargs)Â¶","['Compute the sums of squares of multiple arrays', '\n', 'Defined in src/operator/contrib/multi_sum_sq.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.nag_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Nesterov Accelerated Gradient( NAG) optimizer.\nIt updates the weights using the following formula,', '\n', '\n\\[\\begin{split}v_t = \\gamma v_{t-1} + \\eta * \\nabla J(W_{t-1} - \\gamma v_{t-1})\\\\\nW_t = W_{t-1} - v_t\\end{split}\\]', '\n', 'Where\n', '\\(\\eta\\)', ' is the learning rate of the optimizer\n', '\\(\\gamma\\)', ' is the decay rate of the momentum estimate\n', '\\(\\v_t\\)', ' is the update vector at time step ', 't', '\n', '\\(\\W_t\\)', ' is the weight vector at time step ', 't', '\n', 'Defined in src/operator/optimizer_op.cc:L725', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.nanprod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the product of array elements over given axes treating Not a Numbers (', 'NaN', ') as one.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_prod_value.cc:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.nansum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the sum of array elements over given axes treating Not a Numbers (', 'NaN', ') as zero.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.negative(data=None, out=None, name=None, **kwargs)Â¶","['Numerical negative of the argument, element-wise.', '\n', 'The storage type of ', 'negative', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.norm(data=None, ord=_Null, axis=_Null, out_dtype=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Computes the norm on an NDArray.', '\n', 'This operator computes the norm on an NDArray with the specified axis, depending\non the value of the ord parameter. By default, it computes the L2 norm on the entire\narray. Currently only ord=2 supports sparse ndarrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_norm_value.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.one_hot(indices=None, depth=_Null, on_value=_Null, off_value=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Returns a one-hot array.', '\n', 'The locations represented by ', 'indices', ' take value ', 'on_value', ', while all\nother locations take value ', 'off_value', '.', '\n', 'one_hot', ' operation with ', 'indices', ' of shape ', '(i0,', ' and ', 'depth', '  of ', 'd', ' would result\nin an output array of shape ', '(i0,', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L882', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ones_like(data=None, out=None, name=None, **kwargs)Â¶","['Return an array of ones with the same shape and type\nas the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, out=None, name=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.pick(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.preloaded_multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.preloaded_multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L139', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.preloaded_multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.preloaded_multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.prod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the product of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L30', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.radians(data=None, out=None, name=None, **kwargs)Â¶","['Converts each element of the input array from degrees to radians.', '\n', '\n\\[radians([0, 90, 180, 270, 360]) = [0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]\\]', '\n', 'The storage type of ', 'radians', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L351', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_exponential(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from an exponential distribution.', '\n', 'Samples are distributed according to an exponential distribution parametrized by ', 'lambda', ' (rate).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_gamma(alpha=_Null, beta=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a gamma distribution.', '\n', 'Samples are distributed according to a gamma distribution parametrized by ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L124', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_generalized_negative_binomial(mu=_Null, alpha=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a generalized negative binomial distribution.', '\n', 'Samples are distributed according to a generalized negative binomial distribution parametrized by\n', 'mu', ' (mean) and ', 'alpha', ' (dispersion). ', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_negative_binomial(k=_Null, p=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a negative binomial distribution.', '\n', 'Samples are distributed according to a negative binomial distribution parametrized by\n', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure probability in each experiment).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L163', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_dirichlet(sample=None, alpha=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nDirichlet distributions with parameter ', 'alpha', '.', '\n', 'The shape of ', 'alpha', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'alpha', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'alpha', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L315', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_exponential(sample=None, lam=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nexponential distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L304', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_gamma(sample=None, alpha=None, beta=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (rate).', '\n', 'alpha', ' and ', 'beta', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'alpha', ' and ', 'beta', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'alpha', ' and ', 'beta', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L302', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_generalized_negative_binomial(sample=None, mu=None, alpha=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean)\nand ', 'alpha', ' (dispersion).  This can be understood as a reparameterization of\nthe negative binomial, where ', 'k', ' = ', '1 / alpha', ' and ', 'p', ' = ', '1 / (mu * alpha + 1)', '.', '\n', 'mu', ' and ', 'alpha', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'alpha', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'alpha', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L313', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_negative_binomial(sample=None, k=None, p=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of samples of\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'k', ' and ', 'p', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'k', ' and ', 'p', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'k', ' and ', 'p', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L309', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_normal(sample=None, mu=None, sigma=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'mu', ' and ', 'sigma', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'sigma', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'sigma', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L299', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_poisson(sample=None, lam=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nPoisson distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L306', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_pdf_uniform(sample=None, low=None, high=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'low', ' and ', 'high', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'low', ' and ', 'high', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'low', ' and ', 'high', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L297', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_poisson(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a Poisson distribution.', '\n', 'Samples are distributed according to a Poisson distribution parametrized by ', 'lambda', ' (rate).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L149', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_randint(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a discrete uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L193', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random_uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ravel_multi_index(data=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.rcbrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse cube-root value of the input.', '\n', '\n\\[rcbrt(x) = 1/\\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L323', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.reciprocal(data=None, out=None, name=None, **kwargs)Â¶","['Returns the reciprocal of the argument, element-wise.', '\n', 'Calculates 1/x.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L43', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.relu(data=None, out=None, name=None, **kwargs)Â¶","['Computes rectified linear activation.', '\n', '\n\\[max(features, 0)\\]', '\n', 'The storage type of ', 'relu', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.repeat(data=None, repeats=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Repeats elements of an array.\nBy default, ', 'repeat', ' flattens the input array into 1-D and then repeats the\nelements:', '\n', None, '\n', '\n', '\n', 'The parameter ', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L743', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.reset_arrays(*data, **kwargs)Â¶","['Set to zero multiple arrays', '\n', 'Defined in src/operator/contrib/reset_arrays.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, out=None, name=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.reshape_like(lhs=None, rhs=None, lhs_begin=_Null, lhs_end=_Null, rhs_begin=_Null, rhs_end=_Null, out=None, name=None, **kwargs)Â¶","['Reshape some or all dimensions of ', 'lhs', ' to have the same shape as some or all dimensions of ', 'rhs', '.', '\n', 'Returns a ', 'view', ' of the ', 'lhs', ' array with a new shape without altering any data.', '\n', 'Example:', '\n', None, '\n', '\n', 'More precise control over how dimensions are inherited is achieved by specifying slices over the ', 'lhs', ' and ', 'rhs', ' array dimensions. Only the sliced ', 'lhs', ' dimensions are reshaped to the ', 'rhs', ' sliced dimensions, with the non-sliced ', 'lhs', ' dimensions staying the same.', '\n', '\n', 'Examples:', '\n', 'Negative indices are supported, and ', 'None', ' can be used for either ', 'lhs_end', ' or ', 'rhs_end', ' to indicate the end of the range.', '\n', '\n', 'Example:', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L511', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.reverse(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.rint(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rint', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L798', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.rmsprop_update(weight=None, grad=None, n=None, lr=_Null, gamma1=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, out=None, name=None, **kwargs)Â¶","['Update function for ', 'RMSProp', ' optimizer.', '\n', 'RMSprop', ' is a variant of stochastic gradient descent where the gradients are\ndivided by a cache which grows with the sum of squares of recent gradients?', '\n', 'RMSProp', ' is similar to ', 'AdaGrad', ', a popular variant of ', 'SGD', ' which adaptively\ntunes the learning rate of each parameter. ', 'AdaGrad', ' lowers the learning rate for\neach parameter monotonically over the course of training.\nWhile this is analytically motivated for convex optimizations, it may not be ideal\nfor non-convex problems. ', 'RMSProp', ' deals with this heuristically by allowing the\nlearning rates to rebound as the denominator decays over time.', '\n', 'Define the Root Mean Square (RMS) error criterion of the gradient as\n', '\\(RMS[g]_t = \\sqrt{E[g^2]_t + \\epsilon}\\)', ', where ', '\\(g\\)', ' represents\ngradient and ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient.', '\n', 'The ', '\\(E[g^2]_t\\)', ' is given by:', '\n', '\n\\[E[g^2]_t = \\gamma * E[g^2]_{t-1} + (1-\\gamma) * g_t^2\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t - \\frac{\\eta}{RMS[g]_t} g_t\\]', '\n', 'The RMSProp code follows the version in\n', 'http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf', '\nTieleman & Hinton, 2012.', '\n', 'Hinton suggests the momentum term ', '\\(\\gamma\\)', ' to be 0.9 and the learning rate\n', '\\(\\eta\\)', ' to be 0.001.', '\n', 'Defined in src/operator/optimizer_op.cc:L796', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.rmspropalex_update(weight=None, grad=None, n=None, g=None, delta=None, lr=_Null, gamma1=_Null, gamma2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, out=None, name=None, **kwargs)Â¶","['Update function for RMSPropAlex optimizer.', '\n', 'RMSPropAlex', ' is non-centered version of ', 'RMSProp', '.', '\n', 'Define ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient and\n', '\\(E[g]_t\\)', ' is the decaying average over past gradient.', '\n', '\n\\[\\begin{split}E[g^2]_t = \\gamma_1 * E[g^2]_{t-1} + (1 - \\gamma_1) * g_t^2\\\\\nE[g]_t = \\gamma_1 * E[g]_{t-1} + (1 - \\gamma_1) * g_t\\\\\n\\Delta_t = \\gamma_2 * \\Delta_{t-1} - \\frac{\\eta}{\\sqrt{E[g^2]_t - E[g]_t^2 + \\epsilon}} g_t\\\\\\end{split}\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t + \\Delta_t\\]', '\n', 'The RMSPropAlex code follows the version in\n', 'http://arxiv.org/pdf/1308.0850v5.pdf', ' Eq(38) - Eq(45) by Alex Graves, 2013.', '\n', 'Graves suggests the momentum term ', '\\(\\gamma_1\\)', ' to be 0.95, ', '\\(\\gamma_2\\)', '\nto be 0.9 and the learning rate ', '\\(\\eta\\)', ' to be 0.0001.', '\n', 'Defined in src/operator/optimizer_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.round(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'round', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L777', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.rsqrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse square-root value of the input.', '\n', '\n\\[rsqrt(x) = 1/\\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rsqrt', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_exponential(lam=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nexponential distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_gamma(alpha=None, beta=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L281', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_generalized_negative_binomial(mu=None, alpha=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean) and ', 'alpha', ' (dispersion).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L292', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_multinomial(data=None, shape=_Null, get_prob=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple multinomial distributions.', '\n', 'data', ' is an ', 'n', ' dimensional array whose last dimension has length ', 'k', ', where\n', 'k', ' is the number of possible outcomes of each multinomial distribution. This\noperator will draw ', 'shape', ' samples from each distribution. If shape is empty\none sample will be drawn from each distribution.', '\n', 'If ', 'get_prob', ' is true, a second array containing log likelihood of the drawn\nsamples will also be returned. This is usually used for reinforcement learning\nwhere you can provide reward as head gradient for this array to estimate\ngradient.', '\n', 'Note that the input distribution must be normalized, i.e. ', 'data', ' must sum to\n1 along its last axis.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_negative_binomial(k=None, p=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L288', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_normal(mu=None, sigma=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L278', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_poisson(lam=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nPoisson distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L285', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sample_uniform(low=None, high=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L276', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.scatter_nd(data=None, indices=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Scatters data into a new tensor according to indices.', '\n', 'Given ', 'data', ' with shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', data shape should simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'all other entries in output are 0.', '\n', '\n', 'Warning', '\n', 'If the indices have duplicates, the result will be non-deterministic and\nthe gradient of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sgd_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and weightâ\x80\x99s storage\ntype is the same as momentumâ\x80\x99s storage type,\nonly the row slices whose indices appear in grad.indices are updated (for both weight and momentum):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L564', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradient is of ', 'row_sparse', ' storage type and ', 'lazy_update', ' is True,\nonly the row slices whose indices appear in grad.indices are updated:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L523', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.shape_array(data=None, out=None, name=None, **kwargs)Â¶","['Returns a 1D int64 array containing the shape of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L573', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.shuffle(data=None, out=None, name=None, **kwargs)Â¶","['Randomly shuffle the elements.', '\n', 'This shuffles the array along the first axis.\nThe order of the elements in each subarray does not change.\nFor example, if a 2D array is given, the order of the rows randomly changes,\nbut the order of the elements in each row does not change.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sigmoid(data=None, out=None, name=None, **kwargs)Â¶","['Computes sigmoid of x element-wise.', '\n', '\n\\[y = 1 / (1 + exp(-x))\\]', '\n', 'The storage type of ', 'sigmoid', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sign(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sign of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sign', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L758', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.signsgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for SignSGD optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(g_t)\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L62', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.signum_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, wd_lh=_Null, out=None, name=None, **kwargs)Â¶","['SIGN momentUM (Signum) optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta m_{t-1} + (1 - \\beta) g_t\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(m_t)\\end{split}\\]', '\n', '\n', 'It updates the weights using::', 'state = momentum * state + (1-momentum) * gradient\nweight = weight - learning_rate * sign(state)', '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L91', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sin(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise sine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[sin([0, \\pi/4, \\pi/2]) = [0, 0.707, 1]\\]', '\n', 'The storage type of ', 'sin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L47', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sinh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic sine of the input array, computed element-wise.', '\n', '\n\\[sinh(x) = 0.5\\times(exp(x) - exp(-x))\\]', '\n', 'The storage type of ', 'sinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L371', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.size_array(data=None, out=None, name=None, **kwargs)Â¶","['Returns a 1D int64 array containing the size of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.slice(data=None, begin=_Null, end=_Null, step=_Null, out=None, name=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.slice_axis(data=None, axis=_Null, begin=_Null, end=_Null, out=None, name=None, **kwargs)Â¶","['Slices along a given axis.\nReturns an array slice along a given ', 'axis', ' starting from the ', 'begin', ' index\nto the ', 'end', ' index.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L570', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.slice_like(data=None, shape_like=None, axes=_Null, out=None, name=None, **kwargs)Â¶","['Slices a region of the array like the shape of another array.\nThis function is similar to ', 'slice', ', however, the ', 'begin', ' are always ', '0`s\nand `end', ' of specific axes are inferred from the second input ', 'shape_like', '.\nGiven the second ', 'shape_like', ' input of ', 'shape=(d_0,', ',\na ', 'slice_like', ' operator with default empty ', 'axes', ', it performs the\nfollowing operation:\n`` out = slice(input, begin=(0, 0, â\x80¦, 0), end=(d_0, d_1, â\x80¦, d_n-1))``.\nWhen ', 'axes', ' is not empty, it is used to speficy which axes are being sliced.\nGiven a 4-d input data, ', 'slice_like', ' operator with ', 'axes=(0,', '\nwill perform the following operation:\n`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.\nNote that it is allowed to have first and second input with different dimensions,\nhowever, you have to make sure the ', 'axes', ' are specified and not exceeding the\ndimension limits.\nFor example, given ', 'input_1', ' with ', 'shape=(2,3,4,5)', ' and ', 'input_2', ' with\n', 'shape=(1,2,3)', ', it is not allowed to use:\n`` out = slice_like(a, b)`` because ndim of ', 'input_1', ' is 4, and ndim of ', 'input_2', '\nis 3.\nThe following is allowed in this situation:\n`` out = slice_like(a, b, axes=(0, 2))``\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.smooth_l1(data=None, scalar=_Null, out=None, name=None, **kwargs)Â¶","['Calculate Smooth L1 Loss(lhs, scalar) by summing', '\n', '\n\\[\\begin{split}f(x) =\n\\begin{cases}\n(\\sigma x)^2/2,& \\text{if }x < 1/\\sigma^2\\\\\n|x|-0.5/\\sigma^2,& \\text{otherwise}\n\\end{cases}\\end{split}\\]', '\n', 'where ', '\\(x\\)', ' is an element of the tensor ', 'lhs', ' and ', '\\(\\sigma\\)', ' is the scalar.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L108', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.softmax(data=None, length=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, out=None, name=None, **kwargs)Â¶","['Applies the softmax function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.', '\n', '\n\\[softmax(\\mathbf{z/t})_j = \\frac{e^{z_j/t}}{\\sum_{k=1}^K e^{z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.softmax_cross_entropy(data=None, label=None, out=None, name=None, **kwargs)Â¶","['Calculate cross entropy of softmax output and one-hot label.', '\n', '\n', 'This operator computes the cross entropy in two steps:\n- Applies softmax function on the input array.\n- Computes and returns the cross entropy loss between the softmax output and the labels.', '\n', 'The softmax function and cross entropy loss is given by:', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/loss_binary_op.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.softmin(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, out=None, name=None, **kwargs)Â¶","['Applies the softmin function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum\nup to 1.', '\n', '\n\\[softmin(\\mathbf{z/t})_j = \\frac{e^{-z_j/t}}{\\sum_{k=1}^K e^{-z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmin.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.softsign(data=None, out=None, name=None, **kwargs)Â¶","['Computes softsign of x element-wise.', '\n', '\n\\[y = x / (1 + abs(x))\\]', '\n', 'The storage type of ', 'softsign', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L191', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sort(data=None, axis=_Null, is_ascend=_Null, out=None, name=None, **kwargs)Â¶","['Returns a sorted copy of an input array along the given axis.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.space_to_depth(data=None, block_size=_Null, out=None, name=None, **kwargs)Â¶","['Rearranges(permutes) blocks of spatial data into depth.\nSimilar to ONNX SpaceToDepth operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth', '\nThe output is a new tensor where the values from height and width dimension are\nmoved to the depth dimension. The reverse of this operation is ', 'depth_to_space', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C * (block\\_size ^ 2), H / block\\_size, W / block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L1018', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.split(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, out=None, name=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sqrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise square-root value of the input.', '\n', '\n\\[\\textrm{sqrt}(x) = \\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sqrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L170', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.square(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise squared value of the input.', '\n', '\n\\[square(x) = x^2\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'square', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.squeeze(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Remove single-dimensional entries from the shape of an array.\nSame behavior of defining the output tensor shape as numpy.squeeze for the most of cases.\nSee the following note for exception.\nExamples:', '\n', None, '\n', '\n', '\n', 'Note', '\n', 'The output of this operator will keep at least one dimension not removed. For example,\nsqueeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.stack(*data, **kwargs)Â¶","['Join a sequence of arrays along a new axis.\nThe axis parameter specifies the index of the new axis in the dimensions of the\nresult. For example, if axis=0 it will be the first dimension and if axis=-1 it\nwill be the last dimension.\nExamples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.stop_gradient(data=None, out=None, name=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sum_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.swapaxes(data=None, dim1=_Null, dim2=_Null, out=None, name=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.take(a=None, indices=None, axis=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Takes elements from an input array along the given axis.', '\n', 'This function slices the input array along a particular axis with the provided indices.', '\n', 'Given data tensor of rank r >= 1, and indices tensor of rank q, gather entries of the axis\ndimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them\nin an output tensor of rank q + (r - 1).', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of ', 'take', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L776', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.tan(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise tangent of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[tan([0, \\pi/4, \\pi/2]) = [0, 1, -inf]\\]', '\n', 'The storage type of ', 'tan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L140', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.tanh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic tangent of the input array, computed element-wise.', '\n', '\n\\[tanh(x) = sinh(x) / cosh(x)\\]', '\n', 'The storage type of ', 'tanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L451', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.tile(data=None, reps=_Null, out=None, name=None, **kwargs)Â¶","['Repeats the whole array multiple times.\nIf ', 'reps', ' has length ', 'd', ', and input array has dimension of ', 'n', '. There are\nthree cases:\n- ', 'n=d', '. Repeat ', 'i', '-th dimension of the input by ', 'reps[i]', ' times:', '\n', None, '\n', '\n', '\n', 'n>d', '\n', 'n<d', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L795', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.topk(data=None, axis=_Null, k=_Null, ret_typ=_Null, is_ascend=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Returns the indices of the top ', 'axis (by default).\nIf ret_type is set to â\x80\x98valueâ\x80\x99 returns the value of top ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.transpose(data=None, axes=_Null, out=None, name=None, **kwargs)Â¶","['Permutes the dimensions of an array.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L327', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.trunc(data=None, out=None, name=None, **kwargs)Â¶","['Return the element-wise truncated value of the input.', '\n', 'The truncated value of the scalar x is the nearest integer i which is closer to\nzero than x is. In short, the fractional part of the signed number x is discarded.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'trunc', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L856', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.unravel_index(data=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.where(condition=None, x=None, y=None, out=None, name=None, **kwargs)Â¶","['Return the elements, either from x or y, depending on the condition.', '\n', 'Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,\ndepending on the elements from condition are true or false. x and y must have the same shape.\nIf condition has the same shape as x, each element in the output array is from x if the\ncorresponding element in the condition is true, and from y if false.', '\n', 'If condition does not have the same shape as x, it must be a 1D array whose size is\nthe same as xâ\x80\x99s first dimension size. Each row of the output array is from xâ\x80\x99s row\nif the corresponding element from condition is true, and from yâ\x80\x99s row if false.', '\n', 'Note that all non-zero values are interpreted as ', 'True', ' in condition.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/control_flow_op.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.zeros_like(data=None, out=None, name=None, **kwargs)Â¶","['Return an array of zeros with the same shape, type and storage type\nas the input array.', '\n', 'The storage type of ', 'zeros_like', ' output depends on the storage type of the input', '\n', '\n', 'zeros_like(row_sparse) = row_sparse', '\n', 'zeros_like(csr) = csr', '\n', 'zeros_like(default) = default', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
class mxnet.ndarray.NDArray(handle, writable=True)[source]Â¶","['Bases: ', 'mxnet._ctypes.ndarray.NDArrayBase', '\n', 'An array object representing a multidimensional, homogeneous array of\nfixed-size items.', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Returns a copy of the array with axes transposed.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns an array on the target device with the same value as this array.', '\n', '\n', '\n', '\n', 'A convenience function for creating a classic ndarray from the current\nndarray with zero copy. For this class, it just returns itself since it is\nalready a classic ndarray.', '\n', '\n', '\n', '\n', 'Convert mxnet.ndarray.NDArray to mxnet.numpy.ndarray.', '\n', '\n', '\n', '\n', 'Returns a ', '\n', '\n', '\n', '\n', 'Returns a scalar whose value is copied from this array.', '\n', '\n', '\n', '\n', 'Returns a copy of the array after casting to a specified type.', '\n', '\n', '\n', '\n', 'Attach a gradient buffer to this NDArray, so that ', '\n', '\n', '\n', '\n', 'Compute the gradients of this NDArray w.r.t variables.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Broadcasts the input array to the shape of other.', '\n', '\n', '\n', '\n', 'Broadcasts the input array to a new shape.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Device context of the array.', '\n', '\n', '\n', '\n', 'Makes a copy of this ', '\n', '\n', '\n', '\n', 'Copies the value of this array to another array.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Device context of the array. Has the same meaning as context.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns a new NDArray, detached from the current graph.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Data-type of the arrayâ\x80\x99s elements.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Adds an additional dimension to the current array without altering any data.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Flatten this array without altering any data.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns gradient buffer attached to this NDArray.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns the number of dimensions of this array', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns a ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Tuple of array dimensions.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Number of elements in the array.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Assign the rhs to a cropped subset of this NDarray in place.\nReturns the view of this NDArray.', '\n', '\n', '\n', '\n', 'Assign the scalar to a cropped subset of this NDArray. Value will broadcast to the shape of the cropped shape\nand will be cast to the same dtype of the NDArray.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Remove dimensions with size 1 from this array without altering any data.', '\n', '\n', '\n', '\n', 'Storage-type of the array.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns a reference view of NDArray that represents as DLManagedTensor until\nall previous write operations on the current array are finished.', '\n', '\n', '\n', '\n', 'Returns a reference view of NDArray that represents as DLManagedTensor until\nall previous read/write operations on the current array are finished.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Return a copy of the array with chosen storage type.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Waits until all previous write operations on the current array are finished.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n']",,,
"
mxnet.ndarray.concatenate(arrays, axis=0, always_copy=True)[source]Â¶","['DEPRECATED, use ', 'concat', ' instead', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.ones(shape, ctx=None, dtype=None, **kwargs)[source]Â¶","['Returns a new array filled with all ones, with the given shape and type.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A new array of the specified shape filled with all ones.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.add(lhs, rhs)[source]Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ', ', 'mx.nd.broadcast_add(lhs,', ' and\n', 'mx.nd.broadcast_plus(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise sum of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.arange(start, stop=None, step=1.0, repeat=1, infer_range=None, ctx=None, dtype=<class 'numpy.float32'>)[source]Â¶","['Returns evenly spaced values within a given interval.', '\n', 'Values are generated within the half-open interval [', 'start', ', ', 'stop', '). In other\nwords, the interval includes ', 'start', ' but excludes ', 'stop', '. The function is\nsimilar to the built-in Python function ', 'range', ' and to ', 'numpy.arange', ',\nbut returns an ', 'NDArray', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'NDArray', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.linspace(start, stop, num, endpoint=True, ctx=None, dtype=<class 'numpy.float32'>)[source]Â¶","['Return evenly spaced numbers within a specified interval.', '\n', 'Values are generated within the half-open interval [', 'start', ', ', 'stop', ') or\nclosed interval [start, stop] depending on whether ', 'endpoint', ' is True or\nFalse. The function is similar to ', 'numpy.linspace', ', but returns an ', 'NDArray', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'NDArray', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.eye(N, M=0, k=0, ctx=None, dtype=None, **kwargs)[source]Â¶","['Return a 2-D array with ones on the diagonal and zeros elsewhere.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.divide(lhs, rhs)[source]Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_div(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise division of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.equal(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'equal to', ' (==) comparison operation with\nbroadcasting.', '\n', 'For each element in input arrays, return 1(true) if corresponding elements are same,\notherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_equal(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.full(shape, val, ctx=None, dtype=<class 'numpy.float32'>, out=None)[source]Â¶","['Returns a new array of given shape and type, filled with the given value ', 'val', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'NDArray', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.greater(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'greater than', ' (>) comparison operation\nwith broadcasting.', '\n', 'For each element in input arrays, return 1(true) if lhs elements are greater than rhs,\notherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_greater(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.greater_equal(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'greater than or equal to', ' (>=) comparison\noperation with broadcasting.', '\n', 'For each element in input arrays, return 1(true) if lhs elements are greater than equal to rhs,\notherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_greater_equal(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.imdecode(str_img, clip_rect=(0, 0, 0, 0), out=None, index=0, channels=3, mean=None)[source]Â¶","['DEPRECATED, use mx.img instead', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.ndarray.lesser(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'lesser than', ' (<) comparison operation\nwith broadcasting.', '\n', 'For each element in input arrays, return 1(true) if lhs elements are less than rhs,\notherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_lesser(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.lesser_equal(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'lesser than or equal to', ' (<=) comparison\noperation with broadcasting.', '\n', 'For each element in input arrays, return 1(true) if lhs elements are\nlesser than equal to rhs, otherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_lesser_equal(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.logical_and(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'logical and', ' comparison\noperation with broadcasting.', '\n', 'For each element in input arrays, return 1(true) if lhs elements and rhs elements\nare true, otherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_logical_and(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.logical_or(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'logical or', ' comparison\noperation with broadcasting.', '\n', 'For each element in input arrays, return 1(true) if lhs elements or rhs elements\nare true, otherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_logical_or(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.logical_xor(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'logical xor', ' comparison\noperation with broadcasting.', '\n', 'For each element in input arrays, return 1(true) if lhs elements or rhs elements\nare true, otherwise return 0(false).', '\n', 'Equivalent to ', 'bool(lhs)', ' and ', 'mx.nd.broadcast_logical_xor(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.maximum(lhs, rhs)[source]Â¶","['Returns element-wise maximum of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'mx.nd.broadcast_maximum(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise maximum of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.minimum(lhs, rhs)[source]Â¶","['Returns element-wise minimum of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'mx.nd.broadcast_minimum(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise minimum of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.moveaxis(tensor, source, destination)[source]Â¶","['Moves the ', 'source', ' axis into the ', 'destination', ' position\nwhile leaving the other axes in their original order', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'result', '\n', 'Return type', '\n', 'mx.nd.array', '\n', '\n', 'Examples', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.modulo(lhs, rhs)[source]Â¶","['Returns element-wise modulo of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_mod(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise modulo of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.multiply(lhs, rhs)[source]Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_mul(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise multiplication of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.not_equal(lhs, rhs)[source]Â¶","['Returns the result of element-wise ', 'not equal to', ' (!=) comparison operation\nwith broadcasting.', '\n', 'For each element in input arrays, return 1(true) if corresponding elements are different,\notherwise return 0(false).', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_not_equal(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Output array of boolean values.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.onehot_encode(indices, out)[source]Â¶","['One-hot encoding indices into matrix out.', '\n', '\n', 'Note', '\n', 'onehot_encode', '\n', '\n', '\n']",,,
"
mxnet.ndarray.power(base, exp)[source]Â¶","['Returns result of first array elements raised to powers from second array, element-wise\nwith broadcasting.', '\n', 'Equivalent to ', 'base', ' and ', 'mx.nd.broadcast_power(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The bases in x raised to the exponents in y.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.subtract(lhs, rhs)[source]Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ', ', 'mx.nd.broadcast_sub(lhs,', ' and\n', 'mx.nd.broadcast_minus(lhs,', '.', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise difference of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.true_divide(lhs, rhs)[source]Â¶","['This function is similar to ', 'divide()', '.', '\n', '\n']",,,
"
mxnet.ndarray.waitall()[source]Â¶","['Wait for all async operations to finish in MXNet.', '\n', 'This function is used for benchmarking only.', '\n', '\n', 'Note', '\n', 'If your mxnet code throws an exception, then waitall can cause performance impact.', '\n', '\n', '\n']",,,
"
mxnet.ndarray.histogram(a, bins=10, range=None)[source]Â¶","['Compute the histogram of the input data.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.split_v2(ary, indices_or_sections, axis=0, squeeze_axis=False)[source]Â¶","['Split an array into multiple sub-arrays.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.to_dlpack_for_read(data)[source]Â¶","['\n', 'Returns a reference view of NDArray that represents as DLManagedTensor until', 'all previous write operations on the current array are finished.', '\n', '\n', '\n', 'Parameters', '\n', 'data', '\n', 'Returns', '\n', 'a reference view of NDArray that represents as DLManagedTensor.', '\n', 'Return type', '\n', 'PyCapsule (the pointer of DLManagedTensor)', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.to_dlpack_for_write(data)[source]Â¶","['\n', 'Returns a reference view of NDArray that represents as DLManagedTensor until', 'all previous read/write operations on the current array are finished.', '\n', '\n', '\n', 'Parameters', '\n', 'data', '\n', 'Returns', '\n', 'a reference view of NDArray that represents as DLManagedTensor.', '\n', 'Return type', '\n', 'PyCapsule (the pointer of DLManagedTensor)', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.from_dlpack(dlpack)[source]Â¶","['Returns a NDArray backed by a dlpack tensor.', '\n', '\n', 'Parameters', '\n', 'dlpack', '\n', 'Returns', '\n', 'a NDArray backed by a dlpack tensor', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.from_numpy(ndarray, zero_copy=True, array_cls=<class 'mxnet.ndarray.ndarray.NDArray'>)[source]Â¶","['Returns an MXNetâ\x80\x99s ndarray backed by numpyâ\x80\x99s ndarray.\nWhen ', 'zero_copy', ' is set to be true,\nthis API consumes numpyâ\x80\x99s ndarray and produces MXNetâ\x80\x99s ndarray\nwithout having to copy the content. In this case, we disallow\nusers to modify the given numpy ndarray, and it is suggested\nnot to read the numpy ndarray as well for internal correctness.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'a NDArray backed by a dlpack tensor', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.zeros(shape, ctx=None, dtype=None, stype=None, **kwargs)[source]Â¶","['Return a new array of given shape and type, filled with zeros.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.indexing_key_expand_implicit_axes(key, shape)[source]Â¶","['Make implicit axes explicit by adding ', 'slice(None)', '\nand convert boolean array to integer array through ', 'nonzero', '.', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.get_indexing_dispatch_code(key)[source]Â¶","['Returns a dispatch code for calling basic or advanced indexing functions.', '\n', '\n']",,,
"
mxnet.ndarray.get_oshape_of_gather_nd_op(dshape, ishape)[source]Â¶","['Given data and index shapes, get the output ', 'NDArray', ' shape.\nThis basically implements the infer shape logic of op gather_nd.', '\n', '\n']",,,
"
mxnet.ndarray.zeros(shape, ctx=None, dtype=None, stype=None, **kwargs)[source]","['Return a new array of given shape and type, filled with zeros.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.empty(shape, ctx=None, dtype=None, stype=None)[source]Â¶","['Returns a new array of given shape and type, without initializing entries.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.array(source_array, ctx=None, dtype=None)[source]Â¶","['Creates an array from any object exposing the array interface.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An array with the same contents as the ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.load(fname)[source]Â¶","['Loads an array from file.', '\n', 'See more details in ', 'save', '.', '\n', '\n', 'Parameters', '\n', 'fname', '\n', 'Returns', '\n', 'Loaded data.', '\n', 'Return type', '\n', 'list of NDArray, ', '\n', '\n', '\n']",,,
"
mxnet.ndarray.load_frombuffer(buf)[source]Â¶","['Loads an array dictionary or list from a buffer', '\n', 'See more details in ', 'save', '.', '\n', '\n', 'Parameters', '\n', 'buf', '\n', 'Returns', '\n', 'Loaded data.', '\n', 'Return type', '\n', 'list of NDArray, ', '\n', '\n', '\n']",,,
"
mxnet.ndarray.save(fname, data)[source]Â¶","['Saves a list of arrays or a dict of str->array to file.', '\n', 'Examples of filenames:', '\n', '\n', '/path/to/file', '\n', 's3://my-bucket/path/to/file', '\n', 'hdfs://path/to/file', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.rand_zipfian(true_classes, num_sampled, range_max, ctx=None)[source]Â¶","['Draw random samples from an approximately log-uniform or Zipfian distribution.', '\n', 'This operation randomly samples ', 'num_sampled', ' candidates the range of integers [0, range_max).\nThe elements of sampled_candidates are drawn with replacement from the base distribution.', '\n', 'The base distribution for this operator is an approximately log-uniform or Zipfian distribution:', '\n', 'P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)', '\n', 'This sampler is useful when the true classes approximately follow such a distribution.\nFor example, if the classes represent words in a lexicon sorted in decreasing order of     frequency. If your classes are not ordered by decreasing frequency, do not use this op.', '\n', 'Additionaly, it also returns the number of times each of the     true classes and the sampled classes is expected to occur.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.foreach(body, data, init_states)[source]Â¶","['Run a for loop with user-defined computation over NDArrays on dimension 0.', '\n', 'This operator simulates a for loop and body has the computation for an iteration\nof the for loop. It runs the computation in body on each slice from the input\nNDArrays.', '\n', 'body takes two arguments as input and outputs a tuple of two elements,\nas illustrated below:', '\n', None, '\n', '\n', 'data1 can be either an NDArray or a list of NDArrays. If data is an NDArray,\ndata1 is an NDArray. Otherwise, data1 is a list of NDArrays and has the same\nsize as data. states is a list of NDArrays and have the same size as init_states.\nSimilarly, out can be either an NDArray or a list of NDArrays, which are concatenated\nas the first output of foreach; states from the last execution of body\nare the second output of foreach.', '\n', 'The computation done by this operator is equivalent to the pseudo code below\nwhen the input data is NDArray:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.while_loop(cond, func, loop_vars, max_iterations=None)[source]Â¶","['Run a while loop with user-defined computation and loop condition.', '\n', 'This operator simulates a while loop which iterately does customized computation\nas long as the condition is satisfied.', '\n', 'loop_vars', ' is a list of NDArrays on which the computation uses.', '\n', 'cond', ' is a user-defined function, used as the loop condition.\nIt consumes ', 'loop_vars', ', and produces a scalar MXNet NDArray,\nindicating the termination of the loop.\nThe loop ends when ', 'cond', ' returns false (zero).\nThe ', 'cond', ' is variadic, and its signature should be\n', 'cond(*loop_vars) => NDArray', '.', '\n', 'func', ' is a user-defined function, used as the loop body.\nIt also consumes ', 'loop_vars', ', and produces ', 'step_output', ' and ', 'new_loop_vars', ' at each step.\nIn each step, ', 'step_output', ' should contain the same number elements.\nThrough all steps, the i-th element of ', 'step_output', ' should have the same shape and dtype.\nAlso, ', 'new_loop_vars', ' should contain the same number of elements as ', 'loop_vars', ',\nand the corresponding element should have the same shape and dtype.\nThe ', 'func', ' is variadic, and its signature should be\n', 'func(*loop_vars) =>\n(NDArray or nested List[NDArray] step_output, NDArray or nested List[NDArray] new_loop_vars)', '.', '\n', 'max_iterations', ' is a scalar that defines the maximum number of iterations allowed.', '\n', 'This function returns two lists.\nThe first list has the length of ', '|step_output|', ',\nin which the i-th element are all i-th elements of\n', 'step_output', ' from all steps, stacked along axis 0.\nThe second list has the length of ', '|loop_vars|', ',\nwhich represents final states of loop variables.', '\n', '\n', 'Warning', '\n', 'For now, the axis 0 of all NDArrays in the first list are ', '\n', '\n', '\n', 'Warning', '\n', 'When ', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.cond(pred, then_func, else_func)[source]Â¶","['Run an if-then-else using user-defined condition and computation', '\n', 'This operator simulates a if-like branch which chooses to do one of\nthe two customized computations according to the specified condition.', '\n', 'pred', ' is a scalar MXNet NDArray,\nindicating which branch of computation should be used.', '\n', 'then_func', ' is a user-defined function, used as computation of the then branch.\nIt produces ', 'outputs', ', which is a list of NDArrays.\nThe signature of ', 'then_func', ' should be\n', 'then_func() => NDArray or nested List[NDArray]', '.', '\n', 'else_func', ' is a user-defined function, used as computation of the else branch.\nIt produces ', 'outputs', ', which is a list of NDArrays.\nThe signature of ', 'else_func', ' should be\n', 'else_func() => NDArray or nested List[NDArray]', '.', '\n', 'The ', 'outputs', ' produces by ', 'then_func', ' and ', 'else_func', ' should have the same number\nof elements, all of which should be in the same shape, of the same dtype and stype.', '\n', 'This function returns a list of symbols, representing the computation result.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'outputs', '\n', 'Return type', '\n', 'an NDArray or nested lists of NDArrays, representing the result of computation.', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.isinf(data)[source]Â¶","['Performs an element-wise check to determine if the NDArray contains an infinite element\nor not.', '\n', '\n', 'Parameters', '\n', 'input', '\n', 'Returns', '\n', 'output', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.isfinite(data)[source]Â¶","['Performs an element-wise check to determine if the NDArray contains an infinite element\nor not.', '\n', '\n', 'Parameters', '\n', 'input', '\n', 'Returns', '\n', 'output', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.isnan(data)[source]Â¶","['Performs an element-wise check to determine if the NDArray contains a NaN element\nor not.', '\n', '\n', 'Parameters', '\n', 'input', '\n', 'Returns', '\n', 'output', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.AdaptiveAvgPooling2D(data=None, output_size=_Null, out=None, name=None, **kwargs)Â¶","['Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).\nThe pooling kernel and stride sizes are automatically chosen for desired output sizes.', '\n', '\n', 'If a single integer is provided for output_size, the output size is (N x C x output_size x output_size) for any input (NCHW).', '\n', 'If a tuple of integers (height, width) are provided for output_size, the output size is (N x C x height x width) for any input (NCHW).', '\n', '\n', 'Defined in src/operator/contrib/adaptive_avg_pooling.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.BatchNormWithReLU(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization with ReLU fusion.', '\n', 'An extented operator of Batch normalization which can fuse ReLU activation.', '\n', 'Defined in src/operator/contrib/batch_norm_relu.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.BilinearResize2D(data=None, like=None, height=_Null, width=_Null, scale_height=_Null, scale_width=_Null, mode=_Null, align_corners=_Null, out=None, name=None, **kwargs)Â¶","['Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.', '\n', 'Expected input is a 4 dimensional NDArray (NCHW) and the output\nwith the shape of (N x C x height x width).\nThe key idea of bilinear interpolation is to perform linear interpolation\nfirst in one direction, and then again in the other direction. See the wikipedia of\n', 'Bilinear interpolation', '\nfor more details.', '\n', 'Defined in src/operator/contrib/bilinear_resize.cc:L219', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.DeformableConvolution(data=None, offset=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Compute 2-D deformable convolution on 4-D input.', '\n', 'The deformable convolution operation is described in ', 'https://arxiv.org/abs/1703.06211', '\n', 'For 2-D deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'data', ' into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset on the ', 'i', '-th part\nof the data.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.DeformablePSROIPooling(data=None, rois=None, trans=None, spatial_scale=_Null, output_dim=_Null, group_size=_Null, pooled_size=_Null, part_size=_Null, sample_per_part=_Null, trans_std=_Null, no_trans=_Null, out=None, name=None, **kwargs)Â¶","['Performs deformable position-sensitive region-of-interest pooling on inputs.\nThe DeformablePSROIPooling operation is described in ', 'https://arxiv.org/abs/1703.06211', ' .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.ModulatedDeformableConvolution(data=None, offset=None, mask=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, im2col_step=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Compute 2-D modulated deformable convolution on 4-D input.', '\n', 'The modulated deformable convolution operation is described in ', 'https://arxiv.org/abs/1811.11168', '\n', 'For 2-D modulated deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'mask', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'out', ' evenly into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset part on the ', 'i', '-th\nout.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/modulated_deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.MultiBoxDetection(cls_prob=None, loc_pred=None, anchor=None, clip=_Null, threshold=_Null, background_id=_Null, nms_threshold=_Null, force_suppress=_Null, variances=_Null, nms_topk=_Null, out=None, name=None, **kwargs)Â¶","['Convert multibox detection predictions.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.MultiBoxPrior(data=None, sizes=_Null, ratios=_Null, clip=_Null, steps=_Null, offsets=_Null, out=None, name=None, **kwargs)Â¶","['Generate prior(anchor) boxes from data, sizes and ratios.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.MultiBoxTarget(anchor=None, label=None, cls_pred=None, overlap_threshold=_Null, ignore_label=_Null, negative_mining_ratio=_Null, negative_mining_thresh=_Null, minimum_negative_samples=_Null, variances=_Null, out=None, name=None, **kwargs)Â¶","['Compute Multibox training targets', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.MultiProposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, out=None, name=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.PSROIPooling(data=None, rois=None, spatial_scale=_Null, output_dim=_Null, pooled_size=_Null, group_size=_Null, out=None, name=None, **kwargs)Â¶","['Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.Proposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, out=None, name=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.ROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sample_ratio=_Null, position_sensitive=_Null, aligned=_Null, out=None, name=None, **kwargs)Â¶","['This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.\nThis operator is typically used in Faster R-CNN & Mask R-CNN networks. If roi batchid is less\nthan 0, it will be ignored, and the corresponding output will be set to 0.', '\n', 'Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning\nthe extracted features with the input. RoIAlign computes the value of each sampling point\nby bilinear interpolation from the nearby grid points on the feature map. No quantization is\nperformed on any coordinates involved in the RoI, its bins, or the sampling points.\nBilinear interpolation is used to compute the exact values of the\ninput features at four regularly sampled locations in each RoI bin.\nThen the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'He, Kaiming, et al. â\x80\x9cMask R-CNN.â\x80\x9d ICCV, 2017', '\n', 'Defined in src/operator/contrib/roi_align.cc:L558', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.RROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sampling_ratio=_Null, out=None, name=None, **kwargs)Â¶","['Performs Rotated ROI Align on the input array.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.', '\n', 'Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.\nRRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby\ngrid points on the rotated feature map. No quantization is performed on any coordinates\ninvolved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to\ncompute the exact values of the input features at four regularly sampled locations in\neach RoI bin. Then the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'Ma, Jianqi, et al. â\x80\x9cArbitrary-Oriented Scene Text Detection via Rotation Proposals.â\x80\x9d\nIEEE Transactions on Multimedia, 2018.', '\n', 'Defined in src/operator/contrib/rroi_align.cc:L273', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.SparseEmbedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, out=None, name=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'note:: ', 'contrib.SparseEmbedding', ' is deprecated, use ', 'Embedding', ' instead.', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'The storage type of the gradient will be ', 'row_sparse', '.', '\n', '\n', 'Note', '\n', 'SparseEmbedding', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L674', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.SyncBatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, ndev=_Null, key=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.\nStandard BN ', '1', ' implementation only normalize the data within each device.\nSyncBN normalizes the input within the whole mini-batch.\nWe follow the sync-onece implmentation described in the paper ', '2', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Reference:', '\n', '\n', '\n', 'Defined in src/operator/contrib/sync_batch_norm.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.allclose(a=None, b=None, rtol=_Null, atol=_Null, equal_nan=_Null, out=None, name=None, **kwargs)Â¶","['This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)', '\n', '\n\\[f(x) = |aâ\x88\x92b|â\x89¤atol+rtol|b|\\]', '\n', 'where\n', '\\(a, b\\)', ' are the input tensors of equal types an shapes\n', '\\(atol, rtol\\)', ' the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/allclose_op.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.arange_like(data=None, start=_Null, step=_Null, repeat=_Null, ctx=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Return an array with evenly spaced values. If axis is not given, the output will\nhave the same shape as the input array. Otherwise, the output will be a 1-D array with size of\nthe specified axis in input shape.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.backward_gradientmultiplier(data=None, scalar=_Null, is_int=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.backward_hawkesll(out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'out', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.backward_index_copy(out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'out', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.backward_quadratic(out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'out', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.bipartite_matching(data=None, is_ascend=_Null, threshold=_Null, topk=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Compute bipartite matching.', 'The matching is performed on score matrix with shape [B, N, M]\n- B: batch_size\n- N: number of rows to match\n- M: number of columns as reference to be matched against.', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L182', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.boolean_mask(data=None, index=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Given an n-d NDArray data, and a 1-d NDArray index,\nthe operator produces an un-predeterminable shaped n-d NDArray out,\nwhich stands for the rows in x where the corresonding element in index is non-zero.', '\n', None, '\n', '\n', '[[4. 5. 6.]]\n<NDArray 1x3 @cpu(0)>', '\n', 'Defined in src/operator/contrib/boolean_mask.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.box_decode(data=None, anchors=None, std0=_Null, std1=_Null, std2=_Null, std3=_Null, clip=_Null, format=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Decode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.box_encode(samples=None, matches=None, anchors=None, refs=None, means=None, stds=None, out=None, name=None, **kwargs)Â¶","['\n', 'Encode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L210', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.box_iou(lhs=None, rhs=None, format=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Bounding box overlap of two arrays.', 'The overlap is defined as Intersection-over-Union, aka, IOU.\n- lhs: (a_1, a_2, â\x80¦, a_n, 4) array\n- rhs: (b_1, b_2, â\x80¦, b_n, 4) array\n- output: (a_1, a_2, â\x80¦, a_n, b_1, b_2, â\x80¦, b_n) array', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.box_nms(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, out=None, name=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.box_non_maximum_suppression(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, out=None, name=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.calibrate_entropy(hist=None, hist_edges=None, num_quantized_bins=_Null, out=None, name=None, **kwargs)Â¶","['Provide calibrated min/max for input histogram.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/calibrate.cc:L196', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.count_sketch(data=None, h=None, s=None, out_dim=_Null, processing_batch_size=_Null, out=None, name=None, **kwargs)Â¶","['Apply CountSketch to input: map a d-dimension data to k-dimension dataâ\x80\x9d', '\n', '\n', 'Note', '\n', 'count_sketch', '\n', '\n', 'Assume input data has shape (N, d), sign hash table s has shape (N, d),\nindex hash table h has shape (N, d) and mapping dimension out_dim = k,\neach element in s is either +1 or -1, each element in h is random integer from 0 to k-1.\nThen the operator computs:', '\n', '\n\\[out[h[i]] += data[i] * s[i]\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/count_sketch.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.dequantize(data=None, min_range=None, max_range=None, out_type=_Null, out=None, name=None, **kwargs)Â¶","['Dequantize the input tensor into a float tensor.\nmin_range and max_range are scalar floats that specify the range for\nthe output data.', '\n', 'When input data type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = in[i] * (max_range - min_range) / 255.0', ',', '\n', 'When input data type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0', ',', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/dequantize.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.dgl_adjacency(data=None, out=None, name=None, **kwargs)Â¶","['This operator converts a CSR matrix whose values are edge Ids\nto an adjacency matrix whose values are ones. The output CSR matrix always has\nthe data value of float32.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1424', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.dgl_csr_neighbor_non_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graph from a csr graph via an\nnon-uniform probability. The operator is designed for DGL.', '\n', 'The operator outputs four sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,\n4) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L911', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.dgl_csr_neighbor_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graphs from a csr graph via an\nuniform probability. The operator is designed for DGL.', '\n', 'The operator outputs three sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L801', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.dgl_graph_compact(*graph_data, **kwargs)Â¶","['This operator compacts a CSR matrix generated by\ndgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.\nThe CSR matrices generated by these two operators may have many empty\nrows at the end and many empty columns. This operator removes these\nempty rows and empty columns.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1613', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.dgl_subgraph(*data, **kwargs)Â¶","['This operator constructs an induced subgraph for\na given set of vertices from a graph. The operator accepts multiple\nsets of vertices as input. For each set of vertices, it returns a pair\nof CSR matrices if return_mapping is True: the first matrix contains edges\nwith new edge Ids, the second matrix contains edges with the original\nedge Ids.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1171', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.div_sqrt_dim(data=None, out=None, name=None, **kwargs)Â¶","['Rescale the input by the square root of the channel dimension.', '\n', '\n', 'out = data / sqrt(data.shape[-1])', '\n', 'Defined in src/operator/contrib/transformer.cc:L832', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.edge_id(data=None, u=None, v=None, out=None, name=None, **kwargs)Â¶","['This operator implements the edge_id function for a graph\nstored in a CSR matrix (the value of the CSR stores the edge Id of the graph).\noutput[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],\notherwise output[i] will be -1. Both u and v should be 1D vectors.', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1352', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.fft(data=None, compute_size=_Null, out=None, name=None, **kwargs)Â¶","['Apply 1D FFT to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'fft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.\nThe output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, â\x80¦].', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/fft.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.getnnz(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Number of stored values for a sparse tensor, including explicit zeros.', '\n', 'This operator only supports CSR matrix on CPU.', '\n', 'Defined in src/operator/contrib/nnz.cc:L176', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.gradientmultiplier(data=None, scalar=_Null, is_int=_Null, out=None, name=None, **kwargs)Â¶","['This operator implements the gradient multiplier function.\nIn forward pass it acts as an identity transform. During backpropagation it\nmultiplies the gradient from the subsequent level by a scalar factor lambda and passes it to\nthe preceding layer.', '\n', 'Defined in src/operator/contrib/gradient_multiplier_op.cc:L78', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.group_adagrad_update(weight=None, grad=None, history=None, lr=_Null, rescale_grad=_Null, clip_gradient=_Null, epsilon=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Group AdaGrad optimizer.', '\n', 'Referenced from ', 'Adaptive Subgradient Methods for Online Learning and Stochastic Optimization', ',\nand available at ', 'http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf', ' but\nuses only a single learning rate for every row of the parameter array.', '\n', 'Updates are applied by:', '\n', None, '\n', '\n', 'Weights are updated lazily if the gradient is sparse.', '\n', 'Note that non-zero values for the weight decay option are not supported.', '\n', 'Defined in src/operator/contrib/optimizer_op.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.hawkesll(lda=None, alpha=None, beta=None, state=None, lags=None, marks=None, valid_length=None, max_time=None, out=None, name=None, **kwargs)Â¶","['Computes the log likelihood of a univariate Hawkes process.', '\n', 'The log likelihood is calculated on point process observations represented\nas ', 'ragged', ' matrices for ', 'lags', ' (interarrival times w.r.t. the previous point),\nand ', 'marks', ' (identifiers for the process ID). Note that each mark is considered independent,\ni.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:', '\n', '\n\\[\\lambda_k^*(t) = \\lambda_k + \\alpha_k \\sum_{\\{t_i < t, y_i = k\\}} \\beta_k \\exp(-\\beta_k (t - t_i))\\]', '\n', 'where ', '\\(\\lambda_k\\)', ' specifies the background intensity ', 'lda', ', ', '\\(\\alpha_k\\)', ' specifies the ', 'branching ratio', ' or ', 'alpha', ', and ', '\\(\\beta_k\\)', ' the delay density parameter ', 'beta', '.', '\n', 'lags', ' and ', 'marks', ' are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are â\x80\x9cleft-alignedâ\x80\x9d ', 'ragged', ' matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ', 'valid_length', ', of shape (N,) where ', 'valid_length[i]', ' corresponds to the number of valid points in ', 'lags[i,', ' and ', 'marks[i,', '.', '\n', 'max_time', ' is the length of the observation period of the point process. That is, specifying ', 'max_time[i]', ' computes the likelihood of the i-th sample as observed on the time interval ', '\\((0, 5]\\)', '. Naturally, the sum of all valid ', 'lags[i,', ' must be less than or equal to 5.', '\n', 'The input ', 'state', ' specifies the ', 'memory', ' of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the ', 'memory', ' as', '\n', '\n\\[s_k(t) = \\sum_{t_i < t} \\exp(-\\beta_k (t - t_i)).\\]', '\n', 'The ', 'state', ' to be provided is ', '\\(s_k(0)\\)', ' and carries the added intensity due to past events before the current batch. ', '\\(s_k(T)\\)', ' is returned from the function where ', '\\(T\\)', ' is ', 'max_time[T]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'References:', '\n', '\n', 'Bacry, E., Mastromatteo, I., & Muzy, J. F. (2015).\nHawkes processes in finance. Market Microstructure and Liquidity\n, 1(01), 1550005.', '\n', '\n', 'Defined in src/operator/contrib/hawkes_ll.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.ifft(data=None, compute_size=_Null, out=None, name=None, **kwargs)Â¶","['Apply 1D ifft to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'ifft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, â\x80¦].\nLast dimension must be an even number.\nThe output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/ifft.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.index_array(data=None, axes=_Null, out=None, name=None, **kwargs)Â¶","['Returns an array of indexes of the input array.', '\n', 'For an input array with shape  ', '\\((d_1, d_2, ..., d_n)\\)', ', ', 'index_array', ' returns a\n', '\\((d_1, d_2, ..., d_n, n)\\)', ' array ', 'idx', ', where\n', '\\(idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]\\)', '.', '\n', 'Additionally, when the parameter ', 'axes', ' is specified, ', 'idx', ' will be a\n', '\\((d_1, d_2, ..., d_n, m)\\)', ' array where ', 'm', ' is the length of ', 'axes', ', and the following\nequality will hold: ', '\\(idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}\\)', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_array.cc:L118', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.index_copy(old_tensor=None, index_vector=None, new_tensor=None, out=None, name=None, **kwargs)Â¶","['Copies the elements of a ', 'new_tensor', ' into the ', 'old_tensor', '.', '\n', 'This operator copies the elements by selecting the indices in the order given in ', 'index', '.\nThe output will be a new tensor containing the rest elements of old tensor and\nthe copied elements of new tensor.\nFor example, if ', 'index[i] == j', ', then the ', 'i', ' th row of ', 'new_tensor', ' is copied to the\n', 'j', ' th row of output.', '\n', 'The ', 'index', ' must be a vector and it must have the same size with the ', '0', ' th dimension of\n', 'new_tensor', '. Also, the ', '0', ' th dimension of old_tensor must ', '>=', ' the ', '0', ' th dimension of\n', 'new_tensor', ', or an error will be raised.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_copy.cc:L183', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.interleaved_matmul_encdec_qk(queries=None, keys_values=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of projections of queries following the layout:\n(seq_length, batch_size, num_heads * head_dim)', '\n', 'and a tensor of interleaved projections of values and keys following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'the equivalent code would be:\nq_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\ntmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))\nk_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L753', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.interleaved_matmul_encdec_valatt(keys_values=None, attention=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of interleaved projections of\nkeys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:', '\n', 'tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L799', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.interleaved_matmul_selfatt_qk(queries_keys_values=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as self attention.', '\n', 'the input must be a single tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nq_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\nk_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L665', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.interleaved_matmul_selfatt_valatt(queries_keys_values=None, attention=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as self attention.', '\n', 'the inputs must be a tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L709', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.intgemm_fully_connected(data=None, weight=None, scaling=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out_type=_Null, out=None, name=None, **kwargs)Â¶","['Multiply matrices using 8-bit integers.  data * weight.', '\n', 'Input tensor arguments are: data weight [scaling] [bias]', '\n', 'data: either float32 or prepared using intgemm_prepare_data (in which case it is int8).', '\n', 'weight: must be prepared using intgemm_prepare_weight.', '\n', 'scaling: present if and only if out_type is float32. If so this is multiplied by the result before adding bias. Typically:\nscaling = (max passed to intgemm_prepare_weight)/127.0 if data is in float32\nscaling = (max_passed to intgemm_prepare_data)/127.0 * (max passed to intgemm_prepare_weight)/127.0 if data is in int8', '\n', 'bias: present if and only if !no_bias. This is added to the output after scaling and has the same number of columns as the output.', '\n', 'out_type: type of the output.', '\n', 'Defined in src/operator/contrib/intgemm/intgemm_fully_connected_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.intgemm_maxabsolute(data=None, out=None, name=None, **kwargs)Â¶","['Compute the maximum absolute value in a tensor of float32 fast on a CPU.  The tensorâ\x80\x99s total size must be a multiple of 16 and aligned to a multiple of 64 bytes.\nmxnet.nd.contrib.intgemm_maxabsolute(arr) == arr.abs().max()', '\n', 'Defined in src/operator/contrib/intgemm/max_absolute_op.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.intgemm_prepare_data(data=None, maxabs=None, out=None, name=None, **kwargs)Â¶","['This operator converts quantizes float32 to int8 while also banning -128.', '\n', 'It it suitable for preparing an data matrix for use by intgemmâ\x80\x99s C=data * weights operation.', '\n', 'The float32 values are scaled such that maxabs maps to 127. Typically maxabs = maxabsolute(A).', '\n', 'Defined in src/operator/contrib/intgemm/prepare_data_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.intgemm_prepare_weight(weight=None, maxabs=None, already_quantized=_Null, out=None, name=None, **kwargs)Â¶","['This operator converts a weight matrix in column-major format to intgemmâ\x80\x99s internal fast representation of weight matrices.  MXNet customarily stores weight matrices in column-major (transposed) format. This operator is not meant to be fast; it is meant to be run offline to quantize a model.', '\n', 'In other words, it prepares weight for the operation C = data * weight^T.', '\n', 'If the provided weight matrix is float32, it will be quantized first.  The quantization function is (int8_t)(127.0 / max * weight) where multiplier is provided as argument 1 (the weight matrix is argument 0).  Then the matrix will be rearranged into the CPU-dependent format.', '\n', 'If the provided weight matrix is already int8, the matrix will only be rearranged into the CPU-dependent format.  This way one can quantize with intgemm_prepare_data (which just quantizes), store to disk in a consistent format, then at load time convert to CPU-dependent format with intgemm_prepare_weight.', '\n', 'The internal representation depends on register length.  So AVX512, AVX2, and SSSE3 have different formats.  AVX512BW and AVX512VNNI have the same representation.', '\n', 'Defined in src/operator/contrib/intgemm/prepare_weight_op.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.intgemm_take_weight(weight=None, indices=None, out=None, name=None, **kwargs)Â¶","['Index a weight matrix stored in intgemmâ\x80\x99s weight format.\nThe indices select the outputs of matrix multiplication, not the inner dot product dimension.', '\n', 'Defined in src/operator/contrib/intgemm/take_weight_op.cc:L128', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quadratic(data=None, a=_Null, b=_Null, c=_Null, out=None, name=None, **kwargs)Â¶","['This operators implements the quadratic function.', '\n', '\n\\[f(x) = ax^2+bx+c\\]', '\n', 'where ', '\\(x\\)', ' is an input tensor and all operations\nin the function are element-wise.', '\n', 'Example:', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/quadratic_op.cc:L50', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantize(data=None, min_range=None, max_range=None, out_type=_Null, out=None, name=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_range', ' and ', 'max_range', '.', '\n', 'min_range and max_range are scalar floats that specify the range for\nthe input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize.cc:L73', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantize_asym(data=None, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Quantize a input tensor from float to uint8_t.\nOutput ', 'scale', ' and ', 'shift', ' are scalar floats that specify the quantization parameters for the input\ndata.\nThe output is calculated using the following equation:\n', 'out[i] = in[i] * scale + shift + 0.5', ',\nwhere ', 'scale = uint8_range / (max_range - min_range)', ' and\n', 'shift = numeric_limits<T>::max - max_range * scale', '.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantize_asym.cc:L115', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantize_v2(data=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_calib_range', ' and ', 'max_calib_range', ' or the input range collected at runtime.', '\n', 'Output ', 'min_range', ' and ', 'max_range', ' are scalar floats that specify the range for the input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', 'When out_type is ', 'auto', ', the output type is automatically determined by min_calib_range if presented.\nIf min_calib_range < 0.0f, the output type will be int8, otherwise will be uint8.\nIf min_calib_range isnâ\x80\x99t presented, the output type will be int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize_v2.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_act(data=None, min_data=None, max_data=None, act_type=_Null, out=None, name=None, **kwargs)Â¶","['Activation operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_activation.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_batch_norm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, min_data=None, max_data=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['BatchNorm operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_batch_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.\nAll inputs with different min/max will be rescaled by using largest [min, max] pairs.\nIf any input holds int8, then the output will be int8. Otherwise output will be uint8.', '\n', 'Defined in src/operator/quantization/quantized_concat.cc:L107', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_conv(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Convolution operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_conv.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_elemwise_add(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, out=None, name=None, **kwargs)Â¶","['elemwise_add operator for input dataA and input dataB data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_elemwise_mul(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, min_calib_range=_Null, max_calib_range=_Null, enable_float_output=_Null, out=None, name=None, **kwargs)Â¶","['Multiplies arguments int8 element-wise.', '\n', 'Defined in src/operator/quantization/quantized_elemwise_mul.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_embedding(data=None, weight=None, min_weight=None, max_weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, out=None, name=None, **kwargs)Â¶","['Maps integer indices to int8 vector representations (embeddings).', '\n', 'Defined in src/operator/quantization/quantized_indexing_op.cc:L133', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_flatten(data=None, min_data=None, max_data=None, out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_fully_connected(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out=None, name=None, **kwargs)Â¶","['Fully Connected operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_fully_connected.cc:L312', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_pooling(data=None, min_data=None, max_data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Pooling operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_pooling.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.quantized_rnn(data=None, parameters=None, state=None, state_cell=None, data_scale=None, data_shift=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, out=None, name=None, **kwargs)Â¶","['RNN operator for input data type of uint8. The weight of each gates is converted\nto int8, while bias is accumulated in type float32. The hidden state and cell state are in type\nfloat32. For the input data, two more arguments of type float32 must be provided representing the\nthresholds of quantizing argument from data type float32 to uint8. The final outputs contain the\nrecurrent result in float32. It only supports quantization for Vanilla LSTM network.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantized_rnn.cc:L298', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.requantize(data=None, min_range=None, max_range=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Given data that is quantized in int32 and the corresponding thresholds,\nrequantize the data into int8 using min and max thresholds either calculated at runtime\nor from calibration. Itâ\x80\x99s highly recommended to pre-calucate the min and max thresholds\nthrough calibration since it is able to save the runtime of the operator and improve the\ninference accuracy.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/requantize.cc:L59', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.round_ste(data=None, out=None, name=None, **kwargs)Â¶","['Straight-through-estimator of ', 'round()', '.', '\n', 'In forward pass, returns element-wise rounded value to the nearest integer of the input (same as ', 'round()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'round()', '):\n', '\\(\\frac{d}{dx}{round\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{round(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])\nx.backward()\nx = [-2.,  2., -2.,  2.,  3.]\nx.grad() = [1.,  1., 1.,  1.,  1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L54', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.contrib.sign_ste(data=None, out=None, name=None, **kwargs)Â¶","['Straight-through-estimator of ', 'sign()', '.', '\n', 'In forward pass, returns element-wise sign of the input (same as ', 'sign()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'sign()', '):\n', '\\(\\frac{d}{dx}{sign\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{sign(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = sign_ste([-2, 0, 3])\nx.backward()\nx = [-1.,  0., 1.]\nx.grad() = [1.,  1., 1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L79', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.adjust_lighting(data=None, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Adjust the lighting level of the input. Follow the AlexNet style.', '\n', 'Defined in src/operator/image/image_random.cc:L254', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.crop(data=None, x=_Null, y=_Null, width=_Null, height=_Null, out=None, name=None, **kwargs)Â¶","['Crop an image NDArray of shape (H x W x C) or (N x H x W x C)\nto the given size.\n.. rubric:: Example', '\n', 'Defined in src/operator/image/crop.cc:L65', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.flip_left_right(data=None, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.flip_top_bottom(data=None, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L205', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.normalize(data=None, mean=_Null, std=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and', 'standard deviation.', '\n', '\n', '\n\\[ \\begin{align}\\begin{aligned}    output[i] = (input[i] - m\\ :sub:`i`\\ ) / s\\ :sub:`i`\\\\If mean or std is scalar, the same value will be applied to all channels.\\\\Default value for mean is 0.0 and stand deviation is 1.0.\\end{aligned}\\end{align} \\]', '\n', 'Example', '\n', 'Defined in src/operator/image/image_random.cc:L167', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_brightness(data=None, min_factor=_Null, max_factor=_Null, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L215', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_color_jitter(data=None, brightness=_Null, contrast=_Null, saturation=_Null, hue=_Null, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L246', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_contrast(data=None, min_factor=_Null, max_factor=_Null, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L222', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_flip_left_right(data=None, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L200', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_flip_top_bottom(data=None, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L210', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_hue(data=None, min_factor=_Null, max_factor=_Null, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L238', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_lighting(data=None, alpha_std=_Null, out=None, name=None, **kwargs)Â¶","['Randomly add PCA noise. Follow the AlexNet style.', '\n', 'Defined in src/operator/image/image_random.cc:L262', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.random_saturation(data=None, min_factor=_Null, max_factor=_Null, out=None, name=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L230', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.resize(data=None, size=_Null, keep_ratio=_Null, interp=_Null, out=None, name=None, **kwargs)Â¶","['Resize an image NDArray of shape (H x W x C) or (N x H x W x C)\nto the given size\n.. rubric:: Example', '\n', 'Defined in src/operator/image/resize.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.image.to_tensor(data=None, out=None, name=None, **kwargs)Â¶","['Converts an image NDArray of shape (H x W x C) or (N x H x W x C)\nwith values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W)\nwith values in the range [0, 1]', '\n', 'Example', '\n', 'Defined in src/operator/image/image_random.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.det(A=None, out=None, name=None, **kwargs)Â¶","['Compute the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'det', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'There is no gradient backwarded when A is non-invertible (which is\nequivalent to det(A) = 0) because zero is rarely hit upon in float\npoint computation and the Jacobiâ\x80\x99s formula on determinant gradient\nis not computationally efficient when A is non-invertible.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L974', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.extractdiag(A=None, offset=_Null, out=None, name=None, **kwargs)Â¶","['Extracts the diagonal entries of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an ', 'n-1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.extracttrian(A=None, offset=_Null, lower=_Null, out=None, name=None, **kwargs)Â¶","['Extracts a triangular sub-matrix from a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an ', 'n-1', '-dimensional tensor.', '\n', 'The ', 'offset', ' and ', 'lower', ' parameters determine the triangle to be extracted:', '\n', '\n', 'When ', '\n', 'When ', '\n', 'When ', '\n', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L604', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.gelqf(A=None, out=None, name=None, **kwargs)Â¶","['LQ factorization for general matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', we compute the LQ factorization (LAPACK ', 'gelqf', ', followed by ', 'orglq', '). ', 'A', '\nmust have shape ', '(x, y)', ' with ', 'x <= y', ', and must have full rank ', '=x', '. The LQ\nfactorization consists of ', 'L', ' with shape ', '(x, x)', ' and ', 'Q', ' with shape ', '(x, y)', ', so\nthat:', '\n', '\n', 'A', '\n', 'Here, ', 'L', ' is lower triangular (upper triangle equal to zero) with nonzero diagonal,\nand ', 'Q', ' is row-orthonormal, meaning that', '\n', '\n', 'Q', '\n', 'is equal to the identity matrix of shape ', '(x, x)', '.', '\n', 'If ', 'n>2', ', ', 'gelqf', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L797', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.gemm(A=None, B=None, C=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, beta=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Performs general matrix multiplication and accumulation.\nInput are tensors ', 'A', ', ', 'B', ', ', 'C', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here, ', 'alpha', ' and ', 'beta', ' are scalar parameters, and ', 'op()', ' is either the identity or\nmatrix transposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ', ', 'C', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', ', 'C', ', axis=1) is equivalent\nto the following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.gemm2(A=None, B=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Performs general matrix multiplication.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here ', 'alpha', ' is a scalar parameter and ', 'op()', ' is either the identity or the matrix\ntransposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', axis=1) is equivalent to\nthe following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.inverse(A=None, out=None, name=None, **kwargs)Â¶","['Compute the inverse of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'inverse', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L919', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.makediag(A=None, offset=_Null, out=None, name=None, **kwargs)Â¶","['Constructs a square matrix with the input as diagonal.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.\nIf ', 'n>1', ', then ', 'A', ' represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.maketrian(A=None, offset=_Null, lower=_Null, out=None, name=None, **kwargs)Â¶","['Constructs a square matrix with the input representing a specific triangular sub-matrix.\nThis is basically the inverse of ', 'linalg.extracttrian', '. Input is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the entries of a triangular matrix which is lower triangular if ', 'offset<0', ' or ', 'offset=0', ', ', 'lower=true', '. The resulting matrix is derived by first constructing the square\nmatrix with the entries outside the triangle set to zero and then adding ', 'offset', '-times an additional\ndiagonal with zero entries to the square matrix.', '\n', 'If ', 'n>1', ', then ', 'A', ' represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L672', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.potrf(A=None, out=None, name=None, **kwargs)Â¶","['Performs Cholesky factorization of a symmetric positive-definite matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the Cholesky factor ', 'B', ' of the symmetric, positive definite matrix ', 'A', ' is\ncomputed. ', 'B', ' is triangular (entries of upper or lower triangle are all zero), has\npositive diagonal entries, and:', '\n', '\n', 'A', '\n', 'If ', 'n>2', ', ', 'potrf', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.potri(A=None, out=None, name=None, **kwargs)Â¶","['Performs matrix inversion from a Cholesky factorization.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a triangular matrix (entries of upper or lower triangle are all zero)\nwith positive diagonal. We compute:', '\n', '\n', 'out', '\n', 'In other words, if ', 'A', ' is the Cholesky factor of a symmetric positive definite matrix\n', 'B', ' (obtained by ', 'potrf', '), then', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'potri', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Use this operator only if you are certain you need the inverse of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L274', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.slogdet(A=None, out=None, name=None, **kwargs)Â¶","['Compute the sign and log of the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'sign', '\n', 'If ', 'n>2', ', ', 'slogdet', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'The gradient is not properly defined on sign, so the gradient of\nit is not backwarded.', '\n', '\n', '\n', 'Note', '\n', 'No gradient is backwarded when A is non-invertible. Please see\nthe docs of operator det for detail.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L1033', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.sumlogdiag(A=None, out=None, name=None, **kwargs)Â¶","['Computes the sum of the logarithms of the diagonal elements of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be square with positive diagonal entries. We sum the natural\nlogarithms of the diagonal elements, the result has shape (1,).', '\n', 'If ', 'n>2', ', ', 'sumlogdiag', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L444', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.syevd(A=None, out=None, name=None, **kwargs)Â¶","['Eigendecomposition for symmetric matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be symmetric, of shape ', '(x, x)', '. We compute the eigendecomposition,\nresulting in the orthonormal matrix ', 'U', ' of eigenvectors, shape ', '(x, x)', ', and the\nvector ', 'L', ' of eigenvalues, shape ', '(x,)', ', so that:', '\n', '\n', 'U', '\n', 'Here:', '\n', '\n', 'U', '\n', 'where ', 'I', ' is the identity matrix. Also, ', 'L(0) <= L(1) <= L(2) <= â\x80¦', ' (ascending order).', '\n', 'If ', 'n>2', ', ', 'syevd', ' is performed separately on the trailing two dimensions of ', 'A', ' (batch\nmode). In this case, ', 'U', ' has ', 'n', ' dimensions like ', 'A', ', and ', 'L', ' has ', 'n-1', ' dimensions.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Derivatives for this operator are defined only if ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L867', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.syrk(A=None, transpose=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Multiplication of matrix with its transpose.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the operator performs the BLAS3 function ', 'syrk', ':', '\n', '\n', 'out', '\n', 'if ', 'transpose=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'transpose=True', '.', '\n', 'If ', 'n>2', ', ', 'syrk', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L729', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.trmm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Performs multiplication with a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trmm', ':', '\n', '\n', 'out', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trmm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.linalg.trsm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Solves matrix equation involving a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trsm', ', solving for ', 'out', ' in:', '\n', '\n', 'op', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trsm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L395', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
class mxnet.ndarray.op.CachedOp(sym, flags=())[source]Â¶","['Bases: ', 'object', '\n', 'Cached operator handle.', '\n', '\n']",,,
"
mxnet.ndarray.op.Activation(data=None, act_type=_Null, out=None, name=None, **kwargs)Â¶","['Applies an activation function element-wise to the input.', '\n', 'The following activation functions are supported:', '\n', '\n', 'relu', '\n', 'sigmoid', '\n', 'tanh', '\n', 'softrelu', '\n', 'softsign', '\n', '\n', 'Defined in src/operator/nn/activation.cc:L164', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.BatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\nthe inverse of ', 'data_var', ', which are needed for the backward pass. Note that gradient of these\ntwo outputs are blocked.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is 1.  Specifying -1 sets the channel\naxis to be the last item in the input shape.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Note', '\n', 'When ', '\n', '\n', 'Defined in src/operator/nn/batch_norm.cc:L608', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.BatchNorm_v1(data=None, gamma=None, beta=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'This operator is DEPRECATED. Perform BatchNorm on the input.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', 'Thereâ\x80\x99s no sparse support for this operator, and it will exhibit problematic behavior if used with\nsparse tensors.', '\n', 'Defined in src/operator/batch_norm_v1.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.BilinearSampler(data=None, grid=None, cudnn_off=_Null, out=None, name=None, **kwargs)Â¶","['Applies bilinear sampling to input feature map.', '\n', 'Bilinear Sampling is the key of  [NIPS2015] â\x80\x9cSpatial Transformer Networksâ\x80\x9d. The usage of the operator is very similar to remap function in OpenCV,\nexcept that the operator has the backward pass.', '\n', 'Given ', '\\(data\\)', ' and ', '\\(grid\\)', ', then the output is computed by', '\n', '\n\\[\\begin{split}x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\\\\ny_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\\\\noutput[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})\\end{split}\\]', '\n', '\\(x_{dst}\\)', ', ', '\\(y_{dst}\\)', ' enumerate all spatial locations in ', '\\(output\\)', ', and ', '\\(G()\\)', ' denotes the bilinear interpolation kernel.\nThe out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).', '\n', 'The operator assumes that ', '\\(data\\)', ' has â\x80\x98NCHWâ\x80\x99 layout and ', '\\(grid\\)', ' has been normalized to [-1, 1].', '\n', 'BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.\nGridGenerator supports two kinds of transformation: ', 'affine', ' and ', 'warp', '.\nIf users want to design a CustomOp to manipulate ', '\\(grid\\)', ', please firstly refer to the code of GridGenerator.', '\n', 'Example 1:', '\n', None, '\n', '\n', 'Example 2:', '\n', None, '\n', '\n', 'Defined in src/operator/bilinear_sampler.cc:L255', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.BlockGrad(data=None, out=None, name=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Cast(data=None, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Convolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Compute ', 'N', '-D convolution on ', '(N+2)', '-D input.', '\n', 'In the 2-D convolution, given input data with shape ', '(batch_size,\nchannel, height, width)', ', the output is computed by', '\n', '\n\\[out[n,i,:,:] = bias[i] + \\sum_{j=0}^{channel} data[n,j,:,:] \\star\nweight[i,j,:,:]\\]', '\n', 'where ', '\\(\\star\\)', ' is the 2-D cross-correlation operator.', '\n', 'For general 2-D convolution, the shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channel, height,\nwidth)', '. We can choose other layouts such as ', 'NWC', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concatenating all\nthe ', 'g', ' results.', '\n', '1-D convolution does not have ', 'height', ' dimension but only ', 'width', ' in space.', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', '3-D convolution adds an additional ', 'depth', ' dimension besides ', 'height', ' and\n', 'width', '. The shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'There are other options to tune the performance.', '\n', '\n', 'cudnn_tune', '\n', 'workspace', '\n', '\n', 'Defined in src/operator/nn/convolution.cc:L475', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Convolution_v1(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['This operator is DEPRECATED. Apply convolution to input then add a bias.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Correlation(data1=None, data2=None, kernel_size=_Null, max_displacement=_Null, stride1=_Null, stride2=_Null, pad_size=_Null, is_multiply=_Null, out=None, name=None, **kwargs)Â¶","['Applies correlation to inputs.', '\n', 'The correlation layer performs multiplicative patch comparisons between two feature maps.', '\n', 'Given two multi-channel feature maps ', '\\(f_{1}, f_{2}\\)', ', with ', '\\(w\\)', ', ', '\\(h\\)', ', and ', '\\(c\\)', ' being their width, height, and number of channels,\nthe correlation layer lets the network compare each patch from ', '\\(f_{1}\\)', ' with each patch from ', '\\(f_{2}\\)', '.', '\n', 'For now we consider only a single comparison of two patches. The â\x80\x98correlationâ\x80\x99 of two patches centered at ', '\\(x_{1}\\)', ' in the first map and\n', '\\(x_{2}\\)', ' in the second map is then defined as:', '\n', '\n\\[c(x_{1}, x_{2}) = \\sum_{o \\in [-k,k] \\times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\\]', '\n', 'for a square patch of size ', '\\(K:=2k+1\\)', '.', '\n', 'Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other\ndata. For this reason, it has no training weights.', '\n', 'Computing ', '\\(c(x_{1}, x_{2})\\)', ' involves ', '\\(c * K^{2}\\)', ' multiplications. Comparing all patch combinations involves ', '\\(w^{2}*h^{2}\\)', ' such computations.', '\n', 'Given a maximum displacement ', '\\(d\\)', ', for each location ', '\\(x_{1}\\)', ' it computes correlations ', '\\(c(x_{1}, x_{2})\\)', ' only in a neighborhood of size ', '\\(D:=2d+1\\)', ',\nby limiting the range of ', '\\(x_{2}\\)', '. We use strides ', '\\(s_{1}, s_{2}\\)', ', to quantize ', '\\(x_{1}\\)', ' globally and to quantize ', '\\(x_{2}\\)', ' within the neighborhood\ncentered around ', '\\(x_{1}\\)', '.', '\n', 'The final output is defined by the following expression:', '\n', '\n\\[out[n, q, i, j] = c(x_{i, j}, x_{q})\\]', '\n', 'where ', '\\(i\\)', ' and ', '\\(j\\)', ' enumerate spatial locations in ', '\\(f_{1}\\)', ', and ', '\\(q\\)', ' denotes the ', '\\(q^{th}\\)', ' neighborhood of ', '\\(x_{i,j}\\)', '.', '\n', 'Defined in src/operator/correlation.cc:L197', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Crop(*data, **kwargs)Â¶","['\n', 'Note', '\n', 'Crop', '\n', '\n', 'Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or\nwith width and height of the second input symbol, i.e., with one input, we need h_w to\nspecify the crop height and width, otherwise the second input symbolâ\x80\x99s size will be used', '\n', 'Defined in src/operator/crop.cc:L49', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Custom(*data, **kwargs)Â¶","['Apply a custom operator implemented in a frontend language (like Python).', '\n', 'Custom operators should override required methods like ', 'forward', ' and ', 'backward', '.\nThe custom operator must be registered before it can be used.\nPlease check the tutorial here: ', 'https://mxnet.incubator.apache.org/api/faq/new_op', '\n', 'Defined in src/operator/custom/custom.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', 'Applies a custom operator named ', 'my_custom_operator', ' to ', 'input', '.', '\n', None, '\n', '\n', '\n']",">>> output=mx.symbol.Custom(op_type='my_custom_operator',data=input)
",,
"
mxnet.ndarray.op.Deconvolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, adj=_Null, target_shape=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Dropout(data=None, p=_Null, mode=_Null, axes=_Null, cudnn_off=_Null, out=None, name=None, **kwargs)Â¶","['Applies dropout operation to input array.', '\n', '\n', 'During training, each element of the input is set to zero with probability p.\nThe whole array is rescaled by ', '\n', 'During testing, this operator does not change the input if mode is â\x80\x98trainingâ\x80\x99.\nIf mode is â\x80\x98alwaysâ\x80\x99, the same computaion as during training will be applied.', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/dropout.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ElementWiseSum(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Embedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, out=None, name=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'When â\x80\x9csparse_gradâ\x80\x9d is False, if any index mentioned is too large, it is replaced by the index that\naddresses the last vector in an embedding matrix.\nWhen â\x80\x9csparse_gradâ\x80\x9d is True, an error will be raised if invalid indices are found.', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of weight can be either row_sparse or default.', '\n', '\n', 'Note', '\n', 'If â\x80\x9csparse_gradâ\x80\x9d is set to True, the storage type of gradient w.r.t weights will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L597', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Flatten(data=None, out=None, name=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.FullyConnected(data=None, weight=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out=None, name=None, **kwargs)Â¶","['Applies a linear transformation: ', '\\(Y = XW^T + b\\)', '.', '\n', 'If ', 'flatten', ' is set to be true, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'If ', 'flatten', ' is set to be false, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'The learnable parameters include both ', 'weight', ' and ', 'bias', '.', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', '\n', 'Note', '\n', 'The sparse support for FullyConnected is limited to forward evaluation with ', '\n', 'To compute linear transformation with â\x80\x98csrâ\x80\x99 sparse data, sparse.dot is recommended instead\nof sparse.FullyConnected.', '\n', '\n', 'Defined in src/operator/nn/fully_connected.cc:L286', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.GridGenerator(data=None, transform_type=_Null, target_shape=_Null, out=None, name=None, **kwargs)Â¶","['Generates 2D sampling grid for bilinear sampling.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.GroupNorm(data=None, gamma=None, beta=None, num_groups=_Null, eps=_Null, output_mean_var=_Null, out=None, name=None, **kwargs)Â¶","['Group normalization.', '\n', 'The input channels are separated into ', 'num_groups', ' groups, each containing ', 'num_channels', ' channels.\nThe mean and standard-deviation are calculated separately over the each group.', '\n', '\n\\[data = data.reshape((N, num_groups, C // num_groups, ...))\nout = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Defined in src/operator/nn/group_norm.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.IdentityAttachKLSparseReg(data=None, sparseness_target=_Null, penalty=_Null, momentum=_Null, out=None, name=None, **kwargs)Â¶","['Apply a sparse regularization to the output a sigmoid activation function.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.InstanceNorm(data=None, gamma=None, beta=None, eps=_Null, out=None, name=None, **kwargs)Â¶","['Applies instance normalization to the n-dimensional input array.', '\n', 'This operator takes an n-dimensional input array where (n>2) and normalizes\nthe input using the following formula:', '\n', '\n\\[out = \\frac{x - mean[data]}{ \\sqrt{Var[data]} + \\epsilon} * gamma + beta\\]', '\n', 'This layer is similar to batch normalization layer (', 'BatchNorm', ')\nwith two differences: first, the normalization is\ncarried out per example (instance), not over a batch. Second, the\nsame normalization is applied both at test and train time. This\noperation is also known as ', 'contrast normalization', '.', '\n', 'If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, â\x80¦],\n', 'gamma', ' and ', 'beta', ' parameters must be vectors of shape [channel].', '\n', 'This implementation is based on this paper ', '1', '\n', '\n', '1', '\n', 'Instance Normalization: The Missing Ingredient for Fast Stylization,\nD. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/instance_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.L2Normalization(data=None, eps=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Normalize the input array using the L2 norm.', '\n', 'For 1-D NDArray, it computes:', '\n', None, '\n', '\n', 'For N-D NDArray, if the input array has shape (N, N, â\x80¦, N),', '\n', 'with ', 'mode', ' = ', 'instance', ', it normalizes each instance in the multidimensional\narray by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'channel', ', it normalizes each channel in the array by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'spatial', ', it normalizes the cross channel norm for each position\nin the array by its L2 norm.:', '\n', None, '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/l2_normalization.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.LRN(data=None, alpha=_Null, beta=_Null, knorm=_Null, nsize=_Null, out=None, name=None, **kwargs)Â¶","['Applies local response normalization to the input.', '\n', 'The local response normalization layer performs â\x80\x9clateral inhibitionâ\x80\x9d by normalizing\nover local input regions.', '\n', 'If ', '\\(a_{x,y}^{i}\\)', ' is the activity of a neuron computed by applying kernel ', '\\(i\\)', ' at position\n', '\\((x, y)\\)', ' and then applying the ReLU nonlinearity, the response-normalized\nactivity ', '\\(b_{x,y}^{i}\\)', ' is given by the expression:', '\n', '\n\\[b_{x,y}^{i} = \\frac{a_{x,y}^{i}}{\\Bigg({k + \\frac{\\alpha}{n} \\sum_{j=max(0, i-\\frac{n}{2})}^{min(N-1, i+\\frac{n}{2})} (a_{x,y}^{j})^{2}}\\Bigg)^{\\beta}}\\]', '\n', 'where the sum runs over ', '\\(n\\)', ' â\x80\x9cadjacentâ\x80\x9d kernel maps at the same spatial position, and ', '\\(N\\)', ' is the total\nnumber of kernels in the layer.', '\n', 'Defined in src/operator/nn/lrn.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.LayerNorm(data=None, gamma=None, beta=None, axis=_Null, eps=_Null, output_mean_var=_Null, out=None, name=None, **kwargs)Â¶","['Layer normalization.', '\n', 'Normalizes the channels of the input tensor by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis and then\ncompute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Unlike BatchNorm and InstanceNorm,  the ', 'mean', ' and ', 'var', ' are computed along the channel dimension.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_std', '. Note that no gradient will be passed through these two outputs.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is -1, which sets the channel\naxis to be the last item in the input shape.', '\n', 'Defined in src/operator/nn/layer_norm.cc:L201', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.LeakyReLU(data=None, gamma=None, act_type=_Null, slope=_Null, lower_bound=_Null, upper_bound=_Null, out=None, name=None, **kwargs)Â¶","['Applies Leaky rectified linear unit activation element-wise to the input.', '\n', 'Leaky ReLUs attempt to fix the â\x80\x9cdying ReLUâ\x80\x9d problem by allowing a small ', 'slope', '\nwhen the input is negative and has a slope of one when input is positive.', '\n', 'The following modified ReLU Activation functions are supported:', '\n', '\n', 'elu', '\n', 'selu', '\n', 'leaky', '\n', 'prelu', '\n', 'rrelu', '\n', '\n', 'Defined in src/operator/leaky_relu.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.LinearRegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Computes and optimizes for squared loss during backward propagation.\nJust outputs ', 'data', ' during forward propagation.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the squared loss estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{SquaredLoss}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert  \\textbf{y}_i - \\hat{\\textbf{y}}_i  \\rVert_2\\)', '\n', '\n', 'Note', '\n', 'Use the LinearRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LinearRegressionOutput(default, default) = default', '\n', 'LinearRegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.LogisticRegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Applies a logistic function to the input.', '\n', 'The logistic function, also known as the sigmoid function, is computed as\n', '\\(\\frac{1}{1+exp(-\\textbf{x})}\\)', '.', '\n', 'Commonly, the sigmoid is used to squash the real-valued output of a linear model\n', '\\(wTx+b\\)', ' into the [0,1] range so that it can be interpreted as a probability.\nIt is suitable for binary classification or probability prediction tasks.', '\n', '\n', 'Note', '\n', 'Use the LogisticRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LogisticRegressionOutput(default, default) = default', '\n', 'LogisticRegressionOutput(default, csr) = default', '\n', '\n', 'The loss function used is the Binary Cross Entropy Loss:', '\n', '\\(-{(y\\log(p) + (1 - y)\\log(1 - p))}\\)', '\n', 'Where ', 'y', ' is the ground truth probability of positive outcome for a given example, and ', 'p', ' the probability predicted by the model. By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L152', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.MAERegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Computes mean absolute error of the input.', '\n', 'MAE is a risk metric corresponding to the expected value of the absolute error.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the mean absolute error (MAE) estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{MAE}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert \\textbf{y}_i - \\hat{\\textbf{y}}_i \\rVert_1\\)', '\n', '\n', 'Note', '\n', 'Use the MAERegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'MAERegressionOutput(default, default) = default', '\n', 'MAERegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L120', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.MakeLoss(data=None, grad_scale=_Null, valid_thresh=_Null, normalization=_Null, out=None, name=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'MakeLoss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'In addition, we can give a scale to the loss by setting ', 'grad_scale', ',\nso that the gradient of the loss will be rescaled in the backpropagation.', '\n', '\n', 'Note', '\n', 'This operator should be used as a Symbol instead of NDArray.', '\n', '\n', 'Defined in src/operator/make_loss.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, out=None, name=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Pooling(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Performs pooling on the input.', '\n', 'The shapes for 1-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The shapes for 2-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'When ', 'global_pool', ' is set to be true, then global pooling is performed. It will reset\n', 'kernel=(height,', ' and set the appropiate padding to 0.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', 'lp', '\n', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data and output will have shape ', '(batch_size, channel, depth,\nheight, width)', ' (NCDHW layout) or ', '(batch_size, depth, height, width, channel)', ' (NDHWC layout).', '\n', 'Notes on Lp pooling:', '\n', 'Lp pooling was first introduced by this paper: ', 'https://arxiv.org/pdf/1204.3968.pdf', '.\nL-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.\nWe can see that Lp pooling stands between those two, in practice the most common value for p is 2.', '\n', 'For each window ', 'X', ', the mathematical expression for Lp pooling is:', '\n', '\\(f(X) = \\sqrt[p]{\\sum_{x}^{X} x^p}\\)', '\n', 'Defined in src/operator/nn/pooling.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Pooling_v1(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, out=None, name=None, **kwargs)Â¶","['This operator is DEPRECATED.\nPerform pooling on the input.', '\n', 'The shapes for 2-D pooling is', '\n', '\n', 'data', '\n', 'out', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'But ', 'global_pool', ' is set to be true, then do a global pooling, namely reset\n', 'kernel=(height,', '.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', '\n', '1-D pooling is special case of 2-D pooling with ', 'weight=1', ' and\n', 'kernel[1]=1', '.', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data will have shape ', '(batch_size, channel, depth,\nheight, width)', '.', '\n', 'Defined in src/operator/pooling_v1.cc:L103', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.RNN(data=None, parameters=None, state=None, state_cell=None, sequence_length=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, out=None, name=None, **kwargs)Â¶","['Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are\nimplemented, with both multi-layer and bidirectional support.', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', 'Vanilla RNN', '\n', 'Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:\nReLU and Tanh.', '\n', 'With ReLU activation function:', '\n', '\n\\[h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'With Tanh activtion function:', '\n', '\n\\[h_t = \\tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'Reference paper: Finding structure in time - Elman, 1988.\n', 'https://crl.ucsd.edu/~elman/Papers/fsit.pdf', '\n', 'LSTM', '\n', 'Long Short-Term Memory - Hochreiter, 1997. ', 'http://www.bioinf.jku.at/publications/older/2604.pdf', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          \\end{array}\\end{split}\\]', '\n', 'With the projection size being set, LSTM could use the projection feature to reduce the parameters\nsize and give some speedups without significant damage to the accuracy.', '\n', 'Long Short-Term Memory Based Recurrent Neural Network Architectures for Large Vocabulary Speech\nRecognition - Sak et al. 2014. ', 'https://arxiv.org/abs/1402.1128', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{ri} r_{(t-1)} + b_{ri}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{rf} r_{(t-1)} + b_{rf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{rc} r_{(t-1)} + b_{rg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{o} + W_{ro} r_{(t-1)} + b_{ro}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          r_t = W_{hr} h_t\n          \\end{array}\\end{split}\\]', '\n', 'GRU', '\n', 'Gated Recurrent Unit - Cho et al. 2014. ', 'http://arxiv.org/abs/1406.1078', '\n', 'The definition of GRU here is slightly different from paper but compatible with CUDNN.', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          r_t = \\mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\\\\n          z_t = \\mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\\\\n          n_t = \\tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\\\\n          h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\\\\n          \\end{array}\\end{split}\\]', '\n', 'Defined in src/operator/rnn.cc:L375', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ROIPooling(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, out=None, name=None, **kwargs)Â¶","['Performs region of interest(ROI) pooling on the input array.', '\n', 'ROI pooling is a variant of a max pooling layer, in which the output size is fixed and\nregion of interest is a parameter. Its purpose is to perform max pooling on the inputs\nof non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net\nlayer mostly used in training a ', 'Fast R-CNN', ' network for object detection.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen it pools over sub-regions of input and produces a fixed-sized output array\nregardless of the ROI size.', '\n', 'To crop the feature map accordingly, you can resize the bounding box coordinates\nby changing the parameters ', 'rois', ' and ', 'spatial_scale', '.', '\n', 'The cropped feature maps are pooled by standard max pooling operation to a fixed size output\nindicated by a ', 'pooled_size', ' parameter. batch_size will change to the number of region\nbounding boxes after ', 'ROIPooling', '.', '\n', 'The size of each region of interest doesnâ\x80\x99t have to be perfectly divisible by\nthe number of pooling sections(', 'pooled_size', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/roi_pooling.cc:L224', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, out=None, name=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', 'Reshapes the input array into a new shape.', '\n', None, '\n', '\n', 'You can use ', '0', ' to copy a particular dimension from the input to the output shape\nand â\x80\x98-1â\x80\x99 to infer the dimensions of the output.', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SVMOutput(data=None, label=None, margin=_Null, regularization_coefficient=_Null, use_linear=_Null, out=None, name=None, **kwargs)Â¶","['Computes support vector machine based transformation of the input.', '\n', 'This tutorial demonstrates using SVM as output layer for classification instead of softmax:\n', 'https://github.com/apache/mxnet/tree/v1.x/example/svm_mnist', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SequenceLast(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Takes the last element of a sequence.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array\nof the form [batch_size, other_feature_dims].', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', ' should be\nan input array of positive ints of dimension [batch_size]. To use this parameter,\nset ', 'use_sequence_length', ' to ', 'True', ', otherwise each example in the batch is assumed\nto have the max sequence length.', '\n', '\n', 'Note', '\n', 'Alternatively, you can also use ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_last.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SequenceMask(data=None, sequence_length=None, use_sequence_length=_Null, value=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Sets all elements outside the sequence to a constant value.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', '\nshould be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length and\nthis operator works as the ', 'identity', ' operator.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_mask.cc:L185', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SequenceReverse(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Reverses the elements of each sequence.', '\n', 'This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]\nand returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences.\n', 'sequence_length', ' should be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_reverse.cc:L121', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SliceChannel(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, out=None, name=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.Softmax(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, out=None, name=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SoftmaxActivation(data=None, mode=_Null, out=None, name=None, **kwargs)Â¶","['Applies softmax activation to input. This is intended for internal layers.', '\n', '\n', 'Note', '\n', 'This operator has been deprecated, please use ', '\n', '\n', 'If ', 'mode', ' = ', 'instance', ', this operator will compute a softmax for each instance in the batch.\nThis is the default mode.', '\n', 'If ', 'mode', ' = ', 'channel', ', this operator will compute a k-class softmax at each position\nof each instance, where ', 'k', ' = ', 'num_channel', '. This mode can only be used when the input array\nhas at least 3 dimensions.\nThis can be used for ', 'fully convolutional network', ', ', 'image segmentation', ', etc.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax_activation.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SoftmaxOutput(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, out=None, name=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SpatialTransformer(data=None, loc=None, target_shape=_Null, transform_type=_Null, sampler_type=_Null, cudnn_off=_Null, out=None, name=None, **kwargs)Â¶","['Applies a spatial transformer to input feature map.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.SwapAxis(data=None, dim1=_Null, dim2=_Null, out=None, name=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.UpSampling(*data, **kwargs)Â¶","['Upsamples the given input data.', '\n', 'Two algorithms (', 'sample_type', ') are available for upsampling:', '\n', '\n', 'Nearest Neighbor', '\n', 'Bilinear', '\n', '\n', 'Nearest Neighbor Upsampling', '\n', 'Input data is expected to be NCHW.', '\n', 'Example:', '\n', None, '\n', '\n', 'Bilinear Upsampling', '\n', 'Uses ', 'deconvolution', ' algorithm under the hood. You need provide both input data and the kernel.', '\n', 'Input data is expected to be NCHW.', '\n', 'num_filter', ' is expected to be same as the number of channels.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/upsampling.cc:L172', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.abs(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise absolute value of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'abs', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L720', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.adam_update(weight=None, grad=None, mean=None, var=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Adam optimizer. Adam is seen as a generalization\nof AdaGrad.', '\n', 'Adam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nW_t = W_{t-1} - \\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon }\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and the storage\ntype of weight is the same as those of m and v,\nonly the row slices whose indices appear in grad.indices are updated (for w, m and v):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L687', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.add_n(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.all_finite(data=None, init_output=_Null, out=None, name=None, **kwargs)Â¶","['Check if all the float numbers in the array are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.amp_cast(data=None, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Cast function between low precision float/FP32 used by AMP.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L125', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.amp_multicast(*data, **kwargs)Â¶","['Cast function used by AMP, that casts its inputs to the common widest type.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L169', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.arccos(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse cosine of the input array.', '\n', 'The input should be in range ', '[-1, 1]', '.\nThe output is in the closed interval ', '\\([0, \\pi]\\)', '\n', '\n\\[arccos([-1, -.707, 0, .707, 1]) = [\\pi, 3\\pi/4, \\pi/2, \\pi/4, 0]\\]', '\n', 'The storage type of ', 'arccos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.arccosh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arccosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L535', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.arcsin(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse sine of the input array.', '\n', 'The input should be in the range ', '[-1, 1]', '.\nThe output is in the closed interval of [', '\\(-\\pi/2\\)', ', ', '\\(\\pi/2\\)', '].', '\n', '\n\\[arcsin([-1, -.707, 0, .707, 1]) = [-\\pi/2, -\\pi/4, 0, \\pi/4, \\pi/2]\\]', '\n', 'The storage type of ', 'arcsin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.arcsinh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arcsinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.arctan(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse tangent of the input array.', '\n', 'The output is in the closed interval ', '\\([-\\pi/2, \\pi/2]\\)', '\n', '\n\\[arctan([-1, 0, 1]) = [-\\pi/4, 0, \\pi/4]\\]', '\n', 'The storage type of ', 'arctan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L282', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.arctanh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.', '\n', 'The storage type of ', 'arctanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L579', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.argmax(data=None, axis=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Returns indices of the maximum values along an axis.', '\n', 'In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L51', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.argmax_channel(data=None, out=None, name=None, **kwargs)Â¶","['Returns argmax indices of each channel from the input array.', '\n', 'The result will be an NDArray of shape (num_channel,).', '\n', 'In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.argmin(data=None, axis=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Returns indices of the minimum values along an axis.', '\n', 'In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.argsort(data=None, axis=_Null, is_ascend=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Returns the indices that would sort an input array along the given axis.', '\n', 'This function performs sorting along the given axis and returns an array of indices having same shape\nas an input array that index data in sorted order.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L184', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.batch_dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, out=None, name=None, **kwargs)Â¶","['Batchwise dot product.', '\n', 'batch_dot', ' is used to compute dot product of ', 'x', ' and ', 'y', ' when ', 'x', ' and\n', 'y', ' are data in batch, namely N-D (N >= 3) arrays in shape of ', '(B0, â\x80¦, B_i, :, :)', '.', '\n', 'For example, given ', 'x', ' with shape ', '(B_0, â\x80¦, B_i, N, M)', ' and ', 'y', ' with shape\n', '(B_0, â\x80¦, B_i, M, K)', ', the result array will have shape ', '(B_0, â\x80¦, B_i, N, K)', ',\nwhich is computed by:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L127', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.batch_take(a=None, indices=None, out=None, name=None, **kwargs)Â¶","['Takes elements from a data batch.', '\n', '\n', 'Note', '\n', 'batch_take', '\n', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_add(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_axes(data=None, axis=_Null, size=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_axis(data=None, axis=_Null, size=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_div(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_div(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'equal to', ' (==) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L45', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_greater(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than', ' (>) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L81', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_greater_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than or equal to', ' (>=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_hypot(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the hypotenuse of a right angled triangle, given its â\x80\x9clegsâ\x80\x9d\nwith broadcasting.', '\n', 'It is equivalent to doing ', '\\(sqrt(x_1^2 + x_2^2)\\)', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_lesser(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than', ' (<) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L117', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_lesser_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than or equal to', ' (<=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_like(lhs=None, rhs=None, lhs_axes=_Null, rhs_axes=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts lhs to have the same shape as rhs.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_logical_and(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical and', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_logical_or(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical or', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L171', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_logical_xor(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical xor', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L189', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_maximum(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise maximum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise maxima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_minimum(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise minimum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise minima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_minus(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_mod(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise modulo of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_mul(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_mul(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L145', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_not_equal(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns the result of element-wise ', 'not equal to', ' (!=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L63', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_plus(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_power(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns result of first array elements raised to powers from second array, element-wise with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L44', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_sub(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.broadcast_to(data=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Broadcasts the input array to a new shape.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'The dimension which you do not want to change can also be kept as ', '0', ' which means copy the original value.\nSo with ', 'shape=(2,0)', ', we will obtain the same result as in the above example.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.cast(data=None, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.cast_storage(data=None, stype=_Null, out=None, name=None, **kwargs)Â¶","['Casts tensor storage type to the new type.', '\n', 'When an NDArray with default storage type is cast to csr or row_sparse storage,\nthe result is compact, which means:', '\n', '\n', 'for csr, zero values will not be retained', '\n', 'for row_sparse, row slices of all zeros will not be retained', '\n', '\n', 'The storage type of ', 'cast_storage', ' output depends on stype parameter:', '\n', '\n', 'cast_storage(csr, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(row_sparse, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(default, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(default, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', 'cast_storage(csr, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(row_sparse, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/cast_storage.cc:L71', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.cbrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise cube-root value of the input.', '\n', '\n\\[cbrt(x) = \\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'cbrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L270', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ceil(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise ceiling of the input.', '\n', 'The ceil of the scalar x is the smallest integer i, such that i >= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'ceil', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L817', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.choose_element_0index(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.clip(data=None, a_min=_Null, a_max=_Null, out=None, name=None, **kwargs)Â¶","['Clips (limits) the values in an array.\nGiven an interval, values outside the interval are clipped to the interval edges.\nClipping ', 'x', ' between ', 'a_min', ' and ', 'a_max', ' would be::\n.. math:', '\n', None, '\n', '\n', '\n', 'Example::', 'x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nclip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]', '\n', '\n', 'The storage type of ', 'clip', ' output depends on storage types of inputs and the a_min, a_max parameter values:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L676', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.col2im(data=None, output_size=_Null, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, out=None, name=None, **kwargs)Â¶","['Combining the output column matrix of im2col back to image array.', '\n', 'Like ', 'im2col', ', this operator is also used in the vanilla convolution\nimplementation. Despite the name, col2im is not the reverse operation of im2col. Since there\nmay be overlaps between neighbouring sliding blocks, the column elements cannot be directly\nput back into image. Instead, they are accumulated (i.e., summed) in the input image\njust like the gradient computation, so col2im is the gradient of im2col and vice versa.', '\n', 'Using the notation in im2col, given an input column array of shape\n', '\\((N, C \\times  \\prod(\\text{kernel}), W)\\)', ', this operator accumulates the column elements\ninto output array of shape ', '\\((N, C, \\text{output_size}[0], \\text{output_size}[1], \\dots)\\)', '.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L181', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.cos(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise cosine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[cos([0, \\pi/4, \\pi/2]) = [1, 0.707, 0]\\]', '\n', 'The storage type of ', 'cos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.cosh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic cosine  of the input array, computed element-wise.', '\n', '\n\\[cosh(x) = 0.5\\times(exp(x) + exp(-x))\\]', '\n', 'The storage type of ', 'cosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L409', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.crop(data=None, begin=_Null, end=_Null, step=_Null, out=None, name=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.cumsum(a=None, axis=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Return the cumulative sum of the elements along a given axis.', '\n', 'Defined in src/operator/numpy/np_cumsum.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.degrees(data=None, out=None, name=None, **kwargs)Â¶","['Converts each element of the input array from radians to degrees.', '\n', '\n\\[degrees([0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]) = [0, 90, 180, 270, 360]\\]', '\n', 'The storage type of ', 'degrees', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.depth_to_space(data=None, block_size=_Null, out=None, name=None, **kwargs)Â¶","['Rearranges(permutes) data from depth into blocks of spatial data.\nSimilar to ONNX DepthToSpace operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace', '.\nThe output is a new tensor where the values from depth dimension are moved in spatial blocks\nto height and width dimension. The reverse of this operation is ', 'space_to_depth', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C / (block\\_size ^ 2), H * block\\_size, W * block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L971', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.diag(data=None, k=_Null, axis1=_Null, axis2=_Null, out=None, name=None, **kwargs)Â¶","['Extracts a diagonal or constructs a diagonal array.', '\n', 'diag', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.', '\n', 'N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/diag_op.cc:L86', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, out=None, name=None, **kwargs)Â¶","['Dot product of two arrays.', '\n', 'dot', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: inner product of vectors', '\n', '2-D arrays: matrix multiplication', '\n', 'N-D arrays: a sum product over the last axis of the first input and the first\naxis of the second input', '\n', '\n', 'The storage type of ', 'dot', ' output depends on storage types of inputs, transpose option and\nforward_stype option for output storage type. Implemented sparse operations include:', '\n', '\n', 'dot(default, default, transpose_a=True/False, transpose_b=True/False) = default', '\n', 'dot(csr, default, transpose_a=True) = default', '\n', 'dot(csr, default, transpose_a=True) = row_sparse', '\n', 'dot(csr, default) = default', '\n', 'dot(csr, row_sparse) = default', '\n', 'dot(default, csr) = csr (CPU only)', '\n', 'dot(default, csr, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', 'dot(default, csr, transpose_b=True, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', '\n', 'If the combination of input storage types and forward_stype does not match any of the\nabove patterns, ', 'dot', ' will fallback and generate output with default storage.', '\n', '\n', 'Note', '\n', 'If the storage type of the lhs is â\x80\x9ccsrâ\x80\x9d, the storage type of gradient w.r.t rhs will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.elemwise_add(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Adds arguments element-wise.', '\n', 'The storage type of ', 'elemwise_add', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> x=mx.nd.array([1,2,3,4])
>>> y=mx.nd.array([1.1,2.1,3.1,4.1])
>>> mx.nd.elemwise_add(x,y).asnumpy()
array([ 2.0999999 ,  4.0999999 ,  6.0999999 ,  8.10000038], dtype=float32)
",,
"
mxnet.ndarray.op.elemwise_div(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Divides arguments element-wise.', '\n', 'The storage type of ', 'elemwise_div', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.elemwise_mul(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Multiplies arguments element-wise.', '\n', 'The storage type of ', 'elemwise_mul', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.elemwise_sub(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Subtracts arguments element-wise.', '\n', 'The storage type of ', 'elemwise_sub', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.erf(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L886', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.erfinv(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L908', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.exp(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise exponential value of the input.', '\n', '\n\\[exp(x) = e^x \\approx 2.718^x\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'exp', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L64', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.expand_dims(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Inserts a new axis of size 1 into the array shape\nFor example, given ', 'x', ' with shape ', '(2,3,4)', ', then ', 'expand_dims(x,', '\nwill return a new array with shape ', '(2,1,3,4)', '.', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L394', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.expm1(data=None, out=None, name=None, **kwargs)Â¶","['Returns ', 'exp(x)', ' computed element-wise on the input.', '\n', 'This function provides greater precision than ', 'exp(x)', ' for small values of ', 'x', '.', '\n', 'The storage type of ', 'expm1', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.fill_element_0index(lhs=None, mhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.fix(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer towards zero of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'fix', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L874', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.flatten(data=None, out=None, name=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.flip(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.floor(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise floor of the input.', '\n', 'The floor of the scalar x is the largest integer i, such that i <= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'floor', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L836', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ftml_update(weight=None, grad=None, d=None, v=None, z=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, wd=_Null, rescale_grad=_Null, clip_grad=_Null, out=None, name=None, **kwargs)Â¶","['The FTML optimizer described in\n', 'FTML - Follow the Moving Leader in Deep Learning', ',\navailable at ', 'http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf', '.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nd_t = \\frac{ 1 - \\beta_1^t }{ \\eta_t } (\\sqrt{ \\frac{ v_t }{ 1 - \\beta_2^t } } + \\epsilon)\n\\sigma_t = d_t - \\beta_1 d_{t-1}\nz_t = \\beta_1 z_{ t-1 } + (1 - \\beta_1^t) g_t - \\sigma_t W_{t-1}\nW_t = - \\frac{ z_t }{ d_t }\\end{split}\\]', '\n', 'Defined in src/operator/optimizer_op.cc:L639', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ftrl_update(weight=None, grad=None, z=None, n=None, lr=_Null, lamda1=_Null, beta=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Ftrl optimizer.\nReferenced from ', 'Ad Click Prediction: a View from the Trenches', ', available at\n', 'http://dl.acm.org/citation.cfm?id=2488200', '.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'If w, z and n are all of ', 'row_sparse', ' storage type,\nonly the row slices whose indices appear in grad.indices are updated (for w, z and n):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L875', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.gamma(data=None, out=None, name=None, **kwargs)Â¶","['Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.', '\n', 'The storage type of ', 'gamma', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.gammaln(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise log of the absolute value of the gamma function of the input.', '\n', 'The storage type of ', 'gammaln', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.gather_nd(data=None, indices=None, out=None, name=None, **kwargs)Â¶","['Gather elements or slices from ', 'data', ' and store to a tensor whose\nshape is defined by ', 'indices', '.', '\n', 'Given ', 'data', ' with shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', output shape will simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.hard_sigmoid(data=None, alpha=_Null, beta=_Null, out=None, name=None, **kwargs)Â¶","['Computes hard sigmoid of x element-wise.', '\n', '\n\\[y = max(0, min(1, alpha * x + beta))\\]', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L161', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.identity(data=None, out=None, name=None, **kwargs)Â¶","['Returns a copy of the input.', '\n', 'From:src/operator/tensor/elemwise_unary_op_basic.cc:244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.im2col(data=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, out=None, name=None, **kwargs)Â¶","['Extract sliding blocks from input array.', '\n', 'This operator is used in vanilla convolution implementation to transform the sliding\nblocks on image to column matrix, then the convolution operation can be computed\nby matrix multiplication between column and convolution weight. Due to the close\nrelation between im2col and convolution, the concept of ', 'kernel', ', ', 'stride', ',\n', 'dilate', ' and ', 'pad', ' in this operator are inherited from convolution operation.', '\n', 'Given the input data of shape ', '\\((N, C, *)\\)', ', where ', '\\(N\\)', ' is the batch size,\n', '\\(C\\)', ' is the channel size, and ', '\\(*\\)', ' is the arbitrary spatial dimension,\nthe output column array is always with shape ', '\\((N, C \\times \\prod(\\text{kernel}), W)\\)', ',\nwhere ', '\\(C \\times \\prod(\\text{kernel})\\)', ' is the block size, and ', '\\(W\\)', ' is the\nblock number which is the spatial size of the convolution output with same input parameters.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.khatri_rao(*args, **kwargs)Â¶","['Computes the Khatri-Rao product of the input matrices.', '\n', 'Given a collection of ', '\\(n\\)', ' input matrices,', '\n', '\n\\[A_1 \\in \\mathbb{R}^{M_1 \\times M}, \\ldots, A_n \\in \\mathbb{R}^{M_n \\times N},\\]', '\n', 'the (column-wise) Khatri-Rao product is defined as the matrix,', '\n', '\n\\[X = A_1 \\otimes \\cdots \\otimes A_n \\in \\mathbb{R}^{(M_1 \\cdots M_n) \\times N},\\]', '\n', 'where the ', '\\(k\\)', ' th column is equal to the column-wise outer product\n', '\\({A_1}_k \\otimes \\cdots \\otimes {A_n}_k\\)', ' where ', '\\({A_i}_k\\)', ' is the kth\ncolumn of the ith matrix.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/krprod.cc:L108', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.lamb_update_phase1(weight=None, grad=None, mean=None, var=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Phase I of lamb update it performs the following operations and returns g:.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\ngrad = grad * rescale_grad\nif (grad < -clip_gradient)\nthen\n     grad = -clip_gradient\nif (grad > clip_gradient)\nthen\n     grad = clip_gradient\\\\mean = beta1 * mean + (1 - beta1) * grad;\nvariance = beta2 * variance + (1. - beta2) * grad ^ 2;\\\\if (bias_correction)\nthen\n     mean_hat = mean / (1. - beta1^t);\n     var_hat = var / (1 - beta2^t);\n     g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;\nelse\n     g = mean / (var_data^(1/2) + epsilon) + wd * weight;\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L952', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.lamb_update_phase2(weight=None, g=None, r1=None, r2=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, out=None, name=None, **kwargs)Â¶","['Phase II of lamb update it performs the following operations and updates grad.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\nif (lower_bound >= 0)\nthen\n     r1 = max(r1, lower_bound)\nif (upper_bound >= 0)\nthen\n     r1 = max(r1, upper_bound)\\\\if (r1 == 0 or r2 == 0)\nthen\n     lr = lr\nelse\n     lr = lr * (r1/r2)\nweight = weight - lr * g\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L991', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_det(A=None, out=None, name=None, **kwargs)Â¶","['Compute the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'det', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'There is no gradient backwarded when A is non-invertible (which is\nequivalent to det(A) = 0) because zero is rarely hit upon in float\npoint computation and the Jacobiâ\x80\x99s formula on determinant gradient\nis not computationally efficient when A is non-invertible.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L974', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_extractdiag(A=None, offset=_Null, out=None, name=None, **kwargs)Â¶","['Extracts the diagonal entries of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an ', 'n-1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_extracttrian(A=None, offset=_Null, lower=_Null, out=None, name=None, **kwargs)Â¶","['Extracts a triangular sub-matrix from a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an ', 'n-1', '-dimensional tensor.', '\n', 'The ', 'offset', ' and ', 'lower', ' parameters determine the triangle to be extracted:', '\n', '\n', 'When ', '\n', 'When ', '\n', 'When ', '\n', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L604', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_gelqf(A=None, out=None, name=None, **kwargs)Â¶","['LQ factorization for general matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', we compute the LQ factorization (LAPACK ', 'gelqf', ', followed by ', 'orglq', '). ', 'A', '\nmust have shape ', '(x, y)', ' with ', 'x <= y', ', and must have full rank ', '=x', '. The LQ\nfactorization consists of ', 'L', ' with shape ', '(x, x)', ' and ', 'Q', ' with shape ', '(x, y)', ', so\nthat:', '\n', '\n', 'A', '\n', 'Here, ', 'L', ' is lower triangular (upper triangle equal to zero) with nonzero diagonal,\nand ', 'Q', ' is row-orthonormal, meaning that', '\n', '\n', 'Q', '\n', 'is equal to the identity matrix of shape ', '(x, x)', '.', '\n', 'If ', 'n>2', ', ', 'gelqf', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L797', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_gemm(A=None, B=None, C=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, beta=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Performs general matrix multiplication and accumulation.\nInput are tensors ', 'A', ', ', 'B', ', ', 'C', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here, ', 'alpha', ' and ', 'beta', ' are scalar parameters, and ', 'op()', ' is either the identity or\nmatrix transposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ', ', 'C', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', ', 'C', ', axis=1) is equivalent\nto the following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_gemm2(A=None, B=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Performs general matrix multiplication.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here ', 'alpha', ' is a scalar parameter and ', 'op()', ' is either the identity or the matrix\ntransposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', axis=1) is equivalent to\nthe following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_inverse(A=None, out=None, name=None, **kwargs)Â¶","['Compute the inverse of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'inverse', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L919', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_makediag(A=None, offset=_Null, out=None, name=None, **kwargs)Â¶","['Constructs a square matrix with the input as diagonal.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.\nIf ', 'n>1', ', then ', 'A', ' represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_maketrian(A=None, offset=_Null, lower=_Null, out=None, name=None, **kwargs)Â¶","['Constructs a square matrix with the input representing a specific triangular sub-matrix.\nThis is basically the inverse of ', 'linalg.extracttrian', '. Input is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the entries of a triangular matrix which is lower triangular if ', 'offset<0', ' or ', 'offset=0', ', ', 'lower=true', '. The resulting matrix is derived by first constructing the square\nmatrix with the entries outside the triangle set to zero and then adding ', 'offset', '-times an additional\ndiagonal with zero entries to the square matrix.', '\n', 'If ', 'n>1', ', then ', 'A', ' represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L672', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_potrf(A=None, out=None, name=None, **kwargs)Â¶","['Performs Cholesky factorization of a symmetric positive-definite matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the Cholesky factor ', 'B', ' of the symmetric, positive definite matrix ', 'A', ' is\ncomputed. ', 'B', ' is triangular (entries of upper or lower triangle are all zero), has\npositive diagonal entries, and:', '\n', '\n', 'A', '\n', 'If ', 'n>2', ', ', 'potrf', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_potri(A=None, out=None, name=None, **kwargs)Â¶","['Performs matrix inversion from a Cholesky factorization.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a triangular matrix (entries of upper or lower triangle are all zero)\nwith positive diagonal. We compute:', '\n', '\n', 'out', '\n', 'In other words, if ', 'A', ' is the Cholesky factor of a symmetric positive definite matrix\n', 'B', ' (obtained by ', 'potrf', '), then', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'potri', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Use this operator only if you are certain you need the inverse of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L274', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_slogdet(A=None, out=None, name=None, **kwargs)Â¶","['Compute the sign and log of the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'sign', '\n', 'If ', 'n>2', ', ', 'slogdet', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'The gradient is not properly defined on sign, so the gradient of\nit is not backwarded.', '\n', '\n', '\n', 'Note', '\n', 'No gradient is backwarded when A is non-invertible. Please see\nthe docs of operator det for detail.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L1033', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_sumlogdiag(A=None, out=None, name=None, **kwargs)Â¶","['Computes the sum of the logarithms of the diagonal elements of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be square with positive diagonal entries. We sum the natural\nlogarithms of the diagonal elements, the result has shape (1,).', '\n', 'If ', 'n>2', ', ', 'sumlogdiag', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L444', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_syrk(A=None, transpose=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Multiplication of matrix with its transpose.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the operator performs the BLAS3 function ', 'syrk', ':', '\n', '\n', 'out', '\n', 'if ', 'transpose=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'transpose=True', '.', '\n', 'If ', 'n>2', ', ', 'syrk', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L729', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_trmm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Performs multiplication with a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trmm', ':', '\n', '\n', 'out', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trmm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.linalg_trsm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Solves matrix equation involving a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trsm', ', solving for ', 'out', ' in:', '\n', '\n', 'op', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trsm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L395', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.log(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Natural logarithmic value of the input.', '\n', 'The natural logarithm is logarithm in base ', 'e', ', so that ', 'log(exp(x))', '\n', 'The storage type of ', 'log', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.log10(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Base-10 logarithmic value of the input.', '\n', '10**log10(x)', '\n', 'The storage type of ', 'log10', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.log1p(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise ', 'log(1', ' value of the input.', '\n', 'This function is more accurate than ', 'log(1', '  for small ', 'x', ' so that\n', '\\(1+x\\approx 1\\)', '\n', 'The storage type of ', 'log1p', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.log2(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Base-2 logarithmic value of the input.', '\n', '2**log2(x)', '\n', 'The storage type of ', 'log2', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.log_softmax(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, out=None, name=None, **kwargs)Â¶","['Computes the log softmax of the input.\nThis is equivalent to computing softmax followed by log.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.logical_not(data=None, out=None, name=None, **kwargs)Â¶","['Returns the result of logical NOT (!) function', '\n', 'Example', '\n', 'logical_not([-2., 0., 1.]) = [0., 1., 0.]', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.make_loss(data=None, out=None, name=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'make_loss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'The storage type of ', 'make_loss', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L358', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.max(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.max_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.mean(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the mean of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.min(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.min_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.moments(data=None, axes=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Calculate the mean and variance of ', 'data', '.', '\n', 'The mean and variance are calculated by aggregating the contents of data across axes.\nIf x is 1-D and axes = [0] this is just the mean and variance of a vector.', '\n', 'Example', '\n', 'x = [[1, 2, 3], [4, 5, 6]]\nmean, var = moments(data=x, axes=[0])\nmean = [2.5, 3.5, 4.5]\nvar = [2.25, 2.25, 2.25]\nmean, var = moments(data=x, axes=[1])\nmean = [2.0, 5.0]\nvar = [0.66666667, 0.66666667]\nmean, var = moments(data=x, axis=[0, 1])\nmean = [3.5]\nvar = [2.9166667]', '\n', 'Defined in src/operator/nn/moments.cc:L53', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.mp_lamb_update_phase1(weight=None, grad=None, mean=None, var=None, weight32=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Mixed Precision version of Phase I of lamb update\nit performs the following operations and returns g:.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1032', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.mp_lamb_update_phase2(weight=None, g=None, r1=None, r2=None, weight32=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, out=None, name=None, **kwargs)Â¶","['Mixed Precision version Phase II of lamb update\nit performs the following operations and updates grad.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1074', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.mp_nag_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.', '\n', 'Defined in src/operator/optimizer_op.cc:L744', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.mp_sgd_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.mp_sgd_update(weight=None, grad=None, weight32=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.multi_all_finite(*data, **kwargs)Â¶","['Check if all the float numbers in all the arrays are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.multi_lars(lrs=None, weights_sum_sq=None, grads_sum_sq=None, wds=None, eta=_Null, eps=_Null, rescale_grad=_Null, out=None, name=None, **kwargs)Â¶","['Compute the LARS coefficients of multiple weights and grads from their sums of squareâ\x80\x9d', '\n', 'Defined in src/operator/contrib/multi_lars.cc:L36', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L471', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L373', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L328', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.multi_sum_sq(*data, **kwargs)Â¶","['Compute the sums of squares of multiple arrays', '\n', 'Defined in src/operator/contrib/multi_sum_sq.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.nag_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Nesterov Accelerated Gradient( NAG) optimizer.\nIt updates the weights using the following formula,', '\n', '\n\\[\\begin{split}v_t = \\gamma v_{t-1} + \\eta * \\nabla J(W_{t-1} - \\gamma v_{t-1})\\\\\nW_t = W_{t-1} - v_t\\end{split}\\]', '\n', 'Where\n', '\\(\\eta\\)', ' is the learning rate of the optimizer\n', '\\(\\gamma\\)', ' is the decay rate of the momentum estimate\n', '\\(\\v_t\\)', ' is the update vector at time step ', 't', '\n', '\\(\\W_t\\)', ' is the weight vector at time step ', 't', '\n', 'Defined in src/operator/optimizer_op.cc:L725', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.nanprod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the product of array elements over given axes treating Not a Numbers (', 'NaN', ') as one.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_prod_value.cc:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.nansum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the sum of array elements over given axes treating Not a Numbers (', 'NaN', ') as zero.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.negative(data=None, out=None, name=None, **kwargs)Â¶","['Numerical negative of the argument, element-wise.', '\n', 'The storage type of ', 'negative', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.norm(data=None, ord=_Null, axis=_Null, out_dtype=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Computes the norm on an NDArray.', '\n', 'This operator computes the norm on an NDArray with the specified axis, depending\non the value of the ord parameter. By default, it computes the L2 norm on the entire\narray. Currently only ord=2 supports sparse ndarrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_norm_value.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.one_hot(indices=None, depth=_Null, on_value=_Null, off_value=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Returns a one-hot array.', '\n', 'The locations represented by ', 'indices', ' take value ', 'on_value', ', while all\nother locations take value ', 'off_value', '.', '\n', 'one_hot', ' operation with ', 'indices', ' of shape ', '(i0,', ' and ', 'depth', '  of ', 'd', ' would result\nin an output array of shape ', '(i0,', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L882', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ones_like(data=None, out=None, name=None, **kwargs)Â¶","['Return an array of ones with the same shape and type\nas the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, out=None, name=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.pick(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.preloaded_multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.preloaded_multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L139', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.preloaded_multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.preloaded_multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.prod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the product of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L30', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.radians(data=None, out=None, name=None, **kwargs)Â¶","['Converts each element of the input array from degrees to radians.', '\n', '\n\\[radians([0, 90, 180, 270, 360]) = [0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]\\]', '\n', 'The storage type of ', 'radians', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L351', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_exponential(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from an exponential distribution.', '\n', 'Samples are distributed according to an exponential distribution parametrized by ', 'lambda', ' (rate).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_gamma(alpha=_Null, beta=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a gamma distribution.', '\n', 'Samples are distributed according to a gamma distribution parametrized by ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L124', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_generalized_negative_binomial(mu=_Null, alpha=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a generalized negative binomial distribution.', '\n', 'Samples are distributed according to a generalized negative binomial distribution parametrized by\n', 'mu', ' (mean) and ', 'alpha', ' (dispersion). ', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_negative_binomial(k=_Null, p=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a negative binomial distribution.', '\n', 'Samples are distributed according to a negative binomial distribution parametrized by\n', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure probability in each experiment).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L163', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_dirichlet(sample=None, alpha=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nDirichlet distributions with parameter ', 'alpha', '.', '\n', 'The shape of ', 'alpha', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'alpha', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'alpha', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L315', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_exponential(sample=None, lam=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nexponential distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L304', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_gamma(sample=None, alpha=None, beta=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (rate).', '\n', 'alpha', ' and ', 'beta', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'alpha', ' and ', 'beta', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'alpha', ' and ', 'beta', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L302', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_generalized_negative_binomial(sample=None, mu=None, alpha=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean)\nand ', 'alpha', ' (dispersion).  This can be understood as a reparameterization of\nthe negative binomial, where ', 'k', ' = ', '1 / alpha', ' and ', 'p', ' = ', '1 / (mu * alpha + 1)', '.', '\n', 'mu', ' and ', 'alpha', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'alpha', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'alpha', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L313', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_negative_binomial(sample=None, k=None, p=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of samples of\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'k', ' and ', 'p', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'k', ' and ', 'p', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'k', ' and ', 'p', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L309', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_normal(sample=None, mu=None, sigma=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'mu', ' and ', 'sigma', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'sigma', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'sigma', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L299', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_poisson(sample=None, lam=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nPoisson distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L306', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_pdf_uniform(sample=None, low=None, high=None, is_log=_Null, out=None, name=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'low', ' and ', 'high', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'low', ' and ', 'high', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'low', ' and ', 'high', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L297', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_poisson(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a Poisson distribution.', '\n', 'Samples are distributed according to a Poisson distribution parametrized by ', 'lambda', ' (rate).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L149', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_randint(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a discrete uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L193', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.random_uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.ravel_multi_index(data=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.rcbrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse cube-root value of the input.', '\n', '\n\\[rcbrt(x) = 1/\\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L323', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.reciprocal(data=None, out=None, name=None, **kwargs)Â¶","['Returns the reciprocal of the argument, element-wise.', '\n', 'Calculates 1/x.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L43', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.relu(data=None, out=None, name=None, **kwargs)Â¶","['Computes rectified linear activation.', '\n', '\n\\[max(features, 0)\\]', '\n', 'The storage type of ', 'relu', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.repeat(data=None, repeats=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Repeats elements of an array.\nBy default, ', 'repeat', ' flattens the input array into 1-D and then repeats the\nelements:', '\n', None, '\n', '\n', '\n', 'The parameter ', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L743', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.reset_arrays(*data, **kwargs)Â¶","['Set to zero multiple arrays', '\n', 'Defined in src/operator/contrib/reset_arrays.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, out=None, name=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.reshape_like(lhs=None, rhs=None, lhs_begin=_Null, lhs_end=_Null, rhs_begin=_Null, rhs_end=_Null, out=None, name=None, **kwargs)Â¶","['Reshape some or all dimensions of ', 'lhs', ' to have the same shape as some or all dimensions of ', 'rhs', '.', '\n', 'Returns a ', 'view', ' of the ', 'lhs', ' array with a new shape without altering any data.', '\n', 'Example:', '\n', None, '\n', '\n', 'More precise control over how dimensions are inherited is achieved by specifying slices over the ', 'lhs', ' and ', 'rhs', ' array dimensions. Only the sliced ', 'lhs', ' dimensions are reshaped to the ', 'rhs', ' sliced dimensions, with the non-sliced ', 'lhs', ' dimensions staying the same.', '\n', '\n', 'Examples:', '\n', 'Negative indices are supported, and ', 'None', ' can be used for either ', 'lhs_end', ' or ', 'rhs_end', ' to indicate the end of the range.', '\n', '\n', 'Example:', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L511', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.reverse(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.rint(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rint', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L798', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.rmsprop_update(weight=None, grad=None, n=None, lr=_Null, gamma1=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, out=None, name=None, **kwargs)Â¶","['Update function for ', 'RMSProp', ' optimizer.', '\n', 'RMSprop', ' is a variant of stochastic gradient descent where the gradients are\ndivided by a cache which grows with the sum of squares of recent gradients?', '\n', 'RMSProp', ' is similar to ', 'AdaGrad', ', a popular variant of ', 'SGD', ' which adaptively\ntunes the learning rate of each parameter. ', 'AdaGrad', ' lowers the learning rate for\neach parameter monotonically over the course of training.\nWhile this is analytically motivated for convex optimizations, it may not be ideal\nfor non-convex problems. ', 'RMSProp', ' deals with this heuristically by allowing the\nlearning rates to rebound as the denominator decays over time.', '\n', 'Define the Root Mean Square (RMS) error criterion of the gradient as\n', '\\(RMS[g]_t = \\sqrt{E[g^2]_t + \\epsilon}\\)', ', where ', '\\(g\\)', ' represents\ngradient and ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient.', '\n', 'The ', '\\(E[g^2]_t\\)', ' is given by:', '\n', '\n\\[E[g^2]_t = \\gamma * E[g^2]_{t-1} + (1-\\gamma) * g_t^2\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t - \\frac{\\eta}{RMS[g]_t} g_t\\]', '\n', 'The RMSProp code follows the version in\n', 'http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf', '\nTieleman & Hinton, 2012.', '\n', 'Hinton suggests the momentum term ', '\\(\\gamma\\)', ' to be 0.9 and the learning rate\n', '\\(\\eta\\)', ' to be 0.001.', '\n', 'Defined in src/operator/optimizer_op.cc:L796', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.rmspropalex_update(weight=None, grad=None, n=None, g=None, delta=None, lr=_Null, gamma1=_Null, gamma2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, out=None, name=None, **kwargs)Â¶","['Update function for RMSPropAlex optimizer.', '\n', 'RMSPropAlex', ' is non-centered version of ', 'RMSProp', '.', '\n', 'Define ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient and\n', '\\(E[g]_t\\)', ' is the decaying average over past gradient.', '\n', '\n\\[\\begin{split}E[g^2]_t = \\gamma_1 * E[g^2]_{t-1} + (1 - \\gamma_1) * g_t^2\\\\\nE[g]_t = \\gamma_1 * E[g]_{t-1} + (1 - \\gamma_1) * g_t\\\\\n\\Delta_t = \\gamma_2 * \\Delta_{t-1} - \\frac{\\eta}{\\sqrt{E[g^2]_t - E[g]_t^2 + \\epsilon}} g_t\\\\\\end{split}\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t + \\Delta_t\\]', '\n', 'The RMSPropAlex code follows the version in\n', 'http://arxiv.org/pdf/1308.0850v5.pdf', ' Eq(38) - Eq(45) by Alex Graves, 2013.', '\n', 'Graves suggests the momentum term ', '\\(\\gamma_1\\)', ' to be 0.95, ', '\\(\\gamma_2\\)', '\nto be 0.9 and the learning rate ', '\\(\\eta\\)', ' to be 0.0001.', '\n', 'Defined in src/operator/optimizer_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.round(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'round', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L777', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.rsqrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse square-root value of the input.', '\n', '\n\\[rsqrt(x) = 1/\\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rsqrt', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_exponential(lam=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nexponential distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_gamma(alpha=None, beta=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L281', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_generalized_negative_binomial(mu=None, alpha=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean) and ', 'alpha', ' (dispersion).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L292', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_multinomial(data=None, shape=_Null, get_prob=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple multinomial distributions.', '\n', 'data', ' is an ', 'n', ' dimensional array whose last dimension has length ', 'k', ', where\n', 'k', ' is the number of possible outcomes of each multinomial distribution. This\noperator will draw ', 'shape', ' samples from each distribution. If shape is empty\none sample will be drawn from each distribution.', '\n', 'If ', 'get_prob', ' is true, a second array containing log likelihood of the drawn\nsamples will also be returned. This is usually used for reinforcement learning\nwhere you can provide reward as head gradient for this array to estimate\ngradient.', '\n', 'Note that the input distribution must be normalized, i.e. ', 'data', ' must sum to\n1 along its last axis.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_negative_binomial(k=None, p=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L288', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_normal(mu=None, sigma=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L278', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_poisson(lam=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nPoisson distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L285', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sample_uniform(low=None, high=None, shape=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Concurrent sampling from multiple\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L276', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.scatter_nd(data=None, indices=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Scatters data into a new tensor according to indices.', '\n', 'Given ', 'data', ' with shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', data shape should simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'all other entries in output are 0.', '\n', '\n', 'Warning', '\n', 'If the indices have duplicates, the result will be non-deterministic and\nthe gradient of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sgd_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and weightâ\x80\x99s storage\ntype is the same as momentumâ\x80\x99s storage type,\nonly the row slices whose indices appear in grad.indices are updated (for both weight and momentum):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L564', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradient is of ', 'row_sparse', ' storage type and ', 'lazy_update', ' is True,\nonly the row slices whose indices appear in grad.indices are updated:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L523', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.shape_array(data=None, out=None, name=None, **kwargs)Â¶","['Returns a 1D int64 array containing the shape of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L573', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.shuffle(data=None, out=None, name=None, **kwargs)Â¶","['Randomly shuffle the elements.', '\n', 'This shuffles the array along the first axis.\nThe order of the elements in each subarray does not change.\nFor example, if a 2D array is given, the order of the rows randomly changes,\nbut the order of the elements in each row does not change.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sigmoid(data=None, out=None, name=None, **kwargs)Â¶","['Computes sigmoid of x element-wise.', '\n', '\n\\[y = 1 / (1 + exp(-x))\\]', '\n', 'The storage type of ', 'sigmoid', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sign(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sign of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sign', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L758', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.signsgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for SignSGD optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(g_t)\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L62', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.signum_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, wd_lh=_Null, out=None, name=None, **kwargs)Â¶","['SIGN momentUM (Signum) optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta m_{t-1} + (1 - \\beta) g_t\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(m_t)\\end{split}\\]', '\n', '\n', 'It updates the weights using::', 'state = momentum * state + (1-momentum) * gradient\nweight = weight - learning_rate * sign(state)', '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L91', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sin(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise sine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[sin([0, \\pi/4, \\pi/2]) = [0, 0.707, 1]\\]', '\n', 'The storage type of ', 'sin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L47', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sinh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic sine of the input array, computed element-wise.', '\n', '\n\\[sinh(x) = 0.5\\times(exp(x) - exp(-x))\\]', '\n', 'The storage type of ', 'sinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L371', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.size_array(data=None, out=None, name=None, **kwargs)Â¶","['Returns a 1D int64 array containing the size of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.slice(data=None, begin=_Null, end=_Null, step=_Null, out=None, name=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.slice_axis(data=None, axis=_Null, begin=_Null, end=_Null, out=None, name=None, **kwargs)Â¶","['Slices along a given axis.\nReturns an array slice along a given ', 'axis', ' starting from the ', 'begin', ' index\nto the ', 'end', ' index.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L570', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.slice_like(data=None, shape_like=None, axes=_Null, out=None, name=None, **kwargs)Â¶","['Slices a region of the array like the shape of another array.\nThis function is similar to ', 'slice', ', however, the ', 'begin', ' are always ', '0`s\nand `end', ' of specific axes are inferred from the second input ', 'shape_like', '.\nGiven the second ', 'shape_like', ' input of ', 'shape=(d_0,', ',\na ', 'slice_like', ' operator with default empty ', 'axes', ', it performs the\nfollowing operation:\n`` out = slice(input, begin=(0, 0, â\x80¦, 0), end=(d_0, d_1, â\x80¦, d_n-1))``.\nWhen ', 'axes', ' is not empty, it is used to speficy which axes are being sliced.\nGiven a 4-d input data, ', 'slice_like', ' operator with ', 'axes=(0,', '\nwill perform the following operation:\n`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.\nNote that it is allowed to have first and second input with different dimensions,\nhowever, you have to make sure the ', 'axes', ' are specified and not exceeding the\ndimension limits.\nFor example, given ', 'input_1', ' with ', 'shape=(2,3,4,5)', ' and ', 'input_2', ' with\n', 'shape=(1,2,3)', ', it is not allowed to use:\n`` out = slice_like(a, b)`` because ndim of ', 'input_1', ' is 4, and ndim of ', 'input_2', '\nis 3.\nThe following is allowed in this situation:\n`` out = slice_like(a, b, axes=(0, 2))``\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.smooth_l1(data=None, scalar=_Null, out=None, name=None, **kwargs)Â¶","['Calculate Smooth L1 Loss(lhs, scalar) by summing', '\n', '\n\\[\\begin{split}f(x) =\n\\begin{cases}\n(\\sigma x)^2/2,& \\text{if }x < 1/\\sigma^2\\\\\n|x|-0.5/\\sigma^2,& \\text{otherwise}\n\\end{cases}\\end{split}\\]', '\n', 'where ', '\\(x\\)', ' is an element of the tensor ', 'lhs', ' and ', '\\(\\sigma\\)', ' is the scalar.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L108', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.softmax(data=None, length=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, out=None, name=None, **kwargs)Â¶","['Applies the softmax function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.', '\n', '\n\\[softmax(\\mathbf{z/t})_j = \\frac{e^{z_j/t}}{\\sum_{k=1}^K e^{z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.softmax_cross_entropy(data=None, label=None, out=None, name=None, **kwargs)Â¶","['Calculate cross entropy of softmax output and one-hot label.', '\n', '\n', 'This operator computes the cross entropy in two steps:\n- Applies softmax function on the input array.\n- Computes and returns the cross entropy loss between the softmax output and the labels.', '\n', 'The softmax function and cross entropy loss is given by:', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/loss_binary_op.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.softmin(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, out=None, name=None, **kwargs)Â¶","['Applies the softmin function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum\nup to 1.', '\n', '\n\\[softmin(\\mathbf{z/t})_j = \\frac{e^{-z_j/t}}{\\sum_{k=1}^K e^{-z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmin.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.softsign(data=None, out=None, name=None, **kwargs)Â¶","['Computes softsign of x element-wise.', '\n', '\n\\[y = x / (1 + abs(x))\\]', '\n', 'The storage type of ', 'softsign', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L191', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sort(data=None, axis=_Null, is_ascend=_Null, out=None, name=None, **kwargs)Â¶","['Returns a sorted copy of an input array along the given axis.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.space_to_depth(data=None, block_size=_Null, out=None, name=None, **kwargs)Â¶","['Rearranges(permutes) blocks of spatial data into depth.\nSimilar to ONNX SpaceToDepth operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth', '\nThe output is a new tensor where the values from height and width dimension are\nmoved to the depth dimension. The reverse of this operation is ', 'depth_to_space', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C * (block\\_size ^ 2), H / block\\_size, W / block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L1018', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.split(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, out=None, name=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sqrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise square-root value of the input.', '\n', '\n\\[\\textrm{sqrt}(x) = \\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sqrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L170', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.square(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise squared value of the input.', '\n', '\n\\[square(x) = x^2\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'square', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.squeeze(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Remove single-dimensional entries from the shape of an array.\nSame behavior of defining the output tensor shape as numpy.squeeze for the most of cases.\nSee the following note for exception.\nExamples:', '\n', None, '\n', '\n', '\n', 'Note', '\n', 'The output of this operator will keep at least one dimension not removed. For example,\nsqueeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.stack(*data, **kwargs)Â¶","['Join a sequence of arrays along a new axis.\nThe axis parameter specifies the index of the new axis in the dimensions of the\nresult. For example, if axis=0 it will be the first dimension and if axis=-1 it\nwill be the last dimension.\nExamples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.stop_gradient(data=None, out=None, name=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.sum_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.swapaxes(data=None, dim1=_Null, dim2=_Null, out=None, name=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.take(a=None, indices=None, axis=_Null, mode=_Null, out=None, name=None, **kwargs)Â¶","['Takes elements from an input array along the given axis.', '\n', 'This function slices the input array along a particular axis with the provided indices.', '\n', 'Given data tensor of rank r >= 1, and indices tensor of rank q, gather entries of the axis\ndimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them\nin an output tensor of rank q + (r - 1).', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of ', 'take', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L776', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.tan(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise tangent of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[tan([0, \\pi/4, \\pi/2]) = [0, 1, -inf]\\]', '\n', 'The storage type of ', 'tan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L140', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.tanh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic tangent of the input array, computed element-wise.', '\n', '\n\\[tanh(x) = sinh(x) / cosh(x)\\]', '\n', 'The storage type of ', 'tanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L451', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.tile(data=None, reps=_Null, out=None, name=None, **kwargs)Â¶","['Repeats the whole array multiple times.\nIf ', 'reps', ' has length ', 'd', ', and input array has dimension of ', 'n', '. There are\nthree cases:\n- ', 'n=d', '. Repeat ', 'i', '-th dimension of the input by ', 'reps[i]', ' times:', '\n', None, '\n', '\n', '\n', 'n>d', '\n', 'n<d', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L795', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.topk(data=None, axis=_Null, k=_Null, ret_typ=_Null, is_ascend=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Returns the indices of the top ', 'axis (by default).\nIf ret_type is set to â\x80\x98valueâ\x80\x99 returns the value of top ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.transpose(data=None, axes=_Null, out=None, name=None, **kwargs)Â¶","['Permutes the dimensions of an array.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L327', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.trunc(data=None, out=None, name=None, **kwargs)Â¶","['Return the element-wise truncated value of the input.', '\n', 'The truncated value of the scalar x is the nearest integer i which is closer to\nzero than x is. In short, the fractional part of the signed number x is discarded.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'trunc', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L856', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.unravel_index(data=None, shape=_Null, out=None, name=None, **kwargs)Â¶","['Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.where(condition=None, x=None, y=None, out=None, name=None, **kwargs)Â¶","['Return the elements, either from x or y, depending on the condition.', '\n', 'Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,\ndepending on the elements from condition are true or false. x and y must have the same shape.\nIf condition has the same shape as x, each element in the output array is from x if the\ncorresponding element in the condition is true, and from y if false.', '\n', 'If condition does not have the same shape as x, it must be a 1D array whose size is\nthe same as xâ\x80\x99s first dimension size. Each row of the output array is from xâ\x80\x99s row\nif the corresponding element from condition is true, and from yâ\x80\x99s row if false.', '\n', 'Note that all non-zero values are interpreted as ', 'True', ' in condition.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/control_flow_op.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.op.zeros_like(data=None, out=None, name=None, **kwargs)Â¶","['Return an array of zeros with the same shape, type and storage type\nas the input array.', '\n', 'The storage type of ', 'zeros_like', ' output depends on the storage type of the input', '\n', '\n', 'zeros_like(row_sparse) = row_sparse', '\n', 'zeros_like(csr) = csr', '\n', 'zeros_like(default) = default', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.uniform(low=0, high=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw random samples from a uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An NDArray of type ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.normal(loc=0, scale=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', 'Samples are distributed according to a normal distribution parametrized\nby ', 'loc', ' (mean) and ', 'scale', ' (standard deviation).', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An NDArray of type ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.randn(*shape, **kwargs)[source]Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', 'Samples are distributed according to a normal distribution parametrized\nby ', 'loc', ' (mean) and ', 'scale', ' (standard deviation).', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.poisson(lam=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw random samples from a Poisson distribution.', '\n', 'Samples are distributed according to a Poisson distribution parametrized\nby ', 'lambda', ' (rate). Samples will always be returned as a floating point data type.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.exponential(scale=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw samples from an exponential distribution.', '\n', 'Its probability density function is', '\n', '\n\\[f(x; \\frac{1}{\\beta}) = \\frac{1}{\\beta} \\exp(-\\frac{x}{\\beta}),\\]', '\n', 'for x > 0 and 0 elsewhere. beta is the scale parameter, which is the\ninverse of the rate parameter lambda = 1/beta.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.gamma(alpha=1, beta=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw random samples from a gamma distribution.', '\n', 'Samples are distributed according to a gamma distribution parametrized\nby ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.multinomial(data, shape=_Null, get_prob=False, out=None, dtype='int32', **kwargs)[source]Â¶","['Concurrent sampling from multiple multinomial distributions.', '\n', '\n', 'Note', '\n', 'The input distribution must be normalized, i.e. ', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'For input ', '\n', 'Return type', '\n', 'List, or ', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.negative_binomial(k=1, p=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw random samples from a negative binomial distribution.', '\n', 'Samples are distributed according to a negative binomial distribution\nparametrized by ', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure\nprobability in each experiment). Samples will always be returned as a\nfloating point data type.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.generalized_negative_binomial(mu=1, alpha=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw random samples from a generalized negative binomial distribution.', '\n', 'Samples are distributed according to a generalized negative binomial\ndistribution parametrized by ', 'mu', ' (mean) and ', 'alpha', ' (dispersion).\n', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.shuffle(data, **kwargs)[source]Â¶","['Shuffle the elements randomly.', '\n', 'This shuffles the array along the first axis.\nThe order of the elements in each subarray does not change.\nFor example, if a 2D array is given, the order of the rows randomly changes,\nbut the order of the elements in each row does not change.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A new NDArray with the same shape and type as input ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.randint(low, high, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)[source]Â¶","['Draw random samples from a discrete uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An NDArray of type ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.exponential_like(data=None, lam=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from an exponential distribution according to the input array shape.', '\n', 'Samples are distributed according to an exponential distribution parametrized by ', 'lambda', ' (rate).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.gamma_like(data=None, alpha=_Null, beta=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a gamma distribution according to the input array shape.', '\n', 'Samples are distributed according to a gamma distribution parametrized by ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L231', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.generalized_negative_binomial_like(data=None, mu=_Null, alpha=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a generalized negative binomial distribution according to the\ninput array shape.', '\n', 'Samples are distributed according to a generalized negative binomial distribution parametrized by\n', 'mu', ' (mean) and ', 'alpha', ' (dispersion). ', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.negative_binomial_like(data=None, k=_Null, p=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a negative binomial distribution according to the input array shape.', '\n', 'Samples are distributed according to a negative binomial distribution parametrized by\n', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure probability in each experiment).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L267', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.normal_like(data=None, loc=_Null, scale=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution according to the input array shape.', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L220', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.poisson_like(data=None, lam=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a Poisson distribution according to the input array shape.', '\n', 'Samples are distributed according to a Poisson distribution parametrized by ', 'lambda', ' (rate).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L254', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.random.uniform_like(data=None, low=_Null, high=_Null, out=None, name=None, **kwargs)Â¶","['Draw random samples from a uniform distribution according to the input array shape.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L208', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.csr_matrix(arg1, shape=None, ctx=None, dtype=None)[source]Â¶","['Creates a ', 'CSRNDArray', ', an 2D array with compressed sparse row (CSR) format.', '\n', 'The CSRNDArray can be instantiated in several ways:', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A ', '\n', 'Return type', '\n', 'CSRNDArray', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'See also', '\n', '\n', '\n', '\n', '\n']",">>> a=mx.nd.sparse.csr_matrix(([1,2,3],[1,0,2],[0,1,2,2,3]),shape=(4,3))
>>> a.asnumpy()
array([[ 0.,  1.,  0.],
       [ 2.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  3.]], dtype=float32)
",,
"
mxnet.ndarray.sparse.row_sparse_array(arg1, shape=None, ctx=None, dtype=None)[source]Â¶","['Creates a ', 'RowSparseNDArray', ', a multidimensional row sparse array with a set of     tensor slices at given indices.', '\n', 'The RowSparseNDArray can be instantiated in several ways:', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'RowSparseNDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', 'See also', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.ndarray.sparse.BaseSparseNDArray(handle, writable=True)[source]Â¶","['Bases: ', 'mxnet.ndarray.ndarray.NDArray', '\n', 'The base class of an NDArray stored in a sparse storage format.', '\n', 'See CSRNDArray and RowSparseNDArray for more details.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Return a dense ', '\n', '\n', '\n', '\n', 'Return a copy of the array after casting to a specified type.', '\n', '\n', '\n', '\n', 'Check whether the NDArray format is valid.', '\n', '\n', '\n', '\n', 'Copies the value of this array to another array.', '\n', '\n', '\n', '\n', 'Returns a ', '\n', '\n', '\n', '\n', 'Number of elements in the array.', '\n', '\n']",,,
"
class mxnet.ndarray.sparse.CSRNDArray(handle, writable=True)[source]Â¶","['Bases: ', 'mxnet.ndarray.sparse.BaseSparseNDArray', '\n', 'A sparse representation of 2D NDArray in the Compressed Sparse Row format.', '\n', 'A CSRNDArray represents an NDArray as three separate arrays: ', 'data', ',\n', 'indptr', ' and ', 'indices', '. It uses the CSR representation where the column indices for\nrow i are stored in ', 'indices[indptr[i]:indptr[i+1]]', ' and their corresponding values are stored\nin ', 'data[indptr[i]:indptr[i+1]]', '.', '\n', 'The column indices for a given row are expected to be sorted in ascending order.\nDuplicate column entries for the same row are not allowed.', '\n', 'Example', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', None, '\n', '\n', '\n', 'See also', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Returns a ', '\n', '\n', '\n', '\n', 'Copies the value of this array to another array.', '\n', '\n', '\n', '\n', 'A deep copy NDArray of the data array of the CSRNDArray.\nThis generates a deep copy of the ', '\n', '\n', '\n', '\n', 'A deep copy NDArray of the indices array of the CSRNDArray.\nThis generates a deep copy of the column indices of the current ', '\n', '\n', '\n', '\n', 'A deep copy NDArray of the indptr array of the CSRNDArray.\nThis generates a deep copy of the ', '\n', '\n', '\n', '\n', 'Return a copy of the array with chosen storage type.', '\n', '\n']",">>> a=mx.nd.array([[0,1,0],[2,0,0],[0,0,0],[0,0,3]])
>>> a=a.tostype('csr')
>>> a.data.asnumpy()
array([ 1.,  2.,  3.], dtype=float32)
>>> a.indices.asnumpy()
array([1, 0, 2])
>>> a.indptr.asnumpy()
array([0, 1, 2, 2, 3])
",,
"
class mxnet.ndarray.sparse.RowSparseNDArray(handle, writable=True)[source]Â¶","['Bases: ', 'mxnet.ndarray.sparse.BaseSparseNDArray', '\n', 'A sparse representation of a set of NDArray row slices at given indices.', '\n', 'A RowSparseNDArray represents a multidimensional NDArray using two separate arrays: ', 'data', ' and\n', 'indices', '. The number of dimensions has to be at least 2.', '\n', '\n', 'data: an NDArray of any dtype with shape [D0, D1, â\x80¦, Dn].', '\n', 'indices: a 1-D int64 NDArray with shape [D0] with values sorted in ascending order.', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'The ', 'indices', ' stores the indices of the row slices with non-zeros,\nwhile the values are stored in ', 'data', '. The corresponding NDArray ', 'dense', '\nrepresented by RowSparseNDArray ', 'rsp', ' has', '\n', 'dense[rsp.indices[i],', '\n', None, '\n', '\n', 'A RowSparseNDArray is typically used to represent non-zero row slices of a large NDArray\nof shape [LARGE0, D1, .. , Dn] where LARGE0 >> D0 and most row slices are zeros.', '\n', 'RowSparseNDArray is used principally in the definition of gradients for operations\nthat have sparse gradients (e.g. sparse dot and sparse embedding).', '\n', '\n', 'See also', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Copies the value of this array to another array.', '\n', '\n', '\n', '\n', 'A deep copy NDArray of the data array of the RowSparseNDArray.\nThis generates a deep copy of the ', '\n', '\n', '\n', '\n', 'A deep copy NDArray of the indices array of the RowSparseNDArray.\nThis generates a deep copy of the row indices of the current ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Return a copy of the array with chosen storage type.', '\n', '\n']",,,
"
mxnet.ndarray.sparse.add(lhs, rhs)[source]Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ', ', 'mx.nd.broadcast_add(lhs,', ' and\n', 'mx.nd.broadcast_plus(lhs,', ' when shapes of lhs and rhs do not\nmatch. If lhs.shape == rhs.shape, this is equivalent to\n', 'mx.nd.elemwise_add(lhs,', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.abs', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise sum of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.subtract(lhs, rhs)[source]Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ', ', 'mx.nd.broadcast_sub(lhs,', ' and\n', 'mx.nd.broadcast_minus(lhs,', ' when shapes of lhs and rhs do not\nmatch. If lhs.shape == rhs.shape, this is equivalent to\n', 'mx.nd.elemwise_sub(lhs,', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise difference of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.multiply(lhs, rhs)[source]Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', '\n', 'Equivalent to ', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise multiplication of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.divide(lhs, rhs)[source]Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Equivalent to ', 'lhs', ' and ', 'mx.nd.broadcast_div(lhs,', '\nwhen shapes of lhs and rhs do not match. If lhs.shape == rhs.shape,\nthis is equivalent to ', 'mx.nd.elemwise_div(lhs,', '\n', '\n', 'Note', '\n', 'If the corresponding dimensions of two arrays have the same size or one of them has size 1,\nthen the arrays are broadcastable to a common shape.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise division of the input arrays.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.ElementWiseSum(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.Embedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, out=None, name=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'When â\x80\x9csparse_gradâ\x80\x9d is False, if any index mentioned is too large, it is replaced by the index that\naddresses the last vector in an embedding matrix.\nWhen â\x80\x9csparse_gradâ\x80\x9d is True, an error will be raised if invalid indices are found.', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of weight can be either row_sparse or default.', '\n', '\n', 'Note', '\n', 'If â\x80\x9csparse_gradâ\x80\x9d is set to True, the storage type of gradient w.r.t weights will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L597', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.FullyConnected(data=None, weight=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out=None, name=None, **kwargs)Â¶","['Applies a linear transformation: ', '\\(Y = XW^T + b\\)', '.', '\n', 'If ', 'flatten', ' is set to be true, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'If ', 'flatten', ' is set to be false, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'The learnable parameters include both ', 'weight', ' and ', 'bias', '.', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', '\n', 'Note', '\n', 'The sparse support for FullyConnected is limited to forward evaluation with ', '\n', 'To compute linear transformation with â\x80\x98csrâ\x80\x99 sparse data, sparse.dot is recommended instead\nof sparse.FullyConnected.', '\n', '\n', 'Defined in src/operator/nn/fully_connected.cc:L286', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.LinearRegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Computes and optimizes for squared loss during backward propagation.\nJust outputs ', 'data', ' during forward propagation.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the squared loss estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{SquaredLoss}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert  \\textbf{y}_i - \\hat{\\textbf{y}}_i  \\rVert_2\\)', '\n', '\n', 'Note', '\n', 'Use the LinearRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LinearRegressionOutput(default, default) = default', '\n', 'LinearRegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.LogisticRegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Applies a logistic function to the input.', '\n', 'The logistic function, also known as the sigmoid function, is computed as\n', '\\(\\frac{1}{1+exp(-\\textbf{x})}\\)', '.', '\n', 'Commonly, the sigmoid is used to squash the real-valued output of a linear model\n', '\\(wTx+b\\)', ' into the [0,1] range so that it can be interpreted as a probability.\nIt is suitable for binary classification or probability prediction tasks.', '\n', '\n', 'Note', '\n', 'Use the LogisticRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LogisticRegressionOutput(default, default) = default', '\n', 'LogisticRegressionOutput(default, csr) = default', '\n', '\n', 'The loss function used is the Binary Cross Entropy Loss:', '\n', '\\(-{(y\\log(p) + (1 - y)\\log(1 - p))}\\)', '\n', 'Where ', 'y', ' is the ground truth probability of positive outcome for a given example, and ', 'p', ' the probability predicted by the model. By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L152', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.MAERegressionOutput(data=None, label=None, grad_scale=_Null, out=None, name=None, **kwargs)Â¶","['Computes mean absolute error of the input.', '\n', 'MAE is a risk metric corresponding to the expected value of the absolute error.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the mean absolute error (MAE) estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{MAE}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert \\textbf{y}_i - \\hat{\\textbf{y}}_i \\rVert_1\\)', '\n', '\n', 'Note', '\n', 'Use the MAERegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'MAERegressionOutput(default, default) = default', '\n', 'MAERegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L120', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.abs(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise absolute value of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'abs', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L720', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.adagrad_update(weight=None, grad=None, history=None, lr=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for AdaGrad optimizer.', '\n', 'Referenced from ', 'Adaptive Subgradient Methods for Online Learning and Stochastic Optimization', ',\nand available at ', 'http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf', '.', '\n', 'Updates are applied by:', '\n', None, '\n', '\n', 'Note that non-zero values for the weight decay option are not supported.', '\n', 'Defined in src/operator/optimizer_op.cc:L908', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.adam_update(weight=None, grad=None, mean=None, var=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Adam optimizer. Adam is seen as a generalization\nof AdaGrad.', '\n', 'Adam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nW_t = W_{t-1} - \\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon }\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and the storage\ntype of weight is the same as those of m and v,\nonly the row slices whose indices appear in grad.indices are updated (for w, m and v):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L687', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.add_n(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.arccos(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse cosine of the input array.', '\n', 'The input should be in range ', '[-1, 1]', '.\nThe output is in the closed interval ', '\\([0, \\pi]\\)', '\n', '\n\\[arccos([-1, -.707, 0, .707, 1]) = [\\pi, 3\\pi/4, \\pi/2, \\pi/4, 0]\\]', '\n', 'The storage type of ', 'arccos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.arccosh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arccosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L535', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.arcsin(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse sine of the input array.', '\n', 'The input should be in the range ', '[-1, 1]', '.\nThe output is in the closed interval of [', '\\(-\\pi/2\\)', ', ', '\\(\\pi/2\\)', '].', '\n', '\n\\[arcsin([-1, -.707, 0, .707, 1]) = [-\\pi/2, -\\pi/4, 0, \\pi/4, \\pi/2]\\]', '\n', 'The storage type of ', 'arcsin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.arcsinh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arcsinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.arctan(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse tangent of the input array.', '\n', 'The output is in the closed interval ', '\\([-\\pi/2, \\pi/2]\\)', '\n', '\n\\[arctan([-1, 0, 1]) = [-\\pi/4, 0, \\pi/4]\\]', '\n', 'The storage type of ', 'arctan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L282', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.arctanh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.', '\n', 'The storage type of ', 'arctanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L579', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.broadcast_add(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.broadcast_div(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_div(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.broadcast_minus(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.broadcast_mul(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_mul(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L145', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.broadcast_plus(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.broadcast_sub(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.cast_storage(data=None, stype=_Null, out=None, name=None, **kwargs)Â¶","['Casts tensor storage type to the new type.', '\n', 'When an NDArray with default storage type is cast to csr or row_sparse storage,\nthe result is compact, which means:', '\n', '\n', 'for csr, zero values will not be retained', '\n', 'for row_sparse, row slices of all zeros will not be retained', '\n', '\n', 'The storage type of ', 'cast_storage', ' output depends on stype parameter:', '\n', '\n', 'cast_storage(csr, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(row_sparse, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(default, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(default, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', 'cast_storage(csr, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(row_sparse, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/cast_storage.cc:L71', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.cbrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise cube-root value of the input.', '\n', '\n\\[cbrt(x) = \\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'cbrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L270', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.ceil(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise ceiling of the input.', '\n', 'The ceil of the scalar x is the smallest integer i, such that i >= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'ceil', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L817', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.clip(data=None, a_min=_Null, a_max=_Null, out=None, name=None, **kwargs)Â¶","['Clips (limits) the values in an array.\nGiven an interval, values outside the interval are clipped to the interval edges.\nClipping ', 'x', ' between ', 'a_min', ' and ', 'a_max', ' would be::\n.. math:', '\n', None, '\n', '\n', '\n', 'Example::', 'x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nclip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]', '\n', '\n', 'The storage type of ', 'clip', ' output depends on storage types of inputs and the a_min, a_max parameter values:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L676', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.cos(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise cosine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[cos([0, \\pi/4, \\pi/2]) = [1, 0.707, 0]\\]', '\n', 'The storage type of ', 'cos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.cosh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic cosine  of the input array, computed element-wise.', '\n', '\n\\[cosh(x) = 0.5\\times(exp(x) + exp(-x))\\]', '\n', 'The storage type of ', 'cosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L409', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.degrees(data=None, out=None, name=None, **kwargs)Â¶","['Converts each element of the input array from radians to degrees.', '\n', '\n\\[degrees([0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]) = [0, 90, 180, 270, 360]\\]', '\n', 'The storage type of ', 'degrees', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, out=None, name=None, **kwargs)Â¶","['Dot product of two arrays.', '\n', 'dot', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: inner product of vectors', '\n', '2-D arrays: matrix multiplication', '\n', 'N-D arrays: a sum product over the last axis of the first input and the first\naxis of the second input', '\n', '\n', 'The storage type of ', 'dot', ' output depends on storage types of inputs, transpose option and\nforward_stype option for output storage type. Implemented sparse operations include:', '\n', '\n', 'dot(default, default, transpose_a=True/False, transpose_b=True/False) = default', '\n', 'dot(csr, default, transpose_a=True) = default', '\n', 'dot(csr, default, transpose_a=True) = row_sparse', '\n', 'dot(csr, default) = default', '\n', 'dot(csr, row_sparse) = default', '\n', 'dot(default, csr) = csr (CPU only)', '\n', 'dot(default, csr, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', 'dot(default, csr, transpose_b=True, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', '\n', 'If the combination of input storage types and forward_stype does not match any of the\nabove patterns, ', 'dot', ' will fallback and generate output with default storage.', '\n', '\n', 'Note', '\n', 'If the storage type of the lhs is â\x80\x9ccsrâ\x80\x9d, the storage type of gradient w.r.t rhs will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.elemwise_add(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Adds arguments element-wise.', '\n', 'The storage type of ', 'elemwise_add', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.elemwise_div(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Divides arguments element-wise.', '\n', 'The storage type of ', 'elemwise_div', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.elemwise_mul(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Multiplies arguments element-wise.', '\n', 'The storage type of ', 'elemwise_mul', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.elemwise_sub(lhs=None, rhs=None, out=None, name=None, **kwargs)Â¶","['Subtracts arguments element-wise.', '\n', 'The storage type of ', 'elemwise_sub', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.exp(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise exponential value of the input.', '\n', '\n\\[exp(x) = e^x \\approx 2.718^x\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'exp', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L64', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.expm1(data=None, out=None, name=None, **kwargs)Â¶","['Returns ', 'exp(x)', ' computed element-wise on the input.', '\n', 'This function provides greater precision than ', 'exp(x)', ' for small values of ', 'x', '.', '\n', 'The storage type of ', 'expm1', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.fix(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer towards zero of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'fix', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L874', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.floor(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise floor of the input.', '\n', 'The floor of the scalar x is the largest integer i, such that i <= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'floor', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L836', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.ftrl_update(weight=None, grad=None, z=None, n=None, lr=_Null, lamda1=_Null, beta=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Ftrl optimizer.\nReferenced from ', 'Ad Click Prediction: a View from the Trenches', ', available at\n', 'http://dl.acm.org/citation.cfm?id=2488200', '.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'If w, z and n are all of ', 'row_sparse', ' storage type,\nonly the row slices whose indices appear in grad.indices are updated (for w, z and n):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L875', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.gamma(data=None, out=None, name=None, **kwargs)Â¶","['Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.', '\n', 'The storage type of ', 'gamma', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.gammaln(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise log of the absolute value of the gamma function of the input.', '\n', 'The storage type of ', 'gammaln', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.log(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Natural logarithmic value of the input.', '\n', 'The natural logarithm is logarithm in base ', 'e', ', so that ', 'log(exp(x))', '\n', 'The storage type of ', 'log', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.log10(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Base-10 logarithmic value of the input.', '\n', '10**log10(x)', '\n', 'The storage type of ', 'log10', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.log1p(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise ', 'log(1', ' value of the input.', '\n', 'This function is more accurate than ', 'log(1', '  for small ', 'x', ' so that\n', '\\(1+x\\approx 1\\)', '\n', 'The storage type of ', 'log1p', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.log2(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise Base-2 logarithmic value of the input.', '\n', '2**log2(x)', '\n', 'The storage type of ', 'log2', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.make_loss(data=None, out=None, name=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'make_loss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'The storage type of ', 'make_loss', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L358', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.mean(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the mean of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.negative(data=None, out=None, name=None, **kwargs)Â¶","['Numerical negative of the argument, element-wise.', '\n', 'The storage type of ', 'negative', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.norm(data=None, ord=_Null, axis=_Null, out_dtype=_Null, keepdims=_Null, out=None, name=None, **kwargs)Â¶","['Computes the norm on an NDArray.', '\n', 'This operator computes the norm on an NDArray with the specified axis, depending\non the value of the ord parameter. By default, it computes the L2 norm on the entire\narray. Currently only ord=2 supports sparse ndarrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_norm_value.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.radians(data=None, out=None, name=None, **kwargs)Â¶","['Converts each element of the input array from degrees to radians.', '\n', '\n\\[radians([0, 90, 180, 270, 360]) = [0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]\\]', '\n', 'The storage type of ', 'radians', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L351', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.relu(data=None, out=None, name=None, **kwargs)Â¶","['Computes rectified linear activation.', '\n', '\n\\[max(features, 0)\\]', '\n', 'The storage type of ', 'relu', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.retain(data=None, indices=None, out=None, name=None, **kwargs)Â¶","['Pick rows specified by user input index array from a row sparse matrix\nand save them in the output sparse matrix.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'retain', ' output depends on storage types of inputs', '\n', '\n', 'retain(row_sparse, default) = row_sparse', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/sparse_retain.cc:L53', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.rint(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rint', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L798', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.round(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'round', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L777', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.rsqrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise inverse square-root value of the input.', '\n', '\n\\[rsqrt(x) = 1/\\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rsqrt', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sgd_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and weightâ\x80\x99s storage\ntype is the same as momentumâ\x80\x99s storage type,\nonly the row slices whose indices appear in grad.indices are updated (for both weight and momentum):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L564', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradient is of ', 'row_sparse', ' storage type and ', 'lazy_update', ' is True,\nonly the row slices whose indices appear in grad.indices are updated:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L523', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sigmoid(data=None, out=None, name=None, **kwargs)Â¶","['Computes sigmoid of x element-wise.', '\n', '\n\\[y = 1 / (1 + exp(-x))\\]', '\n', 'The storage type of ', 'sigmoid', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sign(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise sign of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sign', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L758', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sin(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise sine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[sin([0, \\pi/4, \\pi/2]) = [0, 0.707, 1]\\]', '\n', 'The storage type of ', 'sin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L47', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sinh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic sine of the input array, computed element-wise.', '\n', '\n\\[sinh(x) = 0.5\\times(exp(x) - exp(-x))\\]', '\n', 'The storage type of ', 'sinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L371', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.slice(data=None, begin=_Null, end=_Null, step=_Null, out=None, name=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sqrt(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise square-root value of the input.', '\n', '\n\\[\\textrm{sqrt}(x) = \\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sqrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L170', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.square(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise squared value of the input.', '\n', '\n\\[square(x) = x^2\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'square', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.stop_gradient(data=None, out=None, name=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.sum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.tan(data=None, out=None, name=None, **kwargs)Â¶","['Computes the element-wise tangent of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[tan([0, \\pi/4, \\pi/2]) = [0, 1, -inf]\\]', '\n', 'The storage type of ', 'tan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L140', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.tanh(data=None, out=None, name=None, **kwargs)Â¶","['Returns the hyperbolic tangent of the input array, computed element-wise.', '\n', '\n\\[tanh(x) = sinh(x) / cosh(x)\\]', '\n', 'The storage type of ', 'tanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L451', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.trunc(data=None, out=None, name=None, **kwargs)Â¶","['Return the element-wise truncated value of the input.', '\n', 'The truncated value of the scalar x is the nearest integer i which is closer to\nzero than x is. In short, the fractional part of the signed number x is discarded.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'trunc', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L856', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.where(condition=None, x=None, y=None, out=None, name=None, **kwargs)Â¶","['Return the elements, either from x or y, depending on the condition.', '\n', 'Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,\ndepending on the elements from condition are true or false. x and y must have the same shape.\nIf condition has the same shape as x, each element in the output array is from x if the\ncorresponding element in the condition is true, and from y if false.', '\n', 'If condition does not have the same shape as x, it must be a 1D array whose size is\nthe same as xâ\x80\x99s first dimension size. Each row of the output array is from xâ\x80\x99s row\nif the corresponding element from condition is true, and from yâ\x80\x99s row if false.', '\n', 'Note that all non-zero values are interpreted as ', 'True', ' in condition.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/control_flow_op.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.sparse.zeros_like(data=None, out=None, name=None, **kwargs)Â¶","['Return an array of zeros with the same shape, type and storage type\nas the input array.', '\n', 'The storage type of ', 'zeros_like', ' output depends on the storage type of the input', '\n', '\n', 'zeros_like(row_sparse) = row_sparse', '\n', 'zeros_like(csr) = csr', '\n', 'zeros_like(default) = default', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.utils.zeros(shape, ctx=None, dtype=None, stype=None, **kwargs)[source]Â¶","['Return a new array of given shape and type, filled with zeros.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.utils.empty(shape, ctx=None, dtype=None, stype=None)[source]Â¶","['Returns a new array of given shape and type, without initializing entries.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A created array.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.utils.array(source_array, ctx=None, dtype=None)[source]Â¶","['Creates an array from any object exposing the array interface.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An array with the same contents as the ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.ndarray.utils.load(fname)[source]Â¶","['Loads an array from file.', '\n', 'See more details in ', 'save', '.', '\n', '\n', 'Parameters', '\n', 'fname', '\n', 'Returns', '\n', 'Loaded data.', '\n', 'Return type', '\n', 'list of NDArray, ', '\n', '\n', '\n']",,,
"
mxnet.ndarray.utils.load_frombuffer(buf)[source]Â¶","['Loads an array dictionary or list from a buffer', '\n', 'See more details in ', 'save', '.', '\n', '\n', 'Parameters', '\n', 'buf', '\n', 'Returns', '\n', 'Loaded data.', '\n', 'Return type', '\n', 'list of NDArray, ', '\n', '\n', '\n']",,,
"
mxnet.ndarray.utils.save(fname, data)[source]Â¶","['Saves a list of arrays or a dict of str->array to file.', '\n', 'Examples of filenames:', '\n', '\n', '/path/to/file', '\n', 's3://my-bucket/path/to/file', '\n', 'hdfs://path/to/file', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
class mxnet.gluon.Block(prefix=None, params=None)[source]Â¶","['Bases: ', 'object', '\n', 'Base class for all neural network layers and models. Your models should\nsubclass this class.', '\n', 'Block', ' can be nested recursively in a tree structure. You can create and\nassign child ', 'Block', ' as regular attributes:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Child ', 'Block', ' assigned this way will be registered and ', 'collect_params()', '\nwill collect their Parameters recursively. You can also manually register\nchild blocks with ', 'register_child()', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Applies ', '\n', '\n', '\n', '\n', 'Cast this Block to use another data type.', '\n', '\n', '\n', '\n', 'Returns a ', '\n', '\n', '\n', '\n', 'Overrides to implement forward computation using ', '\n', '\n', '\n', '\n', 'Please refer description of HybridBlock hybridize().', '\n', '\n', '\n', '\n', 'Initializes ', '\n', '\n', '\n', '\n', 'Load a model saved using the ', '\n', '\n', '\n', '\n', 'Load parameters from file previously saved by ', '\n', '\n', '\n', '\n', '[Deprecated] Please use load_parameters.', '\n', '\n', '\n', '\n', 'Name of this ', '\n', '\n', '\n', '\n', 'Returns a name space object managing a child ', '\n', '\n', '\n', '\n', 'Returns this ', '\n', '\n', '\n', '\n', 'Prefix of this ', '\n', '\n', '\n', '\n', 'Registers block as a child of self. ', '\n', '\n', '\n', '\n', 'Registers a forward hook on the block.', '\n', '\n', '\n', '\n', 'Registers a forward pre-hook on the block.', '\n', '\n', '\n', '\n', 'Install callback monitor.', '\n', '\n', '\n', '\n', 'Save the model architecture and parameters to load again later', '\n', '\n', '\n', '\n', 'Save parameters to file.', '\n', '\n', '\n', '\n', '[Deprecated] Please use save_parameters. Note that if you want load\nfrom SymbolBlock later, please use export instead.', '\n', '\n', '\n', '\n', 'Print the summary of the modelâ\x80\x99s output and parameters.', '\n', '\n']",,,
"
class mxnet.gluon.HybridBlock(prefix=None, params=None)[source]Â¶","['Bases: ', 'mxnet.gluon.block.Block', '\n', 'HybridBlock', ' supports forwarding with both Symbol and NDArray.', '\n', 'HybridBlock', ' is similar to ', 'Block', ', with a few differences:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Forward computation in ', 'HybridBlock', ' must be static to work with ', 'Symbol', ' s,\ni.e. you cannot call ', 'NDArray.asnumpy()', ', ', 'NDArray.shape', ',\n', 'NDArray.dtype', ', ', 'NDArray', ' indexing (', 'x[i]', ') etc on tensors.\nAlso, you cannot use branching or loop logic that bases on non-constant\nexpressions like random numbers or intermediate results, since they change\nthe graph structure for each iteration.', '\n', 'Before activating with ', 'hybridize()', ', ', 'HybridBlock', ' works just like normal\n', 'Block', '. After activation, ', 'HybridBlock', ' will create a symbolic graph\nrepresenting the forward computation and cache it. On subsequent forwards,\nthe cached graph will be used instead of ', 'hybrid_forward()', '.', '\n', 'Please see references for detailed tutorial.', '\n', 'References', '\n', 'Hybrid - Faster training and easy deployment', '\n', '\n', '\n', '\n', 'Applies ', '\n', '\n', '\n', '\n', 'Cast this Block to use another data type.', '\n', '\n', '\n', '\n', 'Returns a ', '\n', '\n', '\n', '\n', 'Export HybridBlock to json format that can be loaded by\n', '\n', '\n', '\n', '\n', 'Defines the forward computation. Arguments can be either\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n', '\n', '\n', 'Activates or deactivates ', '\n', '\n', '\n', '\n', 'Infers shape of Parameters from inputs.', '\n', '\n', '\n', '\n', 'Infers data type of Parameters from inputs.', '\n', '\n', '\n', '\n', 'Initializes ', '\n', '\n', '\n', '\n', 'Load a model saved using the ', '\n', '\n', '\n', '\n', 'Load parameters from file previously saved by ', '\n', '\n', '\n', '\n', '[Deprecated] Please use load_parameters.', '\n', '\n', '\n', '\n', 'Name of this ', '\n', '\n', '\n', '\n', 'Returns a name space object managing a child ', '\n', '\n', '\n', '\n', 'Partitions the current HybridBlock and optimizes it for a given backend\nwithout executing a forward pass. Modifies the HybridBlock in-place.', '\n', '\n', '\n', '\n', 'Returns this ', '\n', '\n', '\n', '\n', 'Prefix of this ', '\n', '\n', '\n', '\n', 'Registers block as a child of self. ', '\n', '\n', '\n', '\n', 'Registers a forward hook on the block.', '\n', '\n', '\n', '\n', 'Registers a forward pre-hook on the block.', '\n', '\n', '\n', '\n', 'Install op hook for block recursively.', '\n', '\n', '\n', '\n', 'Save the model architecture and parameters to load again later', '\n', '\n', '\n', '\n', 'Save parameters to file.', '\n', '\n', '\n', '\n', '[Deprecated] Please use save_parameters. Note that if you want load\nfrom SymbolBlock later, please use export instead.', '\n', '\n', '\n', '\n', 'Print the summary of the modelâ\x80\x99s output and parameters.', '\n', '\n']",,,
"
class mxnet.gluon.SymbolBlock(outputs, inputs, params=None)[source]Â¶","['Bases: ', 'mxnet.gluon.block.HybridBlock', '\n', 'Construct block from symbol. This is useful for using pre-trained models\nas feature extractors. For example, you may want to extract the output\nfrom fc2 layer in AlexNet.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Applies ', '\n', '\n', '\n', '\n', 'Cast this Block to use another data type.', '\n', '\n', '\n', '\n', 'Returns a ', '\n', '\n', '\n', '\n', 'Export HybridBlock to json format that can be loaded by\n', '\n', '\n', '\n', '\n', 'Defines the forward computation. Arguments can be either\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n', '\n', '\n', 'Activates or deactivates ', '\n', '\n', '\n', '\n', 'Import model previously saved by ', '\n', '\n', '\n', '\n', 'Infers shape of Parameters from inputs.', '\n', '\n', '\n', '\n', 'Infers data type of Parameters from inputs.', '\n', '\n', '\n', '\n', 'Initializes ', '\n', '\n', '\n', '\n', 'Load a model saved using the ', '\n', '\n', '\n', '\n', 'Load parameters from file previously saved by ', '\n', '\n', '\n', '\n', '[Deprecated] Please use load_parameters.', '\n', '\n', '\n', '\n', 'Name of this ', '\n', '\n', '\n', '\n', 'Returns a name space object managing a child ', '\n', '\n', '\n', '\n', 'Partitions the current HybridBlock and optimizes it for a given backend\nwithout executing a forward pass. Modifies the HybridBlock in-place.', '\n', '\n', '\n', '\n', 'Returns this ', '\n', '\n', '\n', '\n', 'Prefix of this ', '\n', '\n', '\n', '\n', 'Registers block as a child of self. ', '\n', '\n', '\n', '\n', 'Registers a forward hook on the block.', '\n', '\n', '\n', '\n', 'Registers a forward pre-hook on the block.', '\n', '\n', '\n', '\n', 'Install op hook for block recursively.', '\n', '\n', '\n', '\n', 'Re-assign all Parameters to other contexts. If the Block is hybridized, it will reset the _cached_op_args.\n:param ctx: Assign Parameter to given context. If ctx is a list of Context, a', '\n', '\n', '\n', '\n', 'Save the model architecture and parameters to load again later', '\n', '\n', '\n', '\n', 'Save parameters to file.', '\n', '\n', '\n', '\n', '[Deprecated] Please use save_parameters. Note that if you want load\nfrom SymbolBlock later, please use export instead.', '\n', '\n', '\n', '\n', 'Print the summary of the modelâ\x80\x99s output and parameters.', '\n', '\n']",,,
"
class mxnet.gluon.Constant(name, value)[source]Â¶","['Bases: ', 'mxnet.gluon.parameter.Parameter', '\n', 'A constant parameter for holding immutable tensors.\n', 'Constant`s are ignored by `autograd', ' and ', 'Trainer', ', thus their values\nwill not change during training. But you can still update their values\nmanually with the ', 'set_data', ' method.', '\n', 'Constant', ' s can be created with either:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'or:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Cast data and gradient of this Parameter to a new data type.', '\n', '\n', '\n', '\n', 'Returns a copy of this parameter on one context. Must have been\ninitialized on this context before. For sparse parameters, use\n', '\n', '\n', '\n', '\n', 'The type of the parameter.', '\n', '\n', '\n', '\n', 'Returns a gradient buffer for this parameter on one context.', '\n', '\n', '\n', '\n', 'Initializes parameter and gradient arrays. Only used for ', '\n', '\n', '\n', '\n', 'Returns a list of contexts this parameter is initialized on.', '\n', '\n', '\n', '\n', 'Returns copies of this parameter on all contexts, in the same order\nas creation. For sparse parameters, use ', '\n', '\n', '\n', '\n', 'Returns gradient buffers on all contexts, in the same order\nas ', '\n', '\n', '\n', '\n', 'Returns copies of the â\x80\x98row_sparseâ\x80\x99 parameter on all contexts, in the same order\nas creation. The copy only retains rows whose ids occur in provided row ids.\nThe parameter must have been initialized before.', '\n', '\n', '\n', '\n', 'Re-assign Parameter to other contexts.', '\n', '\n', '\n', '\n', 'Returns a copy of the â\x80\x98row_sparseâ\x80\x99 parameter on the same context as row_idâ\x80\x99s.\nThe copy only retains rows whose ids occur in provided row ids.\nThe parameter must have been initialized on this context before.', '\n', '\n', '\n', '\n', 'Sets this parameterâ\x80\x99s value on all contexts.', '\n', '\n', '\n', '\n', 'The shape of the parameter.', '\n', '\n', '\n', '\n', 'Returns a symbol representing this parameter.', '\n', '\n', '\n', '\n', 'Sets gradient buffer on all contexts to 0. No action is taken if\nparameter is uninitialized or doesnâ\x80\x99t require gradient.', '\n', '\n']",,,
"
class mxnet.gluon.Parameter(name, grad_req='write', shape=None, dtype=<class 'numpy.float32'>, lr_mult=1.0, wd_mult=1.0, init=None, allow_deferred_init=False, differentiable=True, stype='default', grad_stype='default')[source]Â¶","['Bases: ', 'object', '\n', 'A Container holding parameters (weights) of Blocks.', '\n', 'Parameter', ' holds a copy of the parameter on each ', 'Context', ' after\nit is initialized with ', 'Parameter.initialize(...)', '. If ', 'grad_req', ' is\nnot ', ""'null'"", ', it will also hold a gradient array on each ', 'Context', ':', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'This can be set before or after initialization. Setting ', '\n', '\n', '\n', '\n', 'Local learning rate multiplier for this Parameter. The actual learning rate\nis calculated with ', '\n', '\n', '\n', '\n', 'Local weight decay multiplier for this Parameter.', '\n', '\n', '\n', '\n', 'Cast data and gradient of this Parameter to a new data type.', '\n', '\n', '\n', '\n', 'Returns a copy of this parameter on one context. Must have been\ninitialized on this context before. For sparse parameters, use\n', '\n', '\n', '\n', '\n', 'The type of the parameter.', '\n', '\n', '\n', '\n', 'Returns a gradient buffer for this parameter on one context.', '\n', '\n', '\n', '\n', 'Initializes parameter and gradient arrays. Only used for ', '\n', '\n', '\n', '\n', 'Returns a list of contexts this parameter is initialized on.', '\n', '\n', '\n', '\n', 'Returns copies of this parameter on all contexts, in the same order\nas creation. For sparse parameters, use ', '\n', '\n', '\n', '\n', 'Returns gradient buffers on all contexts, in the same order\nas ', '\n', '\n', '\n', '\n', 'Returns copies of the â\x80\x98row_sparseâ\x80\x99 parameter on all contexts, in the same order\nas creation. The copy only retains rows whose ids occur in provided row ids.\nThe parameter must have been initialized before.', '\n', '\n', '\n', '\n', 'Re-assign Parameter to other contexts.', '\n', '\n', '\n', '\n', 'Returns a copy of the â\x80\x98row_sparseâ\x80\x99 parameter on the same context as row_idâ\x80\x99s.\nThe copy only retains rows whose ids occur in provided row ids.\nThe parameter must have been initialized on this context before.', '\n', '\n', '\n', '\n', 'Sets this parameterâ\x80\x99s value on all contexts.', '\n', '\n', '\n', '\n', 'The shape of the parameter.', '\n', '\n', '\n', '\n', 'Returns a symbol representing this parameter.', '\n', '\n', '\n', '\n', 'Sets gradient buffer on all contexts to 0. No action is taken if\nparameter is uninitialized or doesnâ\x80\x99t require gradient.', '\n', '\n']",,,
"
class mxnet.gluon.ParameterDict(prefix='', shared=None)[source]Â¶","['Bases: ', 'object', '\n', 'A dictionary managing a set of parameters.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Retrieves a ', '\n', '\n', '\n', '\n', 'Retrieves a ', '\n', '\n', '\n', '\n', 'Initializes all Parameters managed by this dictionary to be used for ', '\n', '\n', '\n', '\n', 'Returns a list of all the contexts on which the underlying Parameters\nare initialized.', '\n', '\n', '\n', '\n', 'Load parameters from file.', '\n', '\n', '\n', '\n', 'Load parameters from dict', '\n', '\n', '\n', '\n', 'Prefix of this dict. It will be prepended to ', '\n', '\n', '\n', '\n', 'Re-assign all Parameters to other contexts.', '\n', '\n', '\n', '\n', 'Save parameters to file.', '\n', '\n', '\n', '\n', 'Set an attribute to a new value for all Parameters.', '\n', '\n', '\n', '\n', 'Copies all Parameters in ', '\n', '\n', '\n', '\n', 'Sets all Parametersâ\x80\x99 gradient buffer to 0.', '\n', '\n']",,,
"
class mxnet.gluon.Trainer(params, optimizer, optimizer_params=None, kvstore='device', compression_params=None, update_on_kvstore=None)[source]Â¶","['Bases: ', 'object', '\n', 'Applies an ', 'Optimizer', ' on a set of Parameters. Trainer should\nbe used together with ', 'autograd', '.', '\n', '\n', 'Note', '\n', 'For the following cases, updates will always happen on kvstore,\ni.e., you cannot set update_on_kvstore=False.', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'For each parameter, reduce the gradients from different contexts.', '\n', '\n', '\n', '\n', 'Loads trainer states (e.g. optimizer, momentum) from a file.', '\n', '\n', '\n', '\n', 'Saves trainer states (e.g. optimizer, momentum) to a file.', '\n', '\n', '\n', '\n', 'Sets a new learning rate of the optimizer.', '\n', '\n', '\n', '\n', 'Makes one step of parameter update. Should be called after\n', '\n', '\n', '\n', '\n', 'Makes one step of parameter update.', '\n', '\n']",,,
"
class mxnet.gluon.loss.Loss(weight, batch_axis, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.block.HybridBlock', '\n', 'Base class for loss.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.L2Loss(weight=1.0, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates the mean squared error between ', 'label', ' and ', 'pred', '.', '\n', '\n\\[L = \\frac{1}{2} \\sum_i \\vert {label}_i - {pred}_i \\vert^2.\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'label', ' and ', 'pred', ' can have arbitrary shape as long as they have the same\nnumber of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.L1Loss(weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates the mean absolute error between ', 'label', ' and ', 'pred', '.', '\n', '\n\\[L = \\sum_i \\vert {label}_i - {pred}_i \\vert.\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'label', ' and ', 'pred', ' can have arbitrary shape as long as they have the same\nnumber of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.SigmoidBinaryCrossEntropyLoss(from_sigmoid=False, weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'The cross-entropy loss for binary classification. (alias: SigmoidBCELoss)', '\n', 'BCE loss is useful when training logistic regression. If ', 'from_sigmoid', '\nis False (default), this loss computes:', '\n', '\n\\[ \\begin{align}\\begin{aligned}prob = \\frac{1}{1 + \\exp(-{pred})}\\\\L = - \\sum_i {label}_i * \\log({prob}_i) * pos\\_weight +\n    (1 - {label}_i) * \\log(1 - {prob}_i)\\end{aligned}\\end{align} \\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'If ', 'from_sigmoid', ' is True, this loss computes:', '\n', '\n\\[L = - \\sum_i {label}_i * \\log({pred}_i) * pos\\_weight +\n    (1 - {label}_i) * \\log(1 - {pred}_i)\\]', '\n', 'A tensor ', 'pos_weight > 1', ' decreases the false negative count, hence increasing\nthe recall.\nConversely setting ', 'pos_weight < 1', ' decreases the false positive count and\nincreases the precision.', '\n', 'pred', ' and ', 'label', ' can have arbitrary shape as long as they have the same\nnumber of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.SoftmaxCrossEntropyLoss(axis=-1, sparse_label=True, from_logits=False, weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Computes the softmax cross entropy loss. (alias: SoftmaxCELoss)', '\n', 'If ', 'sparse_label', ' is ', 'True', ' (default), label should contain integer\ncategory indicators:', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\DeclareMathOperator{softmax}{softmax}\\\\p = \\softmax({pred})\\\\L = -\\sum_i \\log p_{i,{label}_i}\\end{aligned}\\end{align} \\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'label', 'â\x80\x99s shape should be ', 'pred', 'â\x80\x99s shape with the ', 'axis', ' dimension removed.\ni.e. for ', 'pred', ' with shape (1,2,3,4) and ', 'axis = 2', ', ', 'label', 'â\x80\x99s shape should\nbe (1,2,4).', '\n', 'If ', 'sparse_label', ' is ', 'False', ', ', 'label', ' should contain probability distribution\nand ', 'label', 'â\x80\x99s shape should be the same with ', 'pred', ':', '\n', '\n\\[ \\begin{align}\\begin{aligned}p = \\softmax({pred})\\\\L = -\\sum_i \\sum_j {label}_j \\log p_{ij}\\end{aligned}\\end{align} \\]', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.KLDivLoss(from_logits=True, axis=-1, weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'The Kullback-Leibler divergence loss.', '\n', 'KL divergence measures the distance between contiguous distributions. It\ncan be used to minimize information loss when approximating a distribution.\nIf ', 'from_logits', ' is True (default), loss is defined as:', '\n', '\n\\[L = \\sum_i {label}_i * \\big[\\log({label}_i) - {pred}_i\\big]\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'If ', 'from_logits', ' is False, loss is defined as:', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\DeclareMathOperator{softmax}{softmax}\\\\prob = \\softmax({pred})\\\\L = \\sum_i {label}_i * \\big[\\log({label}_i) - \\log({prob}_i)\\big]\\end{aligned}\\end{align} \\]', '\n', 'label', ' and ', 'pred', ' can have arbitrary shape as long as they have the same\nnumber of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', 'References', '\n', 'Kullback-Leibler divergence', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.CTCLoss(layout='NTC', label_layout='NT', weight=None, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Connectionist Temporal Classification Loss.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', 'Example', ': suppose the vocabulary is ', '[a, b, c]', ', and in one batch we\nhave three sequences â\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. We can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2, blank: 3}', '. Then ', 'alphabet_size', ' should be 4,\nwhere label 3 is reserved for internal use by ', 'CTCLoss', '. We then need to\npad each sequence with ', '-1', ' to make a rectangular ', 'label', ' tensor:', '\n', None, '\n', '\n', 'References', '\n', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']","[[1,0,-1,-1],[2,1,1,-1],[0,1,0,2]]
",,
"
class mxnet.gluon.loss.HuberLoss(rho=1, weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates smoothed L1 loss that is equal to L1 loss if absolute error\nexceeds rho but is equal to L2 loss otherwise. Also called SmoothedL1 loss.', '\n', '\n\\[\\begin{split}L = \\sum_i \\begin{cases} \\frac{1}{2 {rho}} ({label}_i - {pred}_i)^2 &\n                   \\text{ if } |{label}_i - {pred}_i| < {rho} \\\\\n                   |{label}_i - {pred}_i| - \\frac{{rho}}{2} &\n                   \\text{ otherwise }\n    \\end{cases}\\end{split}\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'label', ' and ', 'pred', ' can have arbitrary shape as long as they have the same\nnumber of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.HingeLoss(margin=1, weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates the hinge loss function often used in SVMs:', '\n', '\n\\[L = \\sum_i max(0, {margin} - {pred}_i \\cdot {label}_i)\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'where ', 'pred', ' is the classifier prediction and ', 'label', ' is the target tensor\ncontaining values -1 or 1. ', 'label', ' and ', 'pred', ' must have the same number of\nelements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.SquaredHingeLoss(margin=1, weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates the soft-margin loss function used in SVMs:', '\n', '\n\\[L = \\sum_i max(0, {margin} - {pred}_i \\cdot {label}_i)^2\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'where ', 'pred', ' is the classifier prediction and ', 'label', ' is the target tensor\ncontaining values -1 or 1. ', 'label', ' and ', 'pred', ' can have arbitrary shape as\nlong as they have the same number of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.LogisticLoss(weight=None, batch_axis=0, label_format='signed', **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates the logistic loss (for binary losses only):', '\n', '\n\\[L = \\sum_i \\log(1 + \\exp(- {pred}_i \\cdot {label}_i))\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'where ', 'pred', ' is the classifier prediction and ', 'label', ' is the target tensor\ncontaining values -1 or 1 (0 or 1 if ', 'label_format', ' is binary).\n', 'label', ' and ', 'pred', ' can have arbitrary shape as long as they have the same number of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.TripletLoss(margin=1, weight=None, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates triplet loss given three input tensors and a positive margin.\nTriplet loss measures the relative similarity between a positive\nexample, a negative example, and prediction:', '\n', '\n\\[L = \\sum_i \\max(\\Vert {pos_i}_i - {pred} \\Vert_2^2 -\n                \\Vert {neg_i}_i - {pred} \\Vert_2^2 + {margin}, 0)\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'positive', ', ', 'negative', ', and â\x80\x98predâ\x80\x99 can have arbitrary shape as long as they\nhave the same number of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.PoissonNLLLoss(weight=None, from_logits=True, batch_axis=0, compute_full=False, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'For a target (Random Variable) in a Poisson distribution, the function calculates the Negative\nLog likelihood loss.\nPoissonNLLLoss measures the loss accrued from a poisson regression prediction made by the model.', '\n', '\n\\[L = \\text{pred} - \\text{target} * \\log(\\text{pred}) +\\log(\\text{target!})\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'target', ', â\x80\x98predâ\x80\x99 can have arbitrary shape as long as they have the same number of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.CosineEmbeddingLoss(weight=None, batch_axis=0, margin=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'For a target label 1 or -1, vectors input1 and input2, the function computes the cosine distance\nbetween the vectors. This can be interpreted as how similar/dissimilar two input vectors are.', '\n', '\n\\[\\begin{split}L = \\sum_i \\begin{cases} 1 - {cos\\_sim({input1}_i, {input2}_i)} & \\text{ if } {label}_i = 1\\\\\n                 {cos\\_sim({input1}_i, {input2}_i)} & \\text{ if } {label}_i = -1 \\end{cases}\\\\\ncos\\_sim(input1, input2) = \\frac{{input1}_i.{input2}_i}{||{input1}_i||.||{input2}_i||}\\end{split}\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'input1', ', ', 'input2', ' can have arbitrary shape as long as they have the same number of elements.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Inputs:', '\n', '\n', 'Outputs:', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
class mxnet.gluon.loss.SDMLLoss(smoothing_parameter=0.3, weight=1.0, batch_axis=0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.gluon.loss.Loss', '\n', 'Calculates Batchwise Smoothed Deep Metric Learning (SDML) Loss given two input tensors and a smoothing weight\nSDM Loss learns similarity between paired samples by using unpaired samples in the minibatch\nas potential negative examples.', '\n', 'The loss is described in greater detail in\nâ\x80\x9cLarge Scale Question Paraphrase Retrieval with Smoothed Deep Metric Learning.â\x80\x9d\n- by Bonadiman, Daniele, Anjishnu Kumar, and Arpit Mittal.  arXiv preprint arXiv:1905.12786 (2019).\nURL: https://arxiv.org/pdf/1905.12786.pdf', '\n', 'According to the authors, this loss formulation achieves comparable or higher accuracy to\nTriplet Loss but converges much faster.\nThe loss assumes that the items in both tensors in each minibatch\nare aligned such that x1[0] corresponds to x2[0] and all other datapoints in the minibatch are unrelated.\n', 'x1', ' and  ', 'x2', ' are minibatches of vectors.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Overrides to construct symbolic graph for this ', '\n', '\n']",,,
"
mxnet.gluon.model_zoo.vision.get_model(name, **kwargs)[source]","['Returns a pre-defined model by name', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The model.', '\n', 'Return type', '\n', 'gluon.HybridBlock', '\n', '\n', '\n']",,,
"
mxnet.gluon.utils.split_data(data, num_slice, batch_axis=0, even_split=True)[source]Â¶","['Splits an NDArray into ', 'num_slice', ' slices along ', 'batch_axis', '.\nUsually used for data parallelism where each slices is sent\nto one device (i.e. GPU).', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Return value is a list even if ', '\n', 'Return type', '\n', 'list of NDArray', '\n', '\n', '\n']",,,
"
mxnet.gluon.utils.split_and_load(data, ctx_list, batch_axis=0, even_split=True)[source]Â¶","['Splits an NDArray into ', 'len(ctx_list)', ' slices along ', 'batch_axis', ' and loads\neach slice to one context in ', 'ctx_list', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Each corresponds to a context in ', '\n', 'Return type', '\n', 'list of NDArrays or ndarrays', '\n', '\n', '\n']",,,
"
mxnet.gluon.utils.clip_global_norm(arrays, max_norm, check_isfinite=True)[source]Â¶","['Rescales NDArrays so that the sum of their 2-norm is smaller than ', 'max_norm', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Total norm. Return type is NDArray of shape (1,) if check_isfinite is\nFalse. Otherwise a float is returned.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.gluon.utils.check_sha1(filename, sha1_hash)[source]Â¶","['Check whether the sha1 hash of the file content matches the expected hash.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Whether the file content matches the expected hash.', '\n', 'Return type', '\n', 'bool', '\n', '\n', '\n']",,,
"
mxnet.gluon.utils.download(url, path=None, overwrite=False, sha1_hash=None, retries=5, verify_ssl=True)[source]Â¶","['Download a given URL', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The file path of the downloaded file.', '\n', 'Return type', '\n', 'str', '\n', '\n', '\n']",,,
"
mxnet.gluon.utils.replace_file(src, dst)[source]Â¶","['Implement atomic os.replace with linux and OSX.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.autograd.Function[source]Â¶","['Bases: ', 'object', '\n', 'Customize differentiation in autograd.', '\n', 'If you donâ\x80\x99t want to use the gradients computed by the default\nchain-rule, you can use Function to customize differentiation for\ncomputation. You define your computation in\nthe forward method and provide the customized differentiation\nin the backward method. During gradient computation, autograd will\nuse the user-defined backward function instead of the default chain-rule.\nYou can also cast to numpy array and back for some operations in\nforward and backward.', '\n', 'For example, a stable sigmoid function can be defined as:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Then, the function can be used in the following way:', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Backward computation.', '\n', '\n', '\n', '\n', 'Forward computation.', '\n', '\n']",,,
"
mxnet.autograd.backward(heads, head_grads=None, retain_graph=False, train_mode=True)[source]Â¶","['Compute the gradients of heads w.r.t previously marked variables.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.autograd.get_symbol(x)[source]Â¶","['Retrieve recorded computation history as ', 'Symbol', '.', '\n', '\n', 'Parameters', '\n', 'x', '\n', 'Returns', '\n', 'The retrieved Symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.autograd.grad(heads, variables, head_grads=None, retain_graph=None, create_graph=False, train_mode=True)[source]Â¶","['Compute the gradients of heads w.r.t variables. Gradients will be\nreturned as new NDArrays instead of stored into ', 'variable.grad', '.\nSupports recording gradient graph for computing higher order gradients.', '\n', '\n', 'Note', '\n', 'Currently only a very limited set of operators support higher order       gradients.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Gradients with respect to variables.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.autograd.is_recording()[source]Â¶","['Get status on recording/not recording.', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'Current state of recording.', '\n', '\n', '\n']",,,
"
mxnet.autograd.is_training()[source]Â¶","['Get status on training/predicting.', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'Current state of training/predicting.', '\n', '\n', '\n']",,,
"
mxnet.autograd.mark_variables(variables, gradients, grad_reqs='write')[source]Â¶","['Mark NDArrays as variables to compute gradient for autograd.', '\n', 'This is equivalent to the function .attach_grad() in a variable, but with this\ncall we can set the gradient to any value.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.autograd.pause(train_mode=False)[source]Â¶","['Returns a scope context to be used in â\x80\x98withâ\x80\x99 statement for codes that do not need\ngradients to be calculated.', '\n', 'Example:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', 'train_mode', '\n', '\n', '\n']",,,
"
mxnet.autograd.predict_mode()[source]Â¶","['Returns a scope context to be used in â\x80\x98withâ\x80\x99 statement\nin which forward pass behavior is set to inference mode,\nwithout changing the recording states.', '\n', 'Example:', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.autograd.record(train_mode=True)[source]Â¶","['Returns an autograd recording scope context to be used in â\x80\x98withâ\x80\x99 statement\nand captures code that needs gradients to be calculated.', '\n', '\n', 'Note', '\n', 'When forwarding with train_mode=False, the corresponding backward\nshould also use train_mode=False, otherwise gradient is undefined.', '\n', '\n', 'Example:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', 'train_mode', '\n', '\n', '\n']",,,
"
mxnet.autograd.set_recording(is_recording)[source]Â¶","['Set status to recording/not recording. When recording, graph will be constructed\nfor gradient computation.', '\n', '\n', 'Parameters', '\n', 'is_recording', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'previous state before this set.', '\n', '\n', '\n']",,,
"
mxnet.autograd.set_training(train_mode)[source]Â¶","['Set status to training/predicting. This affects ctx.is_train in operator\nrunning context. For example, Dropout will drop inputs randomly when\ntrain_mode=True while simply passing through if train_mode=False.', '\n', '\n', 'Parameters', '\n', 'train_mode', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'previous state before this set.', '\n', '\n', '\n']",,,
"
mxnet.autograd.train_mode()[source]Â¶","['Returns a scope context to be used in â\x80\x98withâ\x80\x99 statement\nin which forward pass behavior is set to training mode,\nwithout changing the recording states.', '\n', 'Example:', '\n', None, '\n', '\n', '\n']",,,
"
class mxnet.initializer.Bilinear[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initialize weight for upsampling layers.', '\n', '\n']",,,
"
class mxnet.initializer.Constant(value)[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initializes the weights to a given value.\nThe value passed in can be a scalar or a NDarray that matches the shape\nof the parameter to be set.', '\n', '\n', 'Parameters', '\n', 'value', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Saves the initializer to string', '\n', '\n']",,,
"
class mxnet.initializer.FusedRNN(init, num_hidden, num_layers, mode, bidirectional=False, forget_bias=1.0)[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initialize parameters for fused rnn layers.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.initializer.InitDesc[source]Â¶","['Bases: ', 'str', '\n', 'Descriptor for the initialization pattern.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.initializer.Initializer(**kwargs)[source]Â¶","['Bases: ', 'object', '\n', 'The base class of an initializer.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Saves the initializer to string', '\n', '\n', '\n', '\n', 'Switch on/off verbose mode', '\n', '\n']",,,
"
class mxnet.initializer.LSTMBias(forget_bias=1.0)[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initialize all biases of an LSTMCell to 0.0 except for\nthe forget gate whose bias is set to custom value.', '\n', '\n', 'Parameters', '\n', 'forget_bias', '\n', '\n', '\n']",,,
"
class mxnet.initializer.Load(param, default_init=None, verbose=False)[source]Â¶","['Bases: ', 'object', '\n', 'Initializes variables by loading data from file or dict.', '\n', 'Note', ' Load will drop ', 'arg:', ' or ', 'aux:', ' from name and\ninitialize the variables that match with the prefix dropped.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.initializer.MSRAPrelu(factor_type='avg', slope=0.25)[source]Â¶","['Bases: ', 'mxnet.initializer.Xavier', '\n', 'Initialize the weight according to a MSRA paper.', '\n', 'This initializer implements ', 'Delving Deep into Rectifiers: Surpassing\nHuman-Level Performance on ImageNet Classification', ', available at\n', 'https://arxiv.org/abs/1502.01852', '.', '\n', 'This initializer is proposed for initialization related to ReLu activation,\nit makes some changes on top of Xavier method.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.initializer.Mixed(patterns, initializers)[source]Â¶","['Bases: ', 'object', '\n', 'Initialize parameters using multiple initializers.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> # Given 'module', an instance of 'mxnet.module.Module', initialize biases to zero
... # and every other parameter to random values with uniform distribution.
...
>>> init=mx.initializer.Mixed(['bias','.*'],[mx.init.Zero(),mx.init.Uniform(0.1)])
>>> module.init_params(init)
>>>
>>> fordictionaryinmodule.get_params():
... forkeyindictionary:
... print(key)
... print(dictionary[key].asnumpy())
...
fullyconnected1_weight
[[ 0.0097627   0.01856892  0.04303787]]
fullyconnected1_bias
[ 0.]
",,
"
class mxnet.initializer.Normal(sigma=0.01)[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initializes weights with random values sampled from a normal distribution\nwith a mean of zero and standard deviation of ', 'sigma', '.', '\n', '\n', 'Parameters', '\n', 'sigma', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> # Given 'module', an instance of 'mxnet.module.Module', initialize weights
>>> # to random values sampled from a normal distribution.
...
>>> init=mx.init.Normal(0.5)
>>> module.init_params(init)
>>> fordictionaryinmodule.get_params():
... forkeyindictionary:
... print(key)
... print(dictionary[key].asnumpy())
...
fullyconnected0_weight
[[-0.3214761  -0.12660924  0.53789419]]
",,
"
class mxnet.initializer.One[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initializes weights to one.', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> # Given 'module', an instance of 'mxnet.module.Module', initialize weights to one.
...
>>> init=mx.initializer.One()
>>> module.init_params(init)
>>> fordictionaryinmodule.get_params():
... forkeyindictionary:
... print(key)
... print(dictionary[key].asnumpy())
...
fullyconnected0_weight
[[ 1.  1.  1.]]
",,
"
class mxnet.initializer.Orthogonal(scale=1.414, rand_type='uniform')[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initialize weight as orthogonal matrix.', '\n', 'This initializer implements ', 'Exact solutions to the nonlinear dynamics of\nlearning in deep linear neural networks', ', available at\n', 'https://arxiv.org/abs/1312.6120', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.initializer.Uniform(scale=0.07)[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initializes weights with random values uniformly sampled from a given range.', '\n', '\n', 'Parameters', '\n', 'scale', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> # Given 'module', an instance of 'mxnet.module.Module', initialize weights
>>> # to random values uniformly sampled between -0.1 and 0.1.
...
>>> init=mx.init.Uniform(0.1)
>>> module.init_params(init)
>>> fordictionaryinmodule.get_params():
... forkeyindictionary:
... print(key)
... print(dictionary[key].asnumpy())
...
fullyconnected0_weight
[[ 0.01360891 -0.02144304  0.08511933]]
",,
"
class mxnet.initializer.Xavier(rnd_type='uniform', factor_type='avg', magnitude=3)[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Returns an initializer performing â\x80\x9cXavierâ\x80\x9d initialization for weights.', '\n', 'This initializer is designed to keep the scale of gradients roughly the same\nin all layers.', '\n', 'By default, ', 'rnd_type', ' is ', ""'uniform'"", ' and ', 'factor_type', ' is ', ""'avg'"", ',\nthe initializer fills the weights with random numbers in the range\nof ', '\\([-c, c]\\)', ', where ', '\\(c = \\sqrt{\\frac{3.}{0.5 * (n_{in} + n_{out})}}\\)', '.\n', '\\(n_{in}\\)', ' is the number of neurons feeding into weights, and ', '\\(n_{out}\\)', ' is\nthe number of neurons the result is fed to.', '\n', 'If ', 'rnd_type', ' is ', ""'uniform'"", ' and ', 'factor_type', ' is ', ""'in'"", ',\nthe ', '\\(c = \\sqrt{\\frac{3.}{n_{in}}}\\)', '.\nSimilarly when ', 'factor_type', ' is ', ""'out'"", ', the ', '\\(c = \\sqrt{\\frac{3.}{n_{out}}}\\)', '.', '\n', 'If ', 'rnd_type', ' is ', ""'gaussian'"", ' and ', 'factor_type', ' is ', ""'avg'"", ',\nthe initializer fills the weights with numbers from normal distribution with\na standard deviation of ', '\\(\\sqrt{\\frac{3.}{0.5 * (n_{in} + n_{out})}}\\)', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.initializer.Zero[source]Â¶","['Bases: ', 'mxnet.initializer.Initializer', '\n', 'Initializes weights to zero.', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> # Given 'module', an instance of 'mxnet.module.Module', initialize weights to zero.
...
>>> init=mx.initializer.Zero()
>>> module.init_params(init)
>>> fordictionaryinmodule.get_params():
... forkeyindictionary:
... print(key)
... print(dictionary[key].asnumpy())
...
fullyconnected0_weight
[[ 0.  0.  0.]]
",,
"
mxnet.initializer.register(klass)[source]Â¶","['Registers a custom initializer.', '\n', 'Custom initializers can be created by extending ', 'mx.init.Initializer', ' and implementing the\nrequired functions like ', '_init_weight', ' and ', '_init_bias', '. The created initializer must be\nregistered using ', 'mx.init.register', ' before it can be called by name.', '\n', '\n', 'Parameters', '\n', 'klass', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> # Create and register a custom initializer that
... # initializes weights to 0.1 and biases to 1.
...
>>> @mx.init.register
... @alias('myinit')
... classCustomInit(mx.init.Initializer):
... def__init__(self):
... super(CustomInit,self).__init__()
... def_init_weight(self,_,arr):
... arr[:]=0.1
... def_init_bias(self,_,arr):
... arr[:]=1
...
>>> # Module is an instance of 'mxnet.module.Module'
...
>>> module.init_params(""custominit"")
>>> # module.init_params(""myinit"")
>>> # module.init_params(CustomInit())
",,
"
class mxnet.optimizer.AdaDelta(rho=0.9, epsilon=1e-05, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The AdaDelta optimizer.', '\n', 'This class implements AdaDelta, an optimizer described in  ', 'ADADELTA: An adaptive\nlearning rate method', ', available at ', 'https://arxiv.org/abs/1212.5701', '.', '\n', 'This optimizer updates each weight by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.AdaGrad(eps=1e-07, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'AdaGrad optimizer.', '\n', 'This class implements the AdaGrad optimizer described in ', 'Adaptive Subgradient\nMethods for Online Learning and Stochastic Optimization', ', and available at\n', 'http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf', '.', '\n', 'This optimizer updates each weight by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'See also', '\n', 'mxnet.ndarray.sparse.adagrad_update()', '\n', '\n', '\n', 'Parameters', '\n', 'eps', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.Adam(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, lazy_update=True, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The Adam optimizer.', '\n', 'This class implements the optimizer described in ', 'Adam: A Method for\nStochastic Optimization', ', available at ', 'http://arxiv.org/abs/1412.6980', '.', '\n', 'If the storage types of grad is ', 'row_sparse', ', and ', 'lazy_update', ' is True,     ', 'lazy updates', ' at step t are applied by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'The lazy update only updates the mean and var for the weights whose row_sparse\ngradient indices appear in the current batch, rather than updating it for all indices.\nCompared with the original update, it can provide large improvements in model training\nthroughput for some applications. However, it provides slightly different semantics than\nthe original update, and may lead to different empirical results.', '\n', 'Otherwise, ', 'standard updates', ' at step t are applied by:', '\n', None, '\n', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', 'For details of the update algorithm, see ', 'adam_update', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.Adamax(learning_rate=0.002, beta1=0.9, beta2=0.999, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The AdaMax optimizer.', '\n', 'It is a variant of Adam based on the infinity norm\navailable at ', 'http://arxiv.org/abs/1412.6980', ' Section 7.', '\n', 'The optimizer updates the weight by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.DCASGD(momentum=0.0, lamda=0.04, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The DCASGD optimizer.', '\n', 'This class implements the optimizer described in ', 'Asynchronous Stochastic Gradient Descent\nwith Delay Compensation for Distributed Deep Learning', ',\navailable at ', 'https://arxiv.org/abs/1609.08326', '.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.FTML(beta1=0.6, beta2=0.999, epsilon=1e-08, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The FTML optimizer.', '\n', 'This class implements the optimizer described in\n', 'FTML - Follow the Moving Leader in Deep Learning', ',\navailable at ', 'http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf', '.', '\n', 'Denote time step by t. The optimizer updates the weight by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'For details of the update algorithm, see ', 'ftml_update', '.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.Ftrl(lamda1=0.01, learning_rate=0.1, beta=1, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The Ftrl optimizer.', '\n', 'Referenced from ', 'Ad Click Prediction: a View from the Trenches', ', available at\n', 'http://dl.acm.org/citation.cfm?id=2488200', '.', '\n', '\n', 'eta :', '\n\\[\\eta_{t,i} = \\frac{learningrate}{\\beta+\\sqrt{\\sum_{s=1}^tg_{s,i}^2}}\\]', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'The optimizer updates the weight by:', '\n', None, '\n', '\n', 'If the storage types of weight, state and grad are all ', 'row_sparse', ',     ', 'sparse updates', ' are applied by:', '\n', None, '\n', '\n', 'The sparse update only updates the z and n for the weights whose row_sparse\ngradient indices appear in the current batch, rather than updating it for all\nindices. Compared with the original update, it can provide large\nimprovements in model training throughput for some applications. However, it\nprovides slightly different semantics than the original update, and\nmay lead to different empirical results.', '\n', 'For details of the update algorithm, see ', 'ftrl_update', '.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.LARS(momentum=0.0, lazy_update=True, eta=0.001, eps=0, momentum_correction=True, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'the LARS optimizer from â\x80\x98Large Batch Training of Convolution Networksâ\x80\x99     (', 'https://arxiv.org/abs/1708.03888', ')', '\n', 'Behave mostly like SGD with momentum and weight decay but is scaling     adaptively the learning for each layer (except bias and batch norm parameters):\nw_norm = L2norm(weights)\ng_norm = L2norm(gradients)\nif w_norm > 0 and g_norm > 0:', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'lr_layer = lr * lr_mult * eta * w_norm / (g_norm + weight_decay * w_norm + eps)', '\n', '\n', 'else:', 'lr_layer = lr * lr_mult', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight, including FP32 high\nprecision copy if original weight is FP16.', '\n', '\n', '\n', '\n', 'Sets an individual weight decay multiplier for each parameter.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.\nMixed precision version.', '\n', '\n']",,,
"
class mxnet.optimizer.LBSGD(momentum=0.0, multi_precision=False, warmup_strategy='linear', warmup_epochs=5, batch_scale=1, updates_per_epoch=32, begin_epoch=0, num_epochs=60, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The Large Batch SGD optimizer with momentum and weight decay.', '\n', 'The optimizer updates the weight by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'For details of the update algorithm see ', 'sgd_update', '\nand ', 'sgd_mom_update', '.\nIn addition to the SGD updates the LBSGD optimizer uses the LARS, Layer-wise\nAdaptive Rate Scaling, algorithm to have a separate learning rate for each\nlayer of the network, which leads to better stability over large batch sizes.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.NAG(momentum=0.0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'Nesterov accelerated gradient.', '\n', 'This optimizer updates each weight by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight, including FP32 high\nprecision copy if original weight is FP16.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.\nMixed precision version.', '\n', '\n']",,,
"
mxnet.optimizer.NDabs(data=None, out=None, name=None, **kwargs)Â¶","['Returns element-wise absolute value of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'abs', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L720', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
class mxnet.optimizer.Nadam(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, schedule_decay=0.004, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The Nesterov Adam optimizer.', '\n', 'Much like Adam is essentially RMSprop with momentum,\nNadam is Adam RMSprop with Nesterov momentum available\nat ', 'http://cs229.stanford.edu/proj2015/054_report.pdf', '.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.Optimizer(rescale_grad=1.0, param_idx2name=None, wd=0.0, clip_gradient=None, learning_rate=None, lr_scheduler=None, sym=None, begin_num_update=0, multi_precision=False, param_dict=None)[source]Â¶","['Bases: ', 'object', '\n', 'The base class inherited by all optimizers.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Instantiates an optimizer with a given name and kwargs.', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight, including FP32 high\nprecision copy if original weight is FP16.', '\n', '\n', '\n', '\n', 'Registers a new optimizer.', '\n', '\n', '\n', '\n', 'Sets a new learning rate of the optimizer.', '\n', '\n', '\n', '\n', 'Sets an individual learning rate multiplier for each parameter.', '\n', '\n', '\n', '\n', '[DEPRECATED] Sets lr scale. Use set_lr_mult instead.', '\n', '\n', '\n', '\n', 'Sets an individual weight decay multiplier for each parameter.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.\nMixed precision version.', '\n', '\n']",,,
"
class mxnet.optimizer.RMSProp(learning_rate=0.001, gamma1=0.9, gamma2=0.9, epsilon=1e-08, centered=False, clip_weights=None, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The RMSProp optimizer.', '\n', 'Two versions of RMSProp are implemented:', '\n', 'If ', 'centered=False', ', we follow\n', 'http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf', ' by\nTieleman & Hinton, 2012.\nFor details of the update algorithm see ', 'rmsprop_update', '.', '\n', 'If ', 'centered=True', ', we follow ', 'http://arxiv.org/pdf/1308.0850v5.pdf', ' (38)-(45)\nby Alex Graves, 2013.\nFor details of the update algorithm see ', 'rmspropalex_update', '.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.SGD(momentum=0.0, lazy_update=True, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The SGD optimizer with momentum and weight decay.', '\n', 'If the storage types of grad is ', 'row_sparse', ' and ', 'lazy_update', ' is True,     ', 'lazy updates', ' are applied by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'The sparse update only updates the momentum for the weights whose row_sparse\ngradient indices appear in the current batch, rather than updating it for all\nindices. Compared with the original update, it can provide large\nimprovements in model training throughput for some applications. However, it\nprovides slightly different semantics than the original update, and\nmay lead to different empirical results.', '\n', 'In the case when ', 'update_on_kvstore', ' is set to False (either globally via\nMXNET_UPDATE_ON_KVSTORE=0 environment variable or as a parameter in\n', 'Trainer', ') SGD optimizer can perform aggregated update\nof parameters, which may lead to improved performance. The aggregation size\nis controlled by MXNET_OPTIMIZER_AGGREGATION_SIZE environment variable and\ndefaults to 4.', '\n', 'Otherwise, ', 'standard updates', ' are applied by:', '\n', None, '\n', '\n', 'For details of the update algorithm see\n', 'sgd_update', ' and ', 'sgd_mom_update', '.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight, including FP32 high\nprecision copy if original weight is FP16.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.\nMixed precision version.', '\n', '\n']",,,
"
class mxnet.optimizer.SGLD(**kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'Stochastic Gradient Riemannian Langevin Dynamics.', '\n', 'This class implements the optimizer described in the paper ', 'Stochastic Gradient\nRiemannian Langevin Dynamics on the Probability Simplex', ', available at\n', 'https://papers.nips.cc/paper/4883-stochastic-gradient-riemannian-langevin-dynamics-on-the-probability-simplex.pdf', '.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.Signum(learning_rate=0.01, momentum=0.9, wd_lh=0.0, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The Signum optimizer that takes the sign of gradient or momentum.', '\n', 'The optimizer updates the weight by:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'References', '\n', 'Jeremy Bernstein, Yu-Xiang Wang, Kamyar Azizzadenesheli & Anima Anandkumar. (2018).\nsignSGD: Compressed Optimisation for Non-Convex Problems. In ICMLâ\x80\x9918.', '\n', 'See: ', 'https://arxiv.org/abs/1802.04434', '\n', 'For details of the update algorithm see\n', 'signsgd_update', ' and ', 'signum_update', '.', '\n', 'This optimizer accepts the following parameters in addition to those accepted\nby ', 'Optimizer', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n']",,,
"
class mxnet.optimizer.LAMB(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-06, lower_bound=None, upper_bound=None, bias_correction=True, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'LAMB Optimizer.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates auxiliary state for a given weight.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.', '\n', '\n', '\n', '\n', 'Updates the given parameter using the corresponding gradient and state.\nMixed precision version.', '\n', '\n']",,,
"
class mxnet.optimizer.Test(**kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.Optimizer', '\n', 'The Test optimizer', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Creates a state to duplicate weight.', '\n', '\n', '\n', '\n', 'Performs w += rescale_grad * grad.', '\n', '\n']",,,
"
class mxnet.optimizer.Updater(optimizer)[source]Â¶","['Bases: ', 'object', '\n', 'Updater for kvstore.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Gets updater states.', '\n', '\n', '\n', '\n', 'Sets updater states.', '\n', '\n', '\n', '\n', 'sync state context.', '\n', '\n']",,,
"
class mxnet.optimizer.ccSGD(*args, **kwargs)[source]Â¶","['Bases: ', 'mxnet.optimizer.optimizer.SGD', '\n', '[DEPRECATED] Same as ', 'SGD', '. Left here for backward compatibility.', '\n', '\n']",,,
"
mxnet.optimizer.create(name, **kwargs)Â¶","['Instantiates an optimizer with a given name and kwargs.', '\n', '\n', 'Note', '\n', 'We can use the alias ', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An instantiated optimizer.', '\n', 'Return type', '\n', 'Optimizer', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.optimizer.get_updater(optimizer)[source]Â¶","['Returns a closure of the updater needed for kvstore.', '\n', '\n', 'Parameters', '\n', 'optimizer', '\n', 'Returns', '\n', 'updater', '\n', 'Return type', '\n', 'function', '\n', '\n', '\n']",,,
"
mxnet.optimizer.register(klass)Â¶","['Registers a new optimizer.', '\n', 'Once an optimizer is registered, we can create an instance of this\noptimizer with ', 'create_optimizer', ' later.', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
class mxnet.lr_scheduler.CosineScheduler(max_update, base_lr=0.01, final_lr=0, warmup_steps=0, warmup_begin_lr=0, warmup_mode='linear')[source]Â¶","['Bases: ', 'mxnet.lr_scheduler.LRScheduler', '\n', 'Reduce the learning rate according to a cosine function', '\n', 'Calculate the new learning rate by:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.lr_scheduler.FactorScheduler(step, factor=1, stop_factor_lr=1e-08, base_lr=0.01, warmup_steps=0, warmup_begin_lr=0, warmup_mode='linear')[source]Â¶","['Bases: ', 'mxnet.lr_scheduler.LRScheduler', '\n', 'Reduce the learning rate by a factor for every ', 'n', ' steps.', '\n', 'It returns a new learning rate by:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.lr_scheduler.LRScheduler(base_lr=0.01, warmup_steps=0, warmup_begin_lr=0, warmup_mode='linear')[source]Â¶","['Bases: ', 'object', '\n', 'Base class of a learning rate scheduler.', '\n', 'A scheduler returns a new learning rate based on the number of updates that have\nbeen performed.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.lr_scheduler.MultiFactorScheduler(step, factor=1, base_lr=0.01, warmup_steps=0, warmup_begin_lr=0, warmup_mode='linear')[source]Â¶","['Bases: ', 'mxnet.lr_scheduler.LRScheduler', '\n', 'Reduce the learning rate by given a list of steps.', '\n', 'Assume there exists ', 'k', ' such that:', '\n', None, '\n', '\n', 'Then calculate the new learning rate by:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.lr_scheduler.PolyScheduler(max_update, base_lr=0.01, pwr=2, final_lr=0, warmup_steps=0, warmup_begin_lr=0, warmup_mode='linear')[source]Â¶","['Bases: ', 'mxnet.lr_scheduler.LRScheduler', '\n', 'Reduce the learning rate according to a polynomial of given power.', '\n', 'Calculate the new learning rate, after warmup if any, by:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.metric.Accuracy(axis=1, name='accuracy', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes accuracy classification score.', '\n', 'The accuracy score is defined as', '\n', '\n\\[\\text{accuracy}(y, \\hat{y}) = \\frac{1}{n} \\sum_{i=0}^{n-1}\n\\text{1}(\\hat{y_i} == y_i)\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.Caffe(name='caffe', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.Loss', '\n', 'Dummy metric for caffe criterions.', '\n', '\n']",,,
"
class mxnet.metric.CompositeEvalMetric(metrics=None, name='composite', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Manages multiple evaluation metrics.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Adds a child metric.', '\n', '\n', '\n', '\n', 'Returns the current evaluation result.', '\n', '\n', '\n', '\n', 'Save configurations of metric. Can be recreated\nfrom configs with metric.create(', '\n', '\n', '\n', '\n', 'Returns the current evaluation result.', '\n', '\n', '\n', '\n', 'Returns a child metric.', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Resets the local portion of the internal evaluation results to initial state.', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n', '\n', '\n', 'Update the internal evaluation with named label and pred', '\n', '\n']",,,
"
class mxnet.metric.CrossEntropy(eps=1e-12, name='cross-entropy', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes Cross Entropy loss.', '\n', 'The cross entropy over a batch of sample size ', '\\(N\\)', ' is given by', '\n', '\n\\[-\\sum_{n=1}^{N}\\sum_{k=1}^{K}t_{nk}\\log (y_{nk}),\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'where ', '\\(t_{nk}=1\\)', ' if and only if sample ', '\\(n\\)', ' belongs to class ', '\\(k\\)', '.\n', '\\(y_{nk}\\)', ' denotes the probability of sample ', '\\(n\\)', ' belonging to\nclass ', '\\(k\\)', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.CustomMetric(feval, name=None, allow_extra_outputs=False, output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes a customized evaluation metric.', '\n', 'The ', 'feval', ' function can return a ', 'tuple', ' of (sum_metric, num_inst) or return\nan ', 'int', ' sum_metric.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Save configurations of metric. Can be recreated\nfrom configs with metric.create(', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.EvalMetric(name, output_names=None, label_names=None, **kwargs)[source]Â¶","['Bases: ', 'object', '\n', 'Base class for all evaluation metrics.', '\n', '\n', 'Note', '\n', 'This is a base class that provides common metric interfaces.\nOne should not use this class directly, but instead create new metric\nclasses that extend it.', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Gets the current evaluation result.', '\n', '\n', '\n', '\n', 'Save configurations of metric. Can be recreated\nfrom configs with metric.create(', '\n', '\n', '\n', '\n', 'Gets the current global evaluation result.', '\n', '\n', '\n', '\n', 'Returns zipped name and value pairs for global results.', '\n', '\n', '\n', '\n', 'Returns zipped name and value pairs.', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Resets the local portion of the internal evaluation results to initial state.', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n', '\n', '\n', 'Update the internal evaluation with named label and pred', '\n', '\n']",,,
"
class mxnet.metric.F1(name='f1', output_names=None, label_names=None, average='macro')[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes the F1 score of a binary classification problem.', '\n', 'The F1 score is equivalent to harmonic mean of the precision and recall,\nwhere the best value is 1.0 and the worst value is 0.0. The formula for F1 score is:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'The formula for precision and recall is:', '\n', None, '\n', '\n', '\n', 'Note', '\n', 'This F1 score only supports binary classification.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.Loss(name='loss', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Dummy metric for directly printing loss.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.MAE(name='mae', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes Mean Absolute Error (MAE) loss.', '\n', 'The mean absolute error is given by', '\n', '\n\\[\\frac{\\sum_i^n |y_i - \\hat{y}_i|}{n}\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.MCC(name='mcc', output_names=None, label_names=None, average='macro')[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes the Matthews Correlation Coefficient of a binary classification problem.', '\n', 'While slower to compute than F1 the MCC can give insight that F1 or Accuracy cannot.\nFor instance, if the network always predicts the same result\nthen the MCC will immeadiately show this. The MCC is also symetric with respect\nto positive and negative categorization, however, there needs to be both\npositive and negative examples in the labels or it will always return 0.\nMCC of 0 is uncorrelated, 1 is completely correlated, and -1 is negatively correlated.', '\n', '\n\\[\\text{MCC} = \\frac{ TP \\times TN - FP \\times FN }\n{\\sqrt{ (TP + FP) ( TP + FN ) ( TN + FP ) ( TN + FN ) } }\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'where 0 terms in the denominator are replaced by 1.', '\n', '\n', 'Note', '\n', 'This version of MCC only supports binary classification.  See PCC.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.MSE(name='mse', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes Mean Squared Error (MSE) loss.', '\n', 'The mean squared error is given by', '\n', '\n\\[\\frac{\\sum_i^n (y_i - \\hat{y}_i)^2}{n}\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.NegativeLogLikelihood(eps=1e-12, name='nll-loss', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes the negative log-likelihood loss.', '\n', 'The negative log-likelihoodd loss over a batch of sample size ', '\\(N\\)', ' is given by', '\n', '\n\\[-\\sum_{n=1}^{N}\\sum_{k=1}^{K}t_{nk}\\log (y_{nk}),\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'where ', '\\(K\\)', ' is the number of classes, ', '\\(y_{nk}\\)', ' is the prediceted probability for\n', '\\(k\\)', '-th class for ', '\\(n\\)', '-th sample. ', '\\(t_{nk}=1\\)', ' if and only if sample\n', '\\(n\\)', ' belongs to class ', '\\(k\\)', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.PCC(name='pcc', output_names=None, label_names=None, has_global_stats=True)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'PCC is a multiclass equivalent for the Matthews correlation coefficient derived\nfrom a discrete solution to the Pearson correlation coefficient.', '\n', ""\n\\[\\text{PCC} = \\frac {\\sum _{k}\\sum _{l}\\sum _{m}C_{kk}C_{lm}-C_{kl}C_{mk}}\n{{\\sqrt {\\sum _{k}(\\sum _{l}C_{kl})(\\sum _{k'|k'\\neq k}\\sum _{l'}C_{k'l'})}}\n {\\sqrt {\\sum _{k}(\\sum _{l}C_{lk})(\\sum _{k'|k'\\neq k}\\sum _{l'}C_{l'k'})}}}\\]"", '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'defined in terms of a K x K confusion matrix C.', '\n', 'When there are more than two labels the PCC will no longer range between -1 and +1.\nInstead the minimum value will be between -1 and 0 depending on the true distribution.\nThe maximum value is always +1.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Resets the local portion of the internal evaluation results to initial state.', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.PearsonCorrelation(name='pearsonr', output_names=None, label_names=None, average='macro')[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes Pearson correlation.', '\n', 'The pearson correlation is given by', '\n', '\n\\[\\frac{cov(y, \\hat{y})}{\\sigma{y}\\sigma{\\hat{y}}}\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Gets the current evaluation result.', '\n', '\n', '\n', '\n', 'Resets the internal evaluation result to initial state.', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.Perplexity(ignore_label, axis=-1, name='perplexity', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes perplexity.', '\n', 'Perplexity is a measurement of how well a probability distribution\nor model predicts a sample. A low perplexity indicates the model\nis good at predicting the sample.', '\n', 'The perplexity of a model q is defined as', '\n', '\n\\[b^{\\big(-\\frac{1}{N} \\sum_{i=1}^N \\log_b q(x_i) \\big)}\n= \\exp \\big(-\\frac{1}{N} \\sum_{i=1}^N \\log q(x_i)\\big)\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'where we let ', 'b = e', '.', '\n', '\\(q(x_i)\\)', ' is the predicted value of its ground truth\nlabel on sample ', '\\(x_i\\)', '.', '\n', 'For example, we have three samples ', '\\(x_1, x_2, x_3\\)', ' and their labels\nare ', '\\([0, 1, 1]\\)', '.\nSuppose our model predicts ', '\\(q(x_1) = p(y_1 = 0 | x_1) = 0.3\\)', '\nand ', '\\(q(x_2) = 1.0\\)', ',\n', '\\(q(x_3) = 0.6\\)', '. The perplexity of model q is\n', '\\(exp\\big(-(\\log 0.3 + \\log 1.0 + \\log 0.6) / 3\\big) = 1.77109762852\\)', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Returns the current evaluation result.', '\n', '\n', '\n', '\n', 'Returns the current global evaluation result.', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.RMSE(name='rmse', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes Root Mean Squred Error (RMSE) loss.', '\n', 'The root mean squared error is given by', '\n', '\n\\[\\sqrt{\\frac{\\sum_i^n (y_i - \\hat{y}_i)^2}{n}}\\]', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.TopKAccuracy(top_k=1, name='top_k_accuracy', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.EvalMetric', '\n', 'Computes top k predictions accuracy.', '\n', 'TopKAccuracy', ' differs from Accuracy in that it considers the prediction\nto be ', 'True', ' as long as the ground truth label is in the top K\npredicated labels.', '\n', 'If ', 'top_k', ' = ', '1', ', then ', 'TopKAccuracy', ' is identical to ', 'Accuracy', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Updates the internal evaluation result.', '\n', '\n']",,,
"
class mxnet.metric.Torch(name='torch', output_names=None, label_names=None)[source]Â¶","['Bases: ', 'mxnet.metric.Loss', '\n', 'Dummy metric for torch criterions.', '\n', '\n']",,,
"
mxnet.metric.check_label_shapes(labels, preds, wrap=False, shape=False)[source]Â¶","['Helper function for checking shape of label and prediction', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.metric.create(metric, *args, **kwargs)[source]Â¶","['Creates evaluation metric from metric names or instances of EvalMetric\nor a custom metric function.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.metric.np(numpy_feval, name=None, allow_extra_outputs=False)[source]Â¶","['Creates a custom evaluation metric that receives its inputs as numpy arrays.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Custom metric corresponding to the provided labels and predictions.', '\n', 'Return type', '\n', 'float', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> defcustom_metric(label,pred):
... returnnp.mean(np.abs(label-pred))
...
>>> metric=mx.metric.np(custom_metric)
",,
"
mxnet.symbol.Activation(data=None, act_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies an activation function element-wise to the input.', '\n', 'The following activation functions are supported:', '\n', '\n', 'relu', '\n', 'sigmoid', '\n', 'tanh', '\n', 'softrelu', '\n', 'softsign', '\n', '\n', 'Defined in src/operator/nn/activation.cc:L164', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'A one-hidden-layer MLP with ReLU activation:', '\n', None, '\n', '\n', 'ReLU activation', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.BatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\nthe inverse of ', 'data_var', ', which are needed for the backward pass. Note that gradient of these\ntwo outputs are blocked.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is 1.  Specifying -1 sets the channel\naxis to be the last item in the input shape.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Note', '\n', 'When ', '\n', '\n', 'Defined in src/operator/nn/batch_norm.cc:L608', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.BatchNorm_v1(data=None, gamma=None, beta=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization.', '\n', 'This operator is DEPRECATED. Perform BatchNorm on the input.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', 'Thereâ\x80\x99s no sparse support for this operator, and it will exhibit problematic behavior if used with\nsparse tensors.', '\n', 'Defined in src/operator/batch_norm_v1.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.BilinearSampler(data=None, grid=None, cudnn_off=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies bilinear sampling to input feature map.', '\n', 'Bilinear Sampling is the key of  [NIPS2015] â\x80\x9cSpatial Transformer Networksâ\x80\x9d. The usage of the operator is very similar to remap function in OpenCV,\nexcept that the operator has the backward pass.', '\n', 'Given ', '\\(data\\)', ' and ', '\\(grid\\)', ', then the output is computed by', '\n', '\n\\[\\begin{split}x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\\\\ny_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\\\\noutput[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})\\end{split}\\]', '\n', '\\(x_{dst}\\)', ', ', '\\(y_{dst}\\)', ' enumerate all spatial locations in ', '\\(output\\)', ', and ', '\\(G()\\)', ' denotes the bilinear interpolation kernel.\nThe out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).', '\n', 'The operator assumes that ', '\\(data\\)', ' has â\x80\x98NCHWâ\x80\x99 layout and ', '\\(grid\\)', ' has been normalized to [-1, 1].', '\n', 'BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.\nGridGenerator supports two kinds of transformation: ', 'affine', ' and ', 'warp', '.\nIf users want to design a CustomOp to manipulate ', '\\(grid\\)', ', please firstly refer to the code of GridGenerator.', '\n', 'Example 1:', '\n', None, '\n', '\n', 'Example 2:', '\n', None, '\n', '\n', 'Defined in src/operator/bilinear_sampler.cc:L255', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.BlockGrad(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Cast(data=None, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Concat two (or more) inputs along a specific dimension:', '\n', None, '\n', '\n', 'Note the shape should be the same except on the dimension that is being\nconcatenated.', '\n', '\n']",,,
"
mxnet.symbol.Convolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute ', 'N', '-D convolution on ', '(N+2)', '-D input.', '\n', 'In the 2-D convolution, given input data with shape ', '(batch_size,\nchannel, height, width)', ', the output is computed by', '\n', '\n\\[out[n,i,:,:] = bias[i] + \\sum_{j=0}^{channel} data[n,j,:,:] \\star\nweight[i,j,:,:]\\]', '\n', 'where ', '\\(\\star\\)', ' is the 2-D cross-correlation operator.', '\n', 'For general 2-D convolution, the shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channel, height,\nwidth)', '. We can choose other layouts such as ', 'NWC', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concatenating all\nthe ', 'g', ' results.', '\n', '1-D convolution does not have ', 'height', ' dimension but only ', 'width', ' in space.', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', '3-D convolution adds an additional ', 'depth', ' dimension besides ', 'height', ' and\n', 'width', '. The shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'There are other options to tune the performance.', '\n', '\n', 'cudnn_tune', '\n', 'workspace', '\n', '\n', 'Defined in src/operator/nn/convolution.cc:L475', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Convolution_v1(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator is DEPRECATED. Apply convolution to input then add a bias.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Correlation(data1=None, data2=None, kernel_size=_Null, max_displacement=_Null, stride1=_Null, stride2=_Null, pad_size=_Null, is_multiply=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies correlation to inputs.', '\n', 'The correlation layer performs multiplicative patch comparisons between two feature maps.', '\n', 'Given two multi-channel feature maps ', '\\(f_{1}, f_{2}\\)', ', with ', '\\(w\\)', ', ', '\\(h\\)', ', and ', '\\(c\\)', ' being their width, height, and number of channels,\nthe correlation layer lets the network compare each patch from ', '\\(f_{1}\\)', ' with each patch from ', '\\(f_{2}\\)', '.', '\n', 'For now we consider only a single comparison of two patches. The â\x80\x98correlationâ\x80\x99 of two patches centered at ', '\\(x_{1}\\)', ' in the first map and\n', '\\(x_{2}\\)', ' in the second map is then defined as:', '\n', '\n\\[c(x_{1}, x_{2}) = \\sum_{o \\in [-k,k] \\times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\\]', '\n', 'for a square patch of size ', '\\(K:=2k+1\\)', '.', '\n', 'Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other\ndata. For this reason, it has no training weights.', '\n', 'Computing ', '\\(c(x_{1}, x_{2})\\)', ' involves ', '\\(c * K^{2}\\)', ' multiplications. Comparing all patch combinations involves ', '\\(w^{2}*h^{2}\\)', ' such computations.', '\n', 'Given a maximum displacement ', '\\(d\\)', ', for each location ', '\\(x_{1}\\)', ' it computes correlations ', '\\(c(x_{1}, x_{2})\\)', ' only in a neighborhood of size ', '\\(D:=2d+1\\)', ',\nby limiting the range of ', '\\(x_{2}\\)', '. We use strides ', '\\(s_{1}, s_{2}\\)', ', to quantize ', '\\(x_{1}\\)', ' globally and to quantize ', '\\(x_{2}\\)', ' within the neighborhood\ncentered around ', '\\(x_{1}\\)', '.', '\n', 'The final output is defined by the following expression:', '\n', '\n\\[out[n, q, i, j] = c(x_{i, j}, x_{q})\\]', '\n', 'where ', '\\(i\\)', ' and ', '\\(j\\)', ' enumerate spatial locations in ', '\\(f_{1}\\)', ', and ', '\\(q\\)', ' denotes the ', '\\(q^{th}\\)', ' neighborhood of ', '\\(x_{i,j}\\)', '.', '\n', 'Defined in src/operator/correlation.cc:L197', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Crop(*data, **kwargs)Â¶","['\n', 'Note', '\n', 'Crop', '\n', '\n', 'Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or\nwith width and height of the second input symbol, i.e., with one input, we need h_w to\nspecify the crop height and width, otherwise the second input symbolâ\x80\x99s size will be used', '\n', 'Defined in src/operator/crop.cc:L49\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Custom(*data, **kwargs)Â¶","['Apply a custom operator implemented in a frontend language (like Python).', '\n', 'Custom operators should override required methods like ', 'forward', ' and ', 'backward', '.\nThe custom operator must be registered before it can be used.\nPlease check the tutorial here: ', 'https://mxnet.incubator.apache.org/api/faq/new_op', '\n', 'Defined in src/operator/custom/custom.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Deconvolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, adj=_Null, target_shape=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Dropout(data=None, p=_Null, mode=_Null, axes=_Null, cudnn_off=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies dropout operation to input array.', '\n', '\n', 'During training, each element of the input is set to zero with probability p.\nThe whole array is rescaled by ', '\n', 'During testing, this operator does not change the input if mode is â\x80\x98trainingâ\x80\x99.\nIf mode is â\x80\x98alwaysâ\x80\x99, the same computaion as during training will be applied.', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/dropout.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Apply dropout to corrupt input as zero with probability 0.2:', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.ElementWiseSum(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Embedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'When â\x80\x9csparse_gradâ\x80\x9d is False, if any index mentioned is too large, it is replaced by the index that\naddresses the last vector in an embedding matrix.\nWhen â\x80\x9csparse_gradâ\x80\x9d is True, an error will be raised if invalid indices are found.', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of weight can be either row_sparse or default.', '\n', '\n', 'Note', '\n', 'If â\x80\x9csparse_gradâ\x80\x9d is set to True, the storage type of gradient w.r.t weights will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L597', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Assume we want to map the 26 English alphabet letters to 16-dimensional\nvectorial representations.', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.Flatten(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Flatten is usually applied before ', 'FullyConnected', ', to reshape the 4D tensor\nproduced by convolutional layers to 2D matrix:', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.FullyConnected(data=None, weight=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a linear transformation: ', '\\(Y = XW^T + b\\)', '.', '\n', 'If ', 'flatten', ' is set to be true, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'If ', 'flatten', ' is set to be false, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'The learnable parameters include both ', 'weight', ' and ', 'bias', '.', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', '\n', 'Note', '\n', 'The sparse support for FullyConnected is limited to forward evaluation with ', '\n', 'To compute linear transformation with â\x80\x98csrâ\x80\x99 sparse data, sparse.dot is recommended instead\nof sparse.FullyConnected.', '\n', '\n', 'Defined in src/operator/nn/fully_connected.cc:L286', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Construct a fully connected operator with target dimension 512.', '\n', None, '\n', '\n', 'A simple 3-layer MLP with ReLU activation:', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.GridGenerator(data=None, transform_type=_Null, target_shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generates 2D sampling grid for bilinear sampling.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.GroupNorm(data=None, gamma=None, beta=None, num_groups=_Null, eps=_Null, output_mean_var=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Group normalization.', '\n', 'The input channels are separated into ', 'num_groups', ' groups, each containing ', 'num_channels', ' channels.\nThe mean and standard-deviation are calculated separately over the each group.', '\n', '\n\\[data = data.reshape((N, num_groups, C // num_groups, ...))\nout = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Defined in src/operator/nn/group_norm.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.IdentityAttachKLSparseReg(data=None, sparseness_target=_Null, penalty=_Null, momentum=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply a sparse regularization to the output a sigmoid activation function.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.InstanceNorm(data=None, gamma=None, beta=None, eps=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies instance normalization to the n-dimensional input array.', '\n', 'This operator takes an n-dimensional input array where (n>2) and normalizes\nthe input using the following formula:', '\n', '\n\\[out = \\frac{x - mean[data]}{ \\sqrt{Var[data]} + \\epsilon} * gamma + beta\\]', '\n', 'This layer is similar to batch normalization layer (', 'BatchNorm', ')\nwith two differences: first, the normalization is\ncarried out per example (instance), not over a batch. Second, the\nsame normalization is applied both at test and train time. This\noperation is also known as ', 'contrast normalization', '.', '\n', 'If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, â\x80¦],\n', 'gamma', ' and ', 'beta', ' parameters must be vectors of shape [channel].', '\n', 'This implementation is based on this paper ', '1', '\n', '\n', '1', '\n', 'Instance Normalization: The Missing Ingredient for Fast Stylization,\nD. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/instance_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.L2Normalization(data=None, eps=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Normalize the input array using the L2 norm.', '\n', 'For 1-D NDArray, it computes:', '\n', None, '\n', '\n', 'For N-D NDArray, if the input array has shape (N, N, â\x80¦, N),', '\n', 'with ', 'mode', ' = ', 'instance', ', it normalizes each instance in the multidimensional\narray by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'channel', ', it normalizes each channel in the array by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'spatial', ', it normalizes the cross channel norm for each position\nin the array by its L2 norm.:', '\n', None, '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/l2_normalization.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.LRN(data=None, alpha=_Null, beta=_Null, knorm=_Null, nsize=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies local response normalization to the input.', '\n', 'The local response normalization layer performs â\x80\x9clateral inhibitionâ\x80\x9d by normalizing\nover local input regions.', '\n', 'If ', '\\(a_{x,y}^{i}\\)', ' is the activity of a neuron computed by applying kernel ', '\\(i\\)', ' at position\n', '\\((x, y)\\)', ' and then applying the ReLU nonlinearity, the response-normalized\nactivity ', '\\(b_{x,y}^{i}\\)', ' is given by the expression:', '\n', '\n\\[b_{x,y}^{i} = \\frac{a_{x,y}^{i}}{\\Bigg({k + \\frac{\\alpha}{n} \\sum_{j=max(0, i-\\frac{n}{2})}^{min(N-1, i+\\frac{n}{2})} (a_{x,y}^{j})^{2}}\\Bigg)^{\\beta}}\\]', '\n', 'where the sum runs over ', '\\(n\\)', ' â\x80\x9cadjacentâ\x80\x9d kernel maps at the same spatial position, and ', '\\(N\\)', ' is the total\nnumber of kernels in the layer.', '\n', 'Defined in src/operator/nn/lrn.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.LayerNorm(data=None, gamma=None, beta=None, axis=_Null, eps=_Null, output_mean_var=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Layer normalization.', '\n', 'Normalizes the channels of the input tensor by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis and then\ncompute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Unlike BatchNorm and InstanceNorm,  the ', 'mean', ' and ', 'var', ' are computed along the channel dimension.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_std', '. Note that no gradient will be passed through these two outputs.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is -1, which sets the channel\naxis to be the last item in the input shape.', '\n', 'Defined in src/operator/nn/layer_norm.cc:L201', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.LeakyReLU(data=None, gamma=None, act_type=_Null, slope=_Null, lower_bound=_Null, upper_bound=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies Leaky rectified linear unit activation element-wise to the input.', '\n', 'Leaky ReLUs attempt to fix the â\x80\x9cdying ReLUâ\x80\x9d problem by allowing a small ', 'slope', '\nwhen the input is negative and has a slope of one when input is positive.', '\n', 'The following modified ReLU Activation functions are supported:', '\n', '\n', 'elu', '\n', 'selu', '\n', 'leaky', '\n', 'prelu', '\n', 'rrelu', '\n', '\n', 'Defined in src/operator/leaky_relu.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.LinearRegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes and optimizes for squared loss during backward propagation.\nJust outputs ', 'data', ' during forward propagation.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the squared loss estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{SquaredLoss}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert  \\textbf{y}_i - \\hat{\\textbf{y}}_i  \\rVert_2\\)', '\n', '\n', 'Note', '\n', 'Use the LinearRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LinearRegressionOutput(default, default) = default', '\n', 'LinearRegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.LogisticRegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a logistic function to the input.', '\n', 'The logistic function, also known as the sigmoid function, is computed as\n', '\\(\\frac{1}{1+exp(-\\textbf{x})}\\)', '.', '\n', 'Commonly, the sigmoid is used to squash the real-valued output of a linear model\n', '\\(wTx+b\\)', ' into the [0,1] range so that it can be interpreted as a probability.\nIt is suitable for binary classification or probability prediction tasks.', '\n', '\n', 'Note', '\n', 'Use the LogisticRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LogisticRegressionOutput(default, default) = default', '\n', 'LogisticRegressionOutput(default, csr) = default', '\n', '\n', 'The loss function used is the Binary Cross Entropy Loss:', '\n', '\\(-{(y\\log(p) + (1 - y)\\log(1 - p))}\\)', '\n', 'Where ', 'y', ' is the ground truth probability of positive outcome for a given example, and ', 'p', ' the probability predicted by the model. By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L152', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.MAERegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes mean absolute error of the input.', '\n', 'MAE is a risk metric corresponding to the expected value of the absolute error.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the mean absolute error (MAE) estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{MAE}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert \\textbf{y}_i - \\hat{\\textbf{y}}_i \\rVert_1\\)', '\n', '\n', 'Note', '\n', 'Use the MAERegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'MAERegressionOutput(default, default) = default', '\n', 'MAERegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L120', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.MakeLoss(data=None, grad_scale=_Null, valid_thresh=_Null, normalization=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'MakeLoss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'In addition, we can give a scale to the loss by setting ', 'grad_scale', ',\nso that the gradient of the loss will be rescaled in the backpropagation.', '\n', '\n', 'Note', '\n', 'This operator should be used as a Symbol instead of NDArray.', '\n', '\n', 'Defined in src/operator/make_loss.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Pooling(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs pooling on the input.', '\n', 'The shapes for 1-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The shapes for 2-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'When ', 'global_pool', ' is set to be true, then global pooling is performed. It will reset\n', 'kernel=(height,', ' and set the appropiate padding to 0.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', 'lp', '\n', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data and output will have shape ', '(batch_size, channel, depth,\nheight, width)', ' (NCDHW layout) or ', '(batch_size, depth, height, width, channel)', ' (NDHWC layout).', '\n', 'Notes on Lp pooling:', '\n', 'Lp pooling was first introduced by this paper: ', 'https://arxiv.org/pdf/1204.3968.pdf', '.\nL-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.\nWe can see that Lp pooling stands between those two, in practice the most common value for p is 2.', '\n', 'For each window ', 'X', ', the mathematical expression for Lp pooling is:', '\n', '\\(f(X) = \\sqrt[p]{\\sum_{x}^{X} x^p}\\)', '\n', 'Defined in src/operator/nn/pooling.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Pooling_v1(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator is DEPRECATED.\nPerform pooling on the input.', '\n', 'The shapes for 2-D pooling is', '\n', '\n', 'data', '\n', 'out', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'But ', 'global_pool', ' is set to be true, then do a global pooling, namely reset\n', 'kernel=(height,', '.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', '\n', '1-D pooling is special case of 2-D pooling with ', 'weight=1', ' and\n', 'kernel[1]=1', '.', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data will have shape ', '(batch_size, channel, depth,\nheight, width)', '.', '\n', 'Defined in src/operator/pooling_v1.cc:L103', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.RNN(data=None, parameters=None, state=None, state_cell=None, sequence_length=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are\nimplemented, with both multi-layer and bidirectional support.', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', 'Vanilla RNN', '\n', 'Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:\nReLU and Tanh.', '\n', 'With ReLU activation function:', '\n', '\n\\[h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'With Tanh activtion function:', '\n', '\n\\[h_t = \\tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'Reference paper: Finding structure in time - Elman, 1988.\n', 'https://crl.ucsd.edu/~elman/Papers/fsit.pdf', '\n', 'LSTM', '\n', 'Long Short-Term Memory - Hochreiter, 1997. ', 'http://www.bioinf.jku.at/publications/older/2604.pdf', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          \\end{array}\\end{split}\\]', '\n', 'With the projection size being set, LSTM could use the projection feature to reduce the parameters\nsize and give some speedups without significant damage to the accuracy.', '\n', 'Long Short-Term Memory Based Recurrent Neural Network Architectures for Large Vocabulary Speech\nRecognition - Sak et al. 2014. ', 'https://arxiv.org/abs/1402.1128', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{ri} r_{(t-1)} + b_{ri}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{rf} r_{(t-1)} + b_{rf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{rc} r_{(t-1)} + b_{rg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{o} + W_{ro} r_{(t-1)} + b_{ro}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          r_t = W_{hr} h_t\n          \\end{array}\\end{split}\\]', '\n', 'GRU', '\n', 'Gated Recurrent Unit - Cho et al. 2014. ', 'http://arxiv.org/abs/1406.1078', '\n', 'The definition of GRU here is slightly different from paper but compatible with CUDNN.', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          r_t = \\mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\\\\n          z_t = \\mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\\\\n          n_t = \\tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\\\\n          h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\\\\n          \\end{array}\\end{split}\\]', '\n', 'Defined in src/operator/rnn.cc:L375', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ROIPooling(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs region of interest(ROI) pooling on the input array.', '\n', 'ROI pooling is a variant of a max pooling layer, in which the output size is fixed and\nregion of interest is a parameter. Its purpose is to perform max pooling on the inputs\nof non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net\nlayer mostly used in training a ', 'Fast R-CNN', ' network for object detection.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen it pools over sub-regions of input and produces a fixed-sized output array\nregardless of the ROI size.', '\n', 'To crop the feature map accordingly, you can resize the bounding box coordinates\nby changing the parameters ', 'rois', ' and ', 'spatial_scale', '.', '\n', 'The cropped feature maps are pooled by standard max pooling operation to a fixed size output\nindicated by a ', 'pooled_size', ' parameter. batch_size will change to the number of region\nbounding boxes after ', 'ROIPooling', '.', '\n', 'The size of each region of interest doesnâ\x80\x99t have to be perfectly divisible by\nthe number of pooling sections(', 'pooled_size', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/roi_pooling.cc:L224', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SVMOutput(data=None, label=None, margin=_Null, regularization_coefficient=_Null, use_linear=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes support vector machine based transformation of the input.', '\n', 'This tutorial demonstrates using SVM as output layer for classification instead of softmax:\n', 'https://github.com/apache/mxnet/tree/v1.x/example/svm_mnist', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SequenceLast(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Takes the last element of a sequence.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array\nof the form [batch_size, other_feature_dims].', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', ' should be\nan input array of positive ints of dimension [batch_size]. To use this parameter,\nset ', 'use_sequence_length', ' to ', 'True', ', otherwise each example in the batch is assumed\nto have the max sequence length.', '\n', '\n', 'Note', '\n', 'Alternatively, you can also use ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_last.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SequenceMask(data=None, sequence_length=None, use_sequence_length=_Null, value=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Sets all elements outside the sequence to a constant value.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', '\nshould be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length and\nthis operator works as the ', 'identity', ' operator.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_mask.cc:L185', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SequenceReverse(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reverses the elements of each sequence.', '\n', 'This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]\nand returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences.\n', 'sequence_length', ' should be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_reverse.cc:L121', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SliceChannel(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.Softmax(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SoftmaxActivation(data=None, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies softmax activation to input. This is intended for internal layers.', '\n', '\n', 'Note', '\n', 'This operator has been deprecated, please use ', '\n', '\n', 'If ', 'mode', ' = ', 'instance', ', this operator will compute a softmax for each instance in the batch.\nThis is the default mode.', '\n', 'If ', 'mode', ' = ', 'channel', ', this operator will compute a k-class softmax at each position\nof each instance, where ', 'k', ' = ', 'num_channel', '. This mode can only be used when the input array\nhas at least 3 dimensions.\nThis can be used for ', 'fully convolutional network', ', ', 'image segmentation', ', etc.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax_activation.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SoftmaxOutput(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SpatialTransformer(data=None, loc=None, target_shape=_Null, transform_type=_Null, sampler_type=_Null, cudnn_off=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a spatial transformer to input feature map.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.SwapAxis(data=None, dim1=_Null, dim2=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.UpSampling(*data, **kwargs)Â¶","['Upsamples the given input data.', '\n', 'Two algorithms (', 'sample_type', ') are available for upsampling:', '\n', '\n', 'Nearest Neighbor', '\n', 'Bilinear', '\n', '\n', 'Nearest Neighbor Upsampling', '\n', 'Input data is expected to be NCHW.', '\n', 'Example:', '\n', None, '\n', '\n', 'Bilinear Upsampling', '\n', 'Uses ', 'deconvolution', ' algorithm under the hood. You need provide both input data and the kernel.', '\n', 'Input data is expected to be NCHW.', '\n', 'num_filter', ' is expected to be same as the number of channels.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/upsampling.cc:L172\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.abs(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise absolute value of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'abs', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L720', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.adam_update(weight=None, grad=None, mean=None, var=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Adam optimizer. Adam is seen as a generalization\nof AdaGrad.', '\n', 'Adam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nW_t = W_{t-1} - \\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon }\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and the storage\ntype of weight is the same as those of m and v,\nonly the row slices whose indices appear in grad.indices are updated (for w, m and v):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L687', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.add_n(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.all_finite(data=None, init_output=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Check if all the float numbers in the array are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.amp_cast(data=None, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Cast function between low precision float/FP32 used by AMP.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L125', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.amp_multicast(*data, **kwargs)Â¶","['Cast function used by AMP, that casts its inputs to the common widest type.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L169', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.arccos(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse cosine of the input array.', '\n', 'The input should be in range ', '[-1, 1]', '.\nThe output is in the closed interval ', '\\([0, \\pi]\\)', '\n', '\n\\[arccos([-1, -.707, 0, .707, 1]) = [\\pi, 3\\pi/4, \\pi/2, \\pi/4, 0]\\]', '\n', 'The storage type of ', 'arccos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.arccosh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arccosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L535', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.arcsin(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse sine of the input array.', '\n', 'The input should be in the range ', '[-1, 1]', '.\nThe output is in the closed interval of [', '\\(-\\pi/2\\)', ', ', '\\(\\pi/2\\)', '].', '\n', '\n\\[arcsin([-1, -.707, 0, .707, 1]) = [-\\pi/2, -\\pi/4, 0, \\pi/4, \\pi/2]\\]', '\n', 'The storage type of ', 'arcsin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.arcsinh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arcsinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.arctan(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse tangent of the input array.', '\n', 'The output is in the closed interval ', '\\([-\\pi/2, \\pi/2]\\)', '\n', '\n\\[arctan([-1, 0, 1]) = [-\\pi/4, 0, \\pi/4]\\]', '\n', 'The storage type of ', 'arctan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L282', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.arctanh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.', '\n', 'The storage type of ', 'arctanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L579', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.argmax(data=None, axis=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns indices of the maximum values along an axis.', '\n', 'In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L51', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.argmax_channel(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns argmax indices of each channel from the input array.', '\n', 'The result will be an NDArray of shape (num_channel,).', '\n', 'In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.argmin(data=None, axis=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns indices of the minimum values along an axis.', '\n', 'In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.argsort(data=None, axis=_Null, is_ascend=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the indices that would sort an input array along the given axis.', '\n', 'This function performs sorting along the given axis and returns an array of indices having same shape\nas an input array that index data in sorted order.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L184', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.batch_dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batchwise dot product.', '\n', 'batch_dot', ' is used to compute dot product of ', 'x', ' and ', 'y', ' when ', 'x', ' and\n', 'y', ' are data in batch, namely N-D (N >= 3) arrays in shape of ', '(B0, â\x80¦, B_i, :, :)', '.', '\n', 'For example, given ', 'x', ' with shape ', '(B_0, â\x80¦, B_i, N, M)', ' and ', 'y', ' with shape\n', '(B_0, â\x80¦, B_i, M, K)', ', the result array will have shape ', '(B_0, â\x80¦, B_i, N, K)', ',\nwhich is computed by:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L127', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.batch_take(a=None, indices=None, name=None, attr=None, out=None, **kwargs)Â¶","['Takes elements from a data batch.', '\n', '\n', 'Note', '\n', 'batch_take', '\n', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_add(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_axes(data=None, axis=_Null, size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_axis(data=None, axis=_Null, size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_div(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_div(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'equal to', ' (==) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L45', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_greater(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than', ' (>) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L81', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_greater_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than or equal to', ' (>=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_hypot(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hypotenuse of a right angled triangle, given its â\x80\x9clegsâ\x80\x9d\nwith broadcasting.', '\n', 'It is equivalent to doing ', '\\(sqrt(x_1^2 + x_2^2)\\)', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_lesser(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than', ' (<) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L117', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_lesser_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than or equal to', ' (<=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_like(lhs=None, rhs=None, lhs_axes=_Null, rhs_axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts lhs to have the same shape as rhs.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_logical_and(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical and', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_logical_or(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical or', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L171', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_logical_xor(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical xor', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L189', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_maximum(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise maximum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise maxima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_minimum(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise minimum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise minima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_minus(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_mod(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise modulo of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_mul(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_mul(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L145', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_not_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'not equal to', ' (!=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L63', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_plus(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_power(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns result of first array elements raised to powers from second array, element-wise with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L44', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_sub(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.broadcast_to(data=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts the input array to a new shape.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'The dimension which you do not want to change can also be kept as ', '0', ' which means copy the original value.\nSo with ', 'shape=(2,0)', ', we will obtain the same result as in the above example.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.cast(data=None, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.cast_storage(data=None, stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Casts tensor storage type to the new type.', '\n', 'When an NDArray with default storage type is cast to csr or row_sparse storage,\nthe result is compact, which means:', '\n', '\n', 'for csr, zero values will not be retained', '\n', 'for row_sparse, row slices of all zeros will not be retained', '\n', '\n', 'The storage type of ', 'cast_storage', ' output depends on stype parameter:', '\n', '\n', 'cast_storage(csr, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(row_sparse, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(default, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(default, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', 'cast_storage(csr, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(row_sparse, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/cast_storage.cc:L71', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.cbrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise cube-root value of the input.', '\n', '\n\\[cbrt(x) = \\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'cbrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L270', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ceil(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise ceiling of the input.', '\n', 'The ceil of the scalar x is the smallest integer i, such that i >= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'ceil', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L817', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.choose_element_0index(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.clip(data=None, a_min=_Null, a_max=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Clips (limits) the values in an array.\nGiven an interval, values outside the interval are clipped to the interval edges.\nClipping ', 'x', ' between ', 'a_min', ' and ', 'a_max', ' would be::\n.. math:', '\n', None, '\n', '\n', '\n', 'Example::', 'x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nclip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]', '\n', '\n', 'The storage type of ', 'clip', ' output depends on storage types of inputs and the a_min, a_max parameter values:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L676', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.col2im(data=None, output_size=_Null, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Combining the output column matrix of im2col back to image array.', '\n', 'Like ', 'im2col', ', this operator is also used in the vanilla convolution\nimplementation. Despite the name, col2im is not the reverse operation of im2col. Since there\nmay be overlaps between neighbouring sliding blocks, the column elements cannot be directly\nput back into image. Instead, they are accumulated (i.e., summed) in the input image\njust like the gradient computation, so col2im is the gradient of im2col and vice versa.', '\n', 'Using the notation in im2col, given an input column array of shape\n', '\\((N, C \\times  \\prod(\\text{kernel}), W)\\)', ', this operator accumulates the column elements\ninto output array of shape ', '\\((N, C, \\text{output_size}[0], \\text{output_size}[1], \\dots)\\)', '.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L181', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.cos(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise cosine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[cos([0, \\pi/4, \\pi/2]) = [1, 0.707, 0]\\]', '\n', 'The storage type of ', 'cos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.cosh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic cosine  of the input array, computed element-wise.', '\n', '\n\\[cosh(x) = 0.5\\times(exp(x) + exp(-x))\\]', '\n', 'The storage type of ', 'cosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L409', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.crop(data=None, begin=_Null, end=_Null, step=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.cumsum(a=None, axis=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Return the cumulative sum of the elements along a given axis.', '\n', 'Defined in src/operator/numpy/np_cumsum.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.degrees(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Converts each element of the input array from radians to degrees.', '\n', '\n\\[degrees([0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]) = [0, 90, 180, 270, 360]\\]', '\n', 'The storage type of ', 'degrees', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.depth_to_space(data=None, block_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Rearranges(permutes) data from depth into blocks of spatial data.\nSimilar to ONNX DepthToSpace operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace', '.\nThe output is a new tensor where the values from depth dimension are moved in spatial blocks\nto height and width dimension. The reverse of this operation is ', 'space_to_depth', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C / (block\\_size ^ 2), H * block\\_size, W * block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L971', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.diag(data=None, k=_Null, axis1=_Null, axis2=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts a diagonal or constructs a diagonal array.', '\n', 'diag', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.', '\n', 'N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/diag_op.cc:L86', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Dot product of two arrays.', '\n', 'dot', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: inner product of vectors', '\n', '2-D arrays: matrix multiplication', '\n', 'N-D arrays: a sum product over the last axis of the first input and the first\naxis of the second input', '\n', '\n', 'The storage type of ', 'dot', ' output depends on storage types of inputs, transpose option and\nforward_stype option for output storage type. Implemented sparse operations include:', '\n', '\n', 'dot(default, default, transpose_a=True/False, transpose_b=True/False) = default', '\n', 'dot(csr, default, transpose_a=True) = default', '\n', 'dot(csr, default, transpose_a=True) = row_sparse', '\n', 'dot(csr, default) = default', '\n', 'dot(csr, row_sparse) = default', '\n', 'dot(default, csr) = csr (CPU only)', '\n', 'dot(default, csr, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', 'dot(default, csr, transpose_b=True, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', '\n', 'If the combination of input storage types and forward_stype does not match any of the\nabove patterns, ', 'dot', ' will fallback and generate output with default storage.', '\n', '\n', 'Note', '\n', 'If the storage type of the lhs is â\x80\x9ccsrâ\x80\x9d, the storage type of gradient w.r.t rhs will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.elemwise_add(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Adds arguments element-wise.', '\n', 'The storage type of ', 'elemwise_add', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.elemwise_div(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Divides arguments element-wise.', '\n', 'The storage type of ', 'elemwise_div', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.elemwise_mul(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplies arguments element-wise.', '\n', 'The storage type of ', 'elemwise_mul', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.elemwise_sub(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Subtracts arguments element-wise.', '\n', 'The storage type of ', 'elemwise_sub', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.erf(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L886', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.erfinv(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L908', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.exp(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise exponential value of the input.', '\n', '\n\\[exp(x) = e^x \\approx 2.718^x\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'exp', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L64', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.expand_dims(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Inserts a new axis of size 1 into the array shape\nFor example, given ', 'x', ' with shape ', '(2,3,4)', ', then ', 'expand_dims(x,', '\nwill return a new array with shape ', '(2,1,3,4)', '.', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L394', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.expm1(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns ', 'exp(x)', ' computed element-wise on the input.', '\n', 'This function provides greater precision than ', 'exp(x)', ' for small values of ', 'x', '.', '\n', 'The storage type of ', 'expm1', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.fill_element_0index(lhs=None, mhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.fix(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer towards zero of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'fix', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L874', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.flatten(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.flip(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.floor(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise floor of the input.', '\n', 'The floor of the scalar x is the largest integer i, such that i <= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'floor', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L836', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ftml_update(weight=None, grad=None, d=None, v=None, z=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, wd=_Null, rescale_grad=_Null, clip_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['The FTML optimizer described in\n', 'FTML - Follow the Moving Leader in Deep Learning', ',\navailable at ', 'http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf', '.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nd_t = \\frac{ 1 - \\beta_1^t }{ \\eta_t } (\\sqrt{ \\frac{ v_t }{ 1 - \\beta_2^t } } + \\epsilon)\n\\sigma_t = d_t - \\beta_1 d_{t-1}\nz_t = \\beta_1 z_{ t-1 } + (1 - \\beta_1^t) g_t - \\sigma_t W_{t-1}\nW_t = - \\frac{ z_t }{ d_t }\\end{split}\\]', '\n', 'Defined in src/operator/optimizer_op.cc:L639', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ftrl_update(weight=None, grad=None, z=None, n=None, lr=_Null, lamda1=_Null, beta=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Ftrl optimizer.\nReferenced from ', 'Ad Click Prediction: a View from the Trenches', ', available at\n', 'http://dl.acm.org/citation.cfm?id=2488200', '.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'If w, z and n are all of ', 'row_sparse', ' storage type,\nonly the row slices whose indices appear in grad.indices are updated (for w, z and n):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L875', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.gamma(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.', '\n', 'The storage type of ', 'gamma', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.gammaln(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise log of the absolute value of the gamma function of the input.', '\n', 'The storage type of ', 'gammaln', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.gather_nd(data=None, indices=None, name=None, attr=None, out=None, **kwargs)Â¶","['Gather elements or slices from ', 'data', ' and store to a tensor whose\nshape is defined by ', 'indices', '.', '\n', 'Given ', 'data', ' with shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', output shape will simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.hard_sigmoid(data=None, alpha=_Null, beta=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes hard sigmoid of x element-wise.', '\n', '\n\\[y = max(0, min(1, alpha * x + beta))\\]', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L161', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.identity(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a copy of the input.', '\n', 'From:src/operator/tensor/elemwise_unary_op_basic.cc:244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.im2col(data=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extract sliding blocks from input array.', '\n', 'This operator is used in vanilla convolution implementation to transform the sliding\nblocks on image to column matrix, then the convolution operation can be computed\nby matrix multiplication between column and convolution weight. Due to the close\nrelation between im2col and convolution, the concept of ', 'kernel', ', ', 'stride', ',\n', 'dilate', ' and ', 'pad', ' in this operator are inherited from convolution operation.', '\n', 'Given the input data of shape ', '\\((N, C, *)\\)', ', where ', '\\(N\\)', ' is the batch size,\n', '\\(C\\)', ' is the channel size, and ', '\\(*\\)', ' is the arbitrary spatial dimension,\nthe output column array is always with shape ', '\\((N, C \\times \\prod(\\text{kernel}), W)\\)', ',\nwhere ', '\\(C \\times \\prod(\\text{kernel})\\)', ' is the block size, and ', '\\(W\\)', ' is the\nblock number which is the spatial size of the convolution output with same input parameters.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.khatri_rao(*args, **kwargs)Â¶","['Computes the Khatri-Rao product of the input matrices.', '\n', 'Given a collection of ', '\\(n\\)', ' input matrices,', '\n', '\n\\[A_1 \\in \\mathbb{R}^{M_1 \\times M}, \\ldots, A_n \\in \\mathbb{R}^{M_n \\times N},\\]', '\n', 'the (column-wise) Khatri-Rao product is defined as the matrix,', '\n', '\n\\[X = A_1 \\otimes \\cdots \\otimes A_n \\in \\mathbb{R}^{(M_1 \\cdots M_n) \\times N},\\]', '\n', 'where the ', '\\(k\\)', ' th column is equal to the column-wise outer product\n', '\\({A_1}_k \\otimes \\cdots \\otimes {A_n}_k\\)', ' where ', '\\({A_i}_k\\)', ' is the kth\ncolumn of the ith matrix.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/krprod.cc:L108\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.lamb_update_phase1(weight=None, grad=None, mean=None, var=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Phase I of lamb update it performs the following operations and returns g:.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\ngrad = grad * rescale_grad\nif (grad < -clip_gradient)\nthen\n     grad = -clip_gradient\nif (grad > clip_gradient)\nthen\n     grad = clip_gradient\\\\mean = beta1 * mean + (1 - beta1) * grad;\nvariance = beta2 * variance + (1. - beta2) * grad ^ 2;\\\\if (bias_correction)\nthen\n     mean_hat = mean / (1. - beta1^t);\n     var_hat = var / (1 - beta2^t);\n     g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;\nelse\n     g = mean / (var_data^(1/2) + epsilon) + wd * weight;\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L952', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.lamb_update_phase2(weight=None, g=None, r1=None, r2=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Phase II of lamb update it performs the following operations and updates grad.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\nif (lower_bound >= 0)\nthen\n     r1 = max(r1, lower_bound)\nif (upper_bound >= 0)\nthen\n     r1 = max(r1, upper_bound)\\\\if (r1 == 0 or r2 == 0)\nthen\n     lr = lr\nelse\n     lr = lr * (r1/r2)\nweight = weight - lr * g\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L991', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_det(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'det', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'There is no gradient backwarded when A is non-invertible (which is\nequivalent to det(A) = 0) because zero is rarely hit upon in float\npoint computation and the Jacobiâ\x80\x99s formula on determinant gradient\nis not computationally efficient when A is non-invertible.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L974', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_extractdiag(A=None, offset=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts the diagonal entries of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an ', 'n-1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_extracttrian(A=None, offset=_Null, lower=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts a triangular sub-matrix from a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an ', 'n-1', '-dimensional tensor.', '\n', 'The ', 'offset', ' and ', 'lower', ' parameters determine the triangle to be extracted:', '\n', '\n', 'When ', '\n', 'When ', '\n', 'When ', '\n', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L604', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_gelqf(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['LQ factorization for general matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', we compute the LQ factorization (LAPACK ', 'gelqf', ', followed by ', 'orglq', '). ', 'A', '\nmust have shape ', '(x, y)', ' with ', 'x <= y', ', and must have full rank ', '=x', '. The LQ\nfactorization consists of ', 'L', ' with shape ', '(x, x)', ' and ', 'Q', ' with shape ', '(x, y)', ', so\nthat:', '\n', '\n', 'A', '\n', 'Here, ', 'L', ' is lower triangular (upper triangle equal to zero) with nonzero diagonal,\nand ', 'Q', ' is row-orthonormal, meaning that', '\n', '\n', 'Q', '\n', 'is equal to the identity matrix of shape ', '(x, x)', '.', '\n', 'If ', 'n>2', ', ', 'gelqf', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L797', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_gemm(A=None, B=None, C=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, beta=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs general matrix multiplication and accumulation.\nInput are tensors ', 'A', ', ', 'B', ', ', 'C', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here, ', 'alpha', ' and ', 'beta', ' are scalar parameters, and ', 'op()', ' is either the identity or\nmatrix transposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ', ', 'C', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', ', 'C', ', axis=1) is equivalent\nto the following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_gemm2(A=None, B=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs general matrix multiplication.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here ', 'alpha', ' is a scalar parameter and ', 'op()', ' is either the identity or the matrix\ntransposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', axis=1) is equivalent to\nthe following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_inverse(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the inverse of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'inverse', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L919', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_makediag(A=None, offset=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Constructs a square matrix with the input as diagonal.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.\nIf ', 'n>1', ', then ', 'A', ' represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_maketrian(A=None, offset=_Null, lower=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Constructs a square matrix with the input representing a specific triangular sub-matrix.\nThis is basically the inverse of ', 'linalg.extracttrian', '. Input is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the entries of a triangular matrix which is lower triangular if ', 'offset<0', ' or ', 'offset=0', ', ', 'lower=true', '. The resulting matrix is derived by first constructing the square\nmatrix with the entries outside the triangle set to zero and then adding ', 'offset', '-times an additional\ndiagonal with zero entries to the square matrix.', '\n', 'If ', 'n>1', ', then ', 'A', ' represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L672', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_potrf(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Performs Cholesky factorization of a symmetric positive-definite matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the Cholesky factor ', 'B', ' of the symmetric, positive definite matrix ', 'A', ' is\ncomputed. ', 'B', ' is triangular (entries of upper or lower triangle are all zero), has\npositive diagonal entries, and:', '\n', '\n', 'A', '\n', 'If ', 'n>2', ', ', 'potrf', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_potri(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Performs matrix inversion from a Cholesky factorization.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a triangular matrix (entries of upper or lower triangle are all zero)\nwith positive diagonal. We compute:', '\n', '\n', 'out', '\n', 'In other words, if ', 'A', ' is the Cholesky factor of a symmetric positive definite matrix\n', 'B', ' (obtained by ', 'potrf', '), then', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'potri', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Use this operator only if you are certain you need the inverse of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L274', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_slogdet(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the sign and log of the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'sign', '\n', 'If ', 'n>2', ', ', 'slogdet', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'The gradient is not properly defined on sign, so the gradient of\nit is not backwarded.', '\n', '\n', '\n', 'Note', '\n', 'No gradient is backwarded when A is non-invertible. Please see\nthe docs of operator det for detail.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L1033', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_sumlogdiag(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of the logarithms of the diagonal elements of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be square with positive diagonal entries. We sum the natural\nlogarithms of the diagonal elements, the result has shape (1,).', '\n', 'If ', 'n>2', ', ', 'sumlogdiag', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L444', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_syrk(A=None, transpose=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplication of matrix with its transpose.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the operator performs the BLAS3 function ', 'syrk', ':', '\n', '\n', 'out', '\n', 'if ', 'transpose=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'transpose=True', '.', '\n', 'If ', 'n>2', ', ', 'syrk', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L729', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_trmm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs multiplication with a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trmm', ':', '\n', '\n', 'out', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trmm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg_trsm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Solves matrix equation involving a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trsm', ', solving for ', 'out', ' in:', '\n', '\n', 'op', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trsm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L395', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.log(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Natural logarithmic value of the input.', '\n', 'The natural logarithm is logarithm in base ', 'e', ', so that ', 'log(exp(x))', '\n', 'The storage type of ', 'log', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.log10(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Base-10 logarithmic value of the input.', '\n', '10**log10(x)', '\n', 'The storage type of ', 'log10', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.log1p(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise ', 'log(1', ' value of the input.', '\n', 'This function is more accurate than ', 'log(1', '  for small ', 'x', ' so that\n', '\\(1+x\\approx 1\\)', '\n', 'The storage type of ', 'log1p', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.log2(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Base-2 logarithmic value of the input.', '\n', '2**log2(x)', '\n', 'The storage type of ', 'log2', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.log_softmax(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the log softmax of the input.\nThis is equivalent to computing softmax followed by log.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.logical_not(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of logical NOT (!) function', '\n', 'Example', '\n', 'logical_not([-2., 0., 1.]) = [0., 1., 0.]', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.make_loss(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'make_loss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'The storage type of ', 'make_loss', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L358', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.max(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.max_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.mean(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the mean of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.min(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.min_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.moments(data=None, axes=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Calculate the mean and variance of ', 'data', '.', '\n', 'The mean and variance are calculated by aggregating the contents of data across axes.\nIf x is 1-D and axes = [0] this is just the mean and variance of a vector.', '\n', 'Example', '\n', 'x = [[1, 2, 3], [4, 5, 6]]\nmean, var = moments(data=x, axes=[0])\nmean = [2.5, 3.5, 4.5]\nvar = [2.25, 2.25, 2.25]\nmean, var = moments(data=x, axes=[1])\nmean = [2.0, 5.0]\nvar = [0.66666667, 0.66666667]\nmean, var = moments(data=x, axis=[0, 1])\nmean = [3.5]\nvar = [2.9166667]', '\n', 'Defined in src/operator/nn/moments.cc:L53', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.mp_lamb_update_phase1(weight=None, grad=None, mean=None, var=None, weight32=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Mixed Precision version of Phase I of lamb update\nit performs the following operations and returns g:.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1032', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.mp_lamb_update_phase2(weight=None, g=None, r1=None, r2=None, weight32=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Mixed Precision version Phase II of lamb update\nit performs the following operations and updates grad.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1074', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.mp_nag_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.', '\n', 'Defined in src/operator/optimizer_op.cc:L744', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.mp_sgd_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.mp_sgd_update(weight=None, grad=None, weight32=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.multi_all_finite(*data, **kwargs)Â¶","['Check if all the float numbers in all the arrays are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.multi_lars(lrs=None, weights_sum_sq=None, grads_sum_sq=None, wds=None, eta=_Null, eps=_Null, rescale_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the LARS coefficients of multiple weights and grads from their sums of squareâ\x80\x9d', '\n', 'Defined in src/operator/contrib/multi_lars.cc:L36', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L471', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L373', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L328', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.multi_sum_sq(*data, **kwargs)Â¶","['Compute the sums of squares of multiple arrays', '\n', 'Defined in src/operator/contrib/multi_sum_sq.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.nag_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Nesterov Accelerated Gradient( NAG) optimizer.\nIt updates the weights using the following formula,', '\n', '\n\\[\\begin{split}v_t = \\gamma v_{t-1} + \\eta * \\nabla J(W_{t-1} - \\gamma v_{t-1})\\\\\nW_t = W_{t-1} - v_t\\end{split}\\]', '\n', 'Where\n', '\\(\\eta\\)', ' is the learning rate of the optimizer\n', '\\(\\gamma\\)', ' is the decay rate of the momentum estimate\n', '\\(\\v_t\\)', ' is the update vector at time step ', 't', '\n', '\\(\\W_t\\)', ' is the weight vector at time step ', 't', '\n', 'Defined in src/operator/optimizer_op.cc:L725', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.nanprod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the product of array elements over given axes treating Not a Numbers (', 'NaN', ') as one.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_prod_value.cc:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.nansum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of array elements over given axes treating Not a Numbers (', 'NaN', ') as zero.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.negative(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Numerical negative of the argument, element-wise.', '\n', 'The storage type of ', 'negative', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.norm(data=None, ord=_Null, axis=_Null, out_dtype=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the norm on an NDArray.', '\n', 'This operator computes the norm on an NDArray with the specified axis, depending\non the value of the ord parameter. By default, it computes the L2 norm on the entire\narray. Currently only ord=2 supports sparse ndarrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_norm_value.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.one_hot(indices=None, depth=_Null, on_value=_Null, off_value=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a one-hot array.', '\n', 'The locations represented by ', 'indices', ' take value ', 'on_value', ', while all\nother locations take value ', 'off_value', '.', '\n', 'one_hot', ' operation with ', 'indices', ' of shape ', '(i0,', ' and ', 'depth', '  of ', 'd', ' would result\nin an output array of shape ', '(i0,', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L882', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ones_like(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return an array of ones with the same shape and type\nas the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.pick(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.preloaded_multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.preloaded_multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L139', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.preloaded_multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.preloaded_multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.prod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the product of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L30', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.radians(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Converts each element of the input array from degrees to radians.', '\n', '\n\\[radians([0, 90, 180, 270, 360]) = [0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]\\]', '\n', 'The storage type of ', 'radians', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L351', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_exponential(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from an exponential distribution.', '\n', 'Samples are distributed according to an exponential distribution parametrized by ', 'lambda', ' (rate).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_gamma(alpha=_Null, beta=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a gamma distribution.', '\n', 'Samples are distributed according to a gamma distribution parametrized by ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L124', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_generalized_negative_binomial(mu=_Null, alpha=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a generalized negative binomial distribution.', '\n', 'Samples are distributed according to a generalized negative binomial distribution parametrized by\n', 'mu', ' (mean) and ', 'alpha', ' (dispersion). ', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_negative_binomial(k=_Null, p=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a negative binomial distribution.', '\n', 'Samples are distributed according to a negative binomial distribution parametrized by\n', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure probability in each experiment).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L163', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_dirichlet(sample=None, alpha=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nDirichlet distributions with parameter ', 'alpha', '.', '\n', 'The shape of ', 'alpha', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'alpha', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'alpha', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L315', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_exponential(sample=None, lam=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nexponential distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L304', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_gamma(sample=None, alpha=None, beta=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (rate).', '\n', 'alpha', ' and ', 'beta', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'alpha', ' and ', 'beta', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'alpha', ' and ', 'beta', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L302', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_generalized_negative_binomial(sample=None, mu=None, alpha=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean)\nand ', 'alpha', ' (dispersion).  This can be understood as a reparameterization of\nthe negative binomial, where ', 'k', ' = ', '1 / alpha', ' and ', 'p', ' = ', '1 / (mu * alpha + 1)', '.', '\n', 'mu', ' and ', 'alpha', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'alpha', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'alpha', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L313', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_negative_binomial(sample=None, k=None, p=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of samples of\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'k', ' and ', 'p', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'k', ' and ', 'p', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'k', ' and ', 'p', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L309', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_normal(sample=None, mu=None, sigma=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'mu', ' and ', 'sigma', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'sigma', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'sigma', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L299', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_poisson(sample=None, lam=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nPoisson distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L306', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_pdf_uniform(sample=None, low=None, high=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'low', ' and ', 'high', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'low', ' and ', 'high', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'low', ' and ', 'high', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L297', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_poisson(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a Poisson distribution.', '\n', 'Samples are distributed according to a Poisson distribution parametrized by ', 'lambda', ' (rate).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L149', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_randint(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a discrete uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L193', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random_uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ravel_multi_index(data=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.rcbrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse cube-root value of the input.', '\n', '\n\\[rcbrt(x) = 1/\\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L323', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.reciprocal(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the reciprocal of the argument, element-wise.', '\n', 'Calculates 1/x.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L43', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.relu(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes rectified linear activation.', '\n', '\n\\[max(features, 0)\\]', '\n', 'The storage type of ', 'relu', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.repeat(data=None, repeats=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Repeats elements of an array.\nBy default, ', 'repeat', ' flattens the input array into 1-D and then repeats the\nelements:', '\n', None, '\n', '\n', '\n', 'The parameter ', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L743', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.reset_arrays(*data, **kwargs)Â¶","['Set to zero multiple arrays', '\n', 'Defined in src/operator/contrib/reset_arrays.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.reshape_like(lhs=None, rhs=None, lhs_begin=_Null, lhs_end=_Null, rhs_begin=_Null, rhs_end=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reshape some or all dimensions of ', 'lhs', ' to have the same shape as some or all dimensions of ', 'rhs', '.', '\n', 'Returns a ', 'view', ' of the ', 'lhs', ' array with a new shape without altering any data.', '\n', 'Example:', '\n', None, '\n', '\n', 'More precise control over how dimensions are inherited is achieved by specifying slices over the ', 'lhs', ' and ', 'rhs', ' array dimensions. Only the sliced ', 'lhs', ' dimensions are reshaped to the ', 'rhs', ' sliced dimensions, with the non-sliced ', 'lhs', ' dimensions staying the same.', '\n', '\n', 'Examples:', '\n', 'Negative indices are supported, and ', 'None', ' can be used for either ', 'lhs_end', ' or ', 'rhs_end', ' to indicate the end of the range.', '\n', '\n', 'Example:', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L511', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.reverse(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.rint(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rint', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L798', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.rmsprop_update(weight=None, grad=None, n=None, lr=_Null, gamma1=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for ', 'RMSProp', ' optimizer.', '\n', 'RMSprop', ' is a variant of stochastic gradient descent where the gradients are\ndivided by a cache which grows with the sum of squares of recent gradients?', '\n', 'RMSProp', ' is similar to ', 'AdaGrad', ', a popular variant of ', 'SGD', ' which adaptively\ntunes the learning rate of each parameter. ', 'AdaGrad', ' lowers the learning rate for\neach parameter monotonically over the course of training.\nWhile this is analytically motivated for convex optimizations, it may not be ideal\nfor non-convex problems. ', 'RMSProp', ' deals with this heuristically by allowing the\nlearning rates to rebound as the denominator decays over time.', '\n', 'Define the Root Mean Square (RMS) error criterion of the gradient as\n', '\\(RMS[g]_t = \\sqrt{E[g^2]_t + \\epsilon}\\)', ', where ', '\\(g\\)', ' represents\ngradient and ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient.', '\n', 'The ', '\\(E[g^2]_t\\)', ' is given by:', '\n', '\n\\[E[g^2]_t = \\gamma * E[g^2]_{t-1} + (1-\\gamma) * g_t^2\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t - \\frac{\\eta}{RMS[g]_t} g_t\\]', '\n', 'The RMSProp code follows the version in\n', 'http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf', '\nTieleman & Hinton, 2012.', '\n', 'Hinton suggests the momentum term ', '\\(\\gamma\\)', ' to be 0.9 and the learning rate\n', '\\(\\eta\\)', ' to be 0.001.', '\n', 'Defined in src/operator/optimizer_op.cc:L796', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.rmspropalex_update(weight=None, grad=None, n=None, g=None, delta=None, lr=_Null, gamma1=_Null, gamma2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for RMSPropAlex optimizer.', '\n', 'RMSPropAlex', ' is non-centered version of ', 'RMSProp', '.', '\n', 'Define ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient and\n', '\\(E[g]_t\\)', ' is the decaying average over past gradient.', '\n', '\n\\[\\begin{split}E[g^2]_t = \\gamma_1 * E[g^2]_{t-1} + (1 - \\gamma_1) * g_t^2\\\\\nE[g]_t = \\gamma_1 * E[g]_{t-1} + (1 - \\gamma_1) * g_t\\\\\n\\Delta_t = \\gamma_2 * \\Delta_{t-1} - \\frac{\\eta}{\\sqrt{E[g^2]_t - E[g]_t^2 + \\epsilon}} g_t\\\\\\end{split}\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t + \\Delta_t\\]', '\n', 'The RMSPropAlex code follows the version in\n', 'http://arxiv.org/pdf/1308.0850v5.pdf', ' Eq(38) - Eq(45) by Alex Graves, 2013.', '\n', 'Graves suggests the momentum term ', '\\(\\gamma_1\\)', ' to be 0.95, ', '\\(\\gamma_2\\)', '\nto be 0.9 and the learning rate ', '\\(\\eta\\)', ' to be 0.0001.', '\n', 'Defined in src/operator/optimizer_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.round(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'round', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L777', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.rsqrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse square-root value of the input.', '\n', '\n\\[rsqrt(x) = 1/\\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rsqrt', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_exponential(lam=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nexponential distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_gamma(alpha=None, beta=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L281', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_generalized_negative_binomial(mu=None, alpha=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean) and ', 'alpha', ' (dispersion).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L292', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_multinomial(data=None, shape=_Null, get_prob=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple multinomial distributions.', '\n', 'data', ' is an ', 'n', ' dimensional array whose last dimension has length ', 'k', ', where\n', 'k', ' is the number of possible outcomes of each multinomial distribution. This\noperator will draw ', 'shape', ' samples from each distribution. If shape is empty\none sample will be drawn from each distribution.', '\n', 'If ', 'get_prob', ' is true, a second array containing log likelihood of the drawn\nsamples will also be returned. This is usually used for reinforcement learning\nwhere you can provide reward as head gradient for this array to estimate\ngradient.', '\n', 'Note that the input distribution must be normalized, i.e. ', 'data', ' must sum to\n1 along its last axis.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_negative_binomial(k=None, p=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L288', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_normal(mu=None, sigma=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L278', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_poisson(lam=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nPoisson distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L285', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sample_uniform(low=None, high=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L276', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.scatter_nd(data=None, indices=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Scatters data into a new tensor according to indices.', '\n', 'Given ', 'data', ' with shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', data shape should simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'all other entries in output are 0.', '\n', '\n', 'Warning', '\n', 'If the indices have duplicates, the result will be non-deterministic and\nthe gradient of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sgd_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and weightâ\x80\x99s storage\ntype is the same as momentumâ\x80\x99s storage type,\nonly the row slices whose indices appear in grad.indices are updated (for both weight and momentum):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L564', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradient is of ', 'row_sparse', ' storage type and ', 'lazy_update', ' is True,\nonly the row slices whose indices appear in grad.indices are updated:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L523', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.shape_array(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a 1D int64 array containing the shape of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L573', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.shuffle(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Randomly shuffle the elements.', '\n', 'This shuffles the array along the first axis.\nThe order of the elements in each subarray does not change.\nFor example, if a 2D array is given, the order of the rows randomly changes,\nbut the order of the elements in each row does not change.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sigmoid(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes sigmoid of x element-wise.', '\n', '\n\\[y = 1 / (1 + exp(-x))\\]', '\n', 'The storage type of ', 'sigmoid', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sign(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sign of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sign', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L758', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.signsgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for SignSGD optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(g_t)\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L62', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.signum_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, wd_lh=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['SIGN momentUM (Signum) optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta m_{t-1} + (1 - \\beta) g_t\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(m_t)\\end{split}\\]', '\n', '\n', 'It updates the weights using::', 'state = momentum * state + (1-momentum) * gradient\nweight = weight - learning_rate * sign(state)', '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L91', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sin(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise sine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[sin([0, \\pi/4, \\pi/2]) = [0, 0.707, 1]\\]', '\n', 'The storage type of ', 'sin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L47', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sinh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic sine of the input array, computed element-wise.', '\n', '\n\\[sinh(x) = 0.5\\times(exp(x) - exp(-x))\\]', '\n', 'The storage type of ', 'sinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L371', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.size_array(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a 1D int64 array containing the size of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.slice(data=None, begin=_Null, end=_Null, step=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.slice_axis(data=None, axis=_Null, begin=_Null, end=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices along a given axis.\nReturns an array slice along a given ', 'axis', ' starting from the ', 'begin', ' index\nto the ', 'end', ' index.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L570', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.slice_like(data=None, shape_like=None, axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices a region of the array like the shape of another array.\nThis function is similar to ', 'slice', ', however, the ', 'begin', ' are always ', '0`s\nand `end', ' of specific axes are inferred from the second input ', 'shape_like', '.\nGiven the second ', 'shape_like', ' input of ', 'shape=(d_0,', ',\na ', 'slice_like', ' operator with default empty ', 'axes', ', it performs the\nfollowing operation:\n`` out = slice(input, begin=(0, 0, â\x80¦, 0), end=(d_0, d_1, â\x80¦, d_n-1))``.\nWhen ', 'axes', ' is not empty, it is used to speficy which axes are being sliced.\nGiven a 4-d input data, ', 'slice_like', ' operator with ', 'axes=(0,', '\nwill perform the following operation:\n`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.\nNote that it is allowed to have first and second input with different dimensions,\nhowever, you have to make sure the ', 'axes', ' are specified and not exceeding the\ndimension limits.\nFor example, given ', 'input_1', ' with ', 'shape=(2,3,4,5)', ' and ', 'input_2', ' with\n', 'shape=(1,2,3)', ', it is not allowed to use:\n`` out = slice_like(a, b)`` because ndim of ', 'input_1', ' is 4, and ndim of ', 'input_2', '\nis 3.\nThe following is allowed in this situation:\n`` out = slice_like(a, b, axes=(0, 2))``\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.smooth_l1(data=None, scalar=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Calculate Smooth L1 Loss(lhs, scalar) by summing', '\n', '\n\\[\\begin{split}f(x) =\n\\begin{cases}\n(\\sigma x)^2/2,& \\text{if }x < 1/\\sigma^2\\\\\n|x|-0.5/\\sigma^2,& \\text{otherwise}\n\\end{cases}\\end{split}\\]', '\n', 'where ', '\\(x\\)', ' is an element of the tensor ', 'lhs', ' and ', '\\(\\sigma\\)', ' is the scalar.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L108', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.softmax(data=None, length=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies the softmax function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.', '\n', '\n\\[softmax(\\mathbf{z/t})_j = \\frac{e^{z_j/t}}{\\sum_{k=1}^K e^{z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.softmax_cross_entropy(data=None, label=None, name=None, attr=None, out=None, **kwargs)Â¶","['Calculate cross entropy of softmax output and one-hot label.', '\n', '\n', 'This operator computes the cross entropy in two steps:\n- Applies softmax function on the input array.\n- Computes and returns the cross entropy loss between the softmax output and the labels.', '\n', 'The softmax function and cross entropy loss is given by:', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/loss_binary_op.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.softmin(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies the softmin function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum\nup to 1.', '\n', '\n\\[softmin(\\mathbf{z/t})_j = \\frac{e^{-z_j/t}}{\\sum_{k=1}^K e^{-z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmin.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.softsign(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes softsign of x element-wise.', '\n', '\n\\[y = x / (1 + abs(x))\\]', '\n', 'The storage type of ', 'softsign', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L191', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sort(data=None, axis=_Null, is_ascend=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a sorted copy of an input array along the given axis.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.space_to_depth(data=None, block_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Rearranges(permutes) blocks of spatial data into depth.\nSimilar to ONNX SpaceToDepth operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth', '\nThe output is a new tensor where the values from height and width dimension are\nmoved to the depth dimension. The reverse of this operation is ', 'depth_to_space', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C * (block\\_size ^ 2), H / block\\_size, W / block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L1018', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.split(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sqrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise square-root value of the input.', '\n', '\n\\[\\textrm{sqrt}(x) = \\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sqrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L170', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.square(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise squared value of the input.', '\n', '\n\\[square(x) = x^2\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'square', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.squeeze(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Remove single-dimensional entries from the shape of an array.\nSame behavior of defining the output tensor shape as numpy.squeeze for the most of cases.\nSee the following note for exception.\nExamples:', '\n', None, '\n', '\n', '\n', 'Note', '\n', 'The output of this operator will keep at least one dimension not removed. For example,\nsqueeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.stack(*data, **kwargs)Â¶","['Join a sequence of arrays along a new axis.\nThe axis parameter specifies the index of the new axis in the dimensions of the\nresult. For example, if axis=0 it will be the first dimension and if axis=-1 it\nwill be the last dimension.\nExamples:', '\n', None, '\n', '\n', 'This function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.stop_gradient(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sum_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.swapaxes(data=None, dim1=_Null, dim2=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.take(a=None, indices=None, axis=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Takes elements from an input array along the given axis.', '\n', 'This function slices the input array along a particular axis with the provided indices.', '\n', 'Given data tensor of rank r >= 1, and indices tensor of rank q, gather entries of the axis\ndimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them\nin an output tensor of rank q + (r - 1).', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of ', 'take', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L776', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.tan(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise tangent of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[tan([0, \\pi/4, \\pi/2]) = [0, 1, -inf]\\]', '\n', 'The storage type of ', 'tan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L140', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.tanh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic tangent of the input array, computed element-wise.', '\n', '\n\\[tanh(x) = sinh(x) / cosh(x)\\]', '\n', 'The storage type of ', 'tanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L451', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.tile(data=None, reps=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Repeats the whole array multiple times.\nIf ', 'reps', ' has length ', 'd', ', and input array has dimension of ', 'n', '. There are\nthree cases:\n- ', 'n=d', '. Repeat ', 'i', '-th dimension of the input by ', 'reps[i]', ' times:', '\n', None, '\n', '\n', '\n', 'n>d', '\n', 'n<d', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L795', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.topk(data=None, axis=_Null, k=_Null, ret_typ=_Null, is_ascend=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Returns the indices of the top ', 'axis (by default).\nIf ret_type is set to â\x80\x98valueâ\x80\x99 returns the value of top ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.transpose(data=None, axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Permutes the dimensions of an array.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L327', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.trunc(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return the element-wise truncated value of the input.', '\n', 'The truncated value of the scalar x is the nearest integer i which is closer to\nzero than x is. In short, the fractional part of the signed number x is discarded.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'trunc', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L856', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.unravel_index(data=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.where(condition=None, x=None, y=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return the elements, either from x or y, depending on the condition.', '\n', 'Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,\ndepending on the elements from condition are true or false. x and y must have the same shape.\nIf condition has the same shape as x, each element in the output array is from x if the\ncorresponding element in the condition is true, and from y if false.', '\n', 'If condition does not have the same shape as x, it must be a 1D array whose size is\nthe same as xâ\x80\x99s first dimension size. Each row of the output array is from xâ\x80\x99s row\nif the corresponding element from condition is true, and from yâ\x80\x99s row if false.', '\n', 'Note that all non-zero values are interpreted as ', 'True', ' in condition.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/control_flow_op.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.zeros_like(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return an array of zeros with the same shape, type and storage type\nas the input array.', '\n', 'The storage type of ', 'zeros_like', ' output depends on the storage type of the input', '\n', '\n', 'zeros_like(row_sparse) = row_sparse', '\n', 'zeros_like(csr) = csr', '\n', 'zeros_like(default) = default', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
class mxnet.symbol.Symbol(handle)[source]Â¶","['Bases: ', 'mxnet._ctypes.symbol.SymbolBase', '\n', 'Symbol is symbolic graph of the mxnet.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns self. For the convenience of conversion between legacy and np symbols.', '\n', '\n', '\n', '\n', 'Convert mx.sym.Symbol to mx.sym.np._Symbol.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Returns the attribute string for corresponding input key from the symbol.', '\n', '\n', '\n', '\n', 'Recursively gets all attributes from the symbol and its children.', '\n', '\n', '\n', '\n', 'Binds the current symbol to an executor and returns it.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Gets a debug string of symbol.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Evaluates a symbol given arguments.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Return symbol for target backend.', '\n', '\n', '\n', '\n', 'Gets a new grouped symbol whose output contains\ninputs to output nodes of the original symbol.', '\n', '\n', '\n', '\n', 'Gets a new grouped symbol ', '\n', '\n', '\n', '\n', 'Gets the autodiff of current symbol.', '\n', '\n', '\n', '\n', 'Infers the shapes of all arguments and all outputs given the known shapes of\nsome arguments.', '\n', '\n', '\n', '\n', 'Infers the shape partially.', '\n', '\n', '\n', '\n', 'Infers the type of all arguments and all outputs, given the known types\nfor some arguments.', '\n', '\n', '\n', '\n', 'Infers the type partially.', '\n', '\n', '\n', '\n', 'Lists all the arguments in the symbol.', '\n', '\n', '\n', '\n', 'Gets all attributes from the symbol.', '\n', '\n', '\n', '\n', 'Lists all the auxiliary states in the symbol.', '\n', '\n', '\n', '\n', 'Lists all arguments and auxiliary states of this Symbol.', '\n', '\n', '\n', '\n', 'Lists all the outputs in the symbol.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Gets name string from the symbol, this function only works for non-grouped symbol.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Partitions current symbol and optimizes it for a given backend,\nreturns new partitioned symbol.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Saves symbol to a file.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Bind current symbol to get an executor, allocate all the arguments needed.\nAllows specifying data types.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Saves symbol to a JSON string.', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n', '\n', '\n', 'Convenience fluent method for ', '\n', '\n']",,,
"
mxnet.symbol.var(name, attr=None, shape=None, lr_mult=None, wd_mult=None, dtype=None, init=None, stype=None, **kwargs)[source]Â¶","['Creates a symbolic variable with specified name.', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'variable', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",">>> data=mx.sym.Variable('data',attr={'a':'b'})
>>> data
<Symbol data>
>>> csr_data=mx.sym.Variable('csr_data',stype='csr')
>>> csr_data
<Symbol csr_data>
>>> row_sparse_weight=mx.sym.Variable('weight',stype='row_sparse')
>>> row_sparse_weight
<Symbol weight>
",,
"
mxnet.symbol.Variable(name, attr=None, shape=None, lr_mult=None, wd_mult=None, dtype=None, init=None, stype=None, **kwargs)Â¶","['Creates a symbolic variable with specified name.', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'variable', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",">>> data=mx.sym.Variable('data',attr={'a':'b'})
>>> data
<Symbol data>
>>> csr_data=mx.sym.Variable('csr_data',stype='csr')
>>> csr_data
<Symbol csr_data>
>>> row_sparse_weight=mx.sym.Variable('weight',stype='row_sparse')
>>> row_sparse_weight
<Symbol weight>
",,
"
mxnet.symbol.Group(symbols, create_fn=<class 'mxnet.symbol.symbol.Symbol'>)[source]Â¶","['Creates a symbol that contains a collection of other symbols, grouped together.\nA classic symbol (', 'mx.sym.Symbol', ') will be returned if all the symbols in the list\nare of that type; a numpy symbol (', 'mx.sym.np._Symbol', ') will be returned if all the\nsymbols in the list are of that type. A type error will be raised if a list of mixed\nclassic and numpy symbols are provided.', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'sym', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",">>> a=mx.sym.Variable('a')
>>> b=mx.sym.Variable('b')
>>> mx.sym.Group([a,b])
<Symbol Grouped>
",,
"
mxnet.symbol.load(fname)[source]Â¶","['Loads symbol from a JSON file.', '\n', 'You can also use pickle to do the job if you only work on python.\nThe advantage of load/save is the file is language agnostic.\nThis means the file saved using save can be loaded by other language binding of mxnet.\nYou also get the benefit being able to directly load/save from cloud storage(S3, HDFS).', '\n', '\n', 'Parameters', '\n', 'fname', '\n', 'Returns', '\n', 'sym', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n', 'See also', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.symbol.load_json(json_str)[source]Â¶","['Loads symbol from json string.', '\n', '\n', 'Parameters', '\n', 'json_str', '\n', 'Returns', '\n', 'sym', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n', 'See also', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.symbol.pow(base, exp)[source]Â¶","['Returns element-wise result of base element raised to powers from exp element.', '\n', 'Both inputs can be Symbol or scalar number.\nBroadcasting is not supported. Use ', 'broadcast_pow', ' instead.', '\n', 'sym.pow', ' is being deprecated, please use ', 'sym.power', ' instead.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The bases in x raised to the exponents in y.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.power(base, exp)[source]Â¶","['Returns element-wise result of base element raised to powers from exp element.', '\n', 'Both inputs can be Symbol or scalar number.\nBroadcasting is not supported. Use ', 'broadcast_pow', ' instead.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The bases in x raised to the exponents in y.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.maximum(left, right)[source]Â¶","['Returns element-wise maximum of the input elements.', '\n', 'Both inputs can be Symbol or scalar number. Broadcasting is not supported.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise maximum of the input symbols.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.minimum(left, right)[source]Â¶","['Returns element-wise minimum of the input elements.', '\n', 'Both inputs can be Symbol or scalar number. Broadcasting is not supported.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The element-wise minimum of the input symbols.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.hypot(left, right)[source]Â¶","['Given the â\x80\x9clegsâ\x80\x9d of a right triangle, returns its hypotenuse.', '\n', 'Equivalent to ', '\\(\\sqrt(left^2 + right^2)\\)', ', element-wise.\nBoth inputs can be Symbol or scalar number. Broadcasting is not supported.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The hypotenuse of the triangle(s)', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.eye(N, M=0, k=0, dtype=None, **kwargs)[source]Â¶","['Returns a new symbol of 2-D shpae, filled with ones on the diagonal and zeros elsewhere.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.zeros(shape, dtype=None, **kwargs)[source]Â¶","['Returns a new symbol of given shape and type, filled with zeros.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.ones(shape, dtype=None, **kwargs)[source]Â¶","['Returns a new symbol of given shape and type, filled with ones.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.full(shape, val, dtype=None, **kwargs)[source]Â¶","['Returns a new array of given shape and type, filled with the given value ', 'val', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.arange(start, stop=None, step=1.0, repeat=1, infer_range=False, name=None, dtype=None)[source]Â¶","['Returns evenly spaced values within a given interval.', '\n', 'Values are generated within the half-open interval [', 'start', ', ', 'stop', '). In other\nwords, the interval includes ', 'start', ' but excludes ', 'stop', '. The function is\nsimilar to the built-in Python function ', 'range', ' and to ', 'numpy.arange', ',\nbut returns a ', 'Symbol', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linspace(start, stop, num, endpoint=True, name=None, dtype=None)[source]Â¶","['Return evenly spaced numbers within a specified interval.', '\n', 'Values are generated within the half-open interval [', 'start', ', ', 'stop', ') or\nclosed interval [start, stop] depending on whether ', 'endpoint', ' is True or\nFalse. The function is similar to ', 'numpy.linspace', ', but returns a ', 'Symbol', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.histogram(a, bins=10, range=None, **kwargs)[source]Â¶","['Compute the histogram of the input data.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.split_v2(ary, indices_or_sections, axis=0, squeeze_axis=False)[source]Â¶","['Split an array into multiple sub-arrays.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.rand_zipfian(true_classes, num_sampled, range_max)[source]Â¶","['Draw random samples from an approximately log-uniform or Zipfian distribution.', '\n', 'This operation randomly samples ', 'num_sampled', ' candidates the range of integers [0, range_max).\nThe elements of sampled_candidates are drawn with replacement from the base distribution.', '\n', 'The base distribution for this operator is an approximately log-uniform or Zipfian distribution:', '\n', 'P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)', '\n', 'This sampler is useful when the true classes approximately follow such a distribution.\nFor example, if the classes represent words in a lexicon sorted in decreasing order of     frequency. If your classes are not ordered by decreasing frequency, do not use this op.', '\n', 'Additionaly, it also returns the number of times each of the     true classes and the sampled classes is expected to occur.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.foreach(body, data, init_states, name='foreach')[source]Â¶","['Run a for loop with user-defined computation over Symbols on dimension 0.', '\n', 'This operator simulates a for loop and body has the computation for an iteration\nof the for loop. It runs the computation in body on each slice from the input\nNDArrays.', '\n', 'body takes two arguments as input and outputs a tuple of two elements,\nas illustrated below:', '\n', 'out, states = body(data1, states)', '\n', 'data1 can be either a symbol or a list of symbols. If data is a symbol,\ndata1 is a symbol. Otherwise, data1 is a list of symbols and has the same\nsize as data. states is a list of symbols and have the same size as init_states.\nSimilarly, out can be either a symbol or a list of symbols, which are concatenated\nas the first output of foreach; states from the last execution of body\nare the second output of foreach.', '\n', 'foreach can output only output data or states. If a user only wants states,\nthe body function can return ([], states). Similarly, if a user only wants\noutput data, the body function can return (out, []).', '\n', 'The computation done by this operator is equivalent to the pseudo code below\nwhen the input data is NDArray:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.while_loop(cond, func, loop_vars, max_iterations=None, name='while_loop')[source]Â¶","['Run a while loop with user-defined computation and loop condition.', '\n', 'This operator simulates a while loop which iterately does customized computation\nas long as the condition is satisfied.', '\n', 'loop_vars', ' is a Symbol or nested lists of Symbols on which the computation uses.', '\n', 'cond', ' is a user-defined function, used as the loop condition.\nIt consumes ', 'loop_vars', ', and produces a scalar MXNet symbol,\nindicating the termination of the loop.\nThe loop ends when ', 'cond', ' returns false (zero).\nThe ', 'cond', ' is variadic, and its signature should be\n', 'cond(*loop_vars) => Symbol', '.', '\n', 'func', ' is a user-defined function, used as the loop body.\nIt also consumes ', 'loop_vars', ', and produces ', 'step_output', ' and ', 'new_loop_vars', ' at each step.\nIn each step, ', 'step_output', ' should contain the same number elements.\nThrough all steps, the i-th element of ', 'step_output', ' should have the same shape and dtype.\nAlso, ', 'new_loop_vars', ' should contain the same number of elements as ', 'loop_vars', ',\nand the corresponding element should have the same shape and dtype.\nThe ', 'func', ' is variadic, and its signature should be\n', 'func(*loop_vars) =>\n(Symbol or nested List[Symbol] step_output, Symbol or nested List[Symbol] new_loop_vars)', '.', '\n', 'max_iterations', ' is a scalar that defines the maximum number of iterations allowed.', '\n', 'This function returns two lists.\nThe first list has the length of ', '|step_output|', ',\nin which the i-th element are all i-th elements of\n', 'step_output', ' from all steps, stacked along axis 0.\nThe second list has the length of ', '|loop_vars|', ',\nwhich represents final states of loop variables.', '\n', '\n', 'Warning', '\n', 'For now, the axis 0 of all Symbols in the first list are ', '\n', '\n', '\n', 'Warning', '\n', 'Even if ', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.cond(pred, then_func, else_func, name='cond')[source]Â¶","['Run an if-then-else using user-defined condition and computation', '\n', 'This operator simulates a if-like branch which chooses to do one of\nthe two customized computations according to the specified condition.', '\n', 'pred', ' is a scalar MXNet Symbol,\nindicating which branch of computation should be used.', '\n', 'then_func', ' is a user-defined function, used as computation of the then branch.\nIt produces ', 'outputs', ', which is a list of Symbols.\nThe signature of ', 'then_func', ' should be\n', 'then_func() => nested List[Symbol]', '.', '\n', 'else_func', ' is a user-defined function, used as computation of the else branch.\nIt produces ', 'outputs', ', which is a list of Symbols.\nThe signature of ', 'else_func', ' should be\n', 'else_func() => nested List[Symbol]', '.', '\n', 'The ', 'outputs', ' produces by ', 'then_func', ' and ', 'else_func', ' should have the same number\nof elements, all of which should be in the same shape, of the same dtype and stype.', '\n', 'This function returns a list of symbols, representing the computation result.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'outputs', '\n', 'Return type', '\n', 'a Symbol or nested lists of Symbols, representing the result of computation.', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.AdaptiveAvgPooling2D(data=None, output_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).\nThe pooling kernel and stride sizes are automatically chosen for desired output sizes.', '\n', '\n', 'If a single integer is provided for output_size, the output size is (N x C x output_size x output_size) for any input (NCHW).', '\n', 'If a tuple of integers (height, width) are provided for output_size, the output size is (N x C x height x width) for any input (NCHW).', '\n', '\n', 'Defined in src/operator/contrib/adaptive_avg_pooling.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.BatchNormWithReLU(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization with ReLU fusion.', '\n', 'An extented operator of Batch normalization which can fuse ReLU activation.', '\n', 'Defined in src/operator/contrib/batch_norm_relu.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.BilinearResize2D(data=None, like=None, height=_Null, width=_Null, scale_height=_Null, scale_width=_Null, mode=_Null, align_corners=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.', '\n', 'Expected input is a 4 dimensional NDArray (NCHW) and the output\nwith the shape of (N x C x height x width).\nThe key idea of bilinear interpolation is to perform linear interpolation\nfirst in one direction, and then again in the other direction. See the wikipedia of\n', 'Bilinear interpolation', '\nfor more details.', '\n', 'Defined in src/operator/contrib/bilinear_resize.cc:L219', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.DeformableConvolution(data=None, offset=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute 2-D deformable convolution on 4-D input.', '\n', 'The deformable convolution operation is described in ', 'https://arxiv.org/abs/1703.06211', '\n', 'For 2-D deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'data', ' into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset on the ', 'i', '-th part\nof the data.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.DeformablePSROIPooling(data=None, rois=None, trans=None, spatial_scale=_Null, output_dim=_Null, group_size=_Null, pooled_size=_Null, part_size=_Null, sample_per_part=_Null, trans_std=_Null, no_trans=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs deformable position-sensitive region-of-interest pooling on inputs.\nThe DeformablePSROIPooling operation is described in ', 'https://arxiv.org/abs/1703.06211', ' .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.ModulatedDeformableConvolution(data=None, offset=None, mask=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, im2col_step=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute 2-D modulated deformable convolution on 4-D input.', '\n', 'The modulated deformable convolution operation is described in ', 'https://arxiv.org/abs/1811.11168', '\n', 'For 2-D modulated deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'mask', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'out', ' evenly into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset part on the ', 'i', '-th\nout.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/modulated_deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.MultiBoxDetection(cls_prob=None, loc_pred=None, anchor=None, clip=_Null, threshold=_Null, background_id=_Null, nms_threshold=_Null, force_suppress=_Null, variances=_Null, nms_topk=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Convert multibox detection predictions.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.MultiBoxPrior(data=None, sizes=_Null, ratios=_Null, clip=_Null, steps=_Null, offsets=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generate prior(anchor) boxes from data, sizes and ratios.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.MultiBoxTarget(anchor=None, label=None, cls_pred=None, overlap_threshold=_Null, ignore_label=_Null, negative_mining_ratio=_Null, negative_mining_thresh=_Null, minimum_negative_samples=_Null, variances=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute Multibox training targets', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.MultiProposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.PSROIPooling(data=None, rois=None, spatial_scale=_Null, output_dim=_Null, pooled_size=_Null, group_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.Proposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.ROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sample_ratio=_Null, position_sensitive=_Null, aligned=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.\nThis operator is typically used in Faster R-CNN & Mask R-CNN networks. If roi batchid is less\nthan 0, it will be ignored, and the corresponding output will be set to 0.', '\n', 'Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning\nthe extracted features with the input. RoIAlign computes the value of each sampling point\nby bilinear interpolation from the nearby grid points on the feature map. No quantization is\nperformed on any coordinates involved in the RoI, its bins, or the sampling points.\nBilinear interpolation is used to compute the exact values of the\ninput features at four regularly sampled locations in each RoI bin.\nThen the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'He, Kaiming, et al. â\x80\x9cMask R-CNN.â\x80\x9d ICCV, 2017', '\n', 'Defined in src/operator/contrib/roi_align.cc:L558', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.RROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sampling_ratio=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs Rotated ROI Align on the input array.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.', '\n', 'Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.\nRRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby\ngrid points on the rotated feature map. No quantization is performed on any coordinates\ninvolved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to\ncompute the exact values of the input features at four regularly sampled locations in\neach RoI bin. Then the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'Ma, Jianqi, et al. â\x80\x9cArbitrary-Oriented Scene Text Detection via Rotation Proposals.â\x80\x9d\nIEEE Transactions on Multimedia, 2018.', '\n', 'Defined in src/operator/contrib/rroi_align.cc:L273', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.SparseEmbedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'note:: ', 'contrib.SparseEmbedding', ' is deprecated, use ', 'Embedding', ' instead.', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'The storage type of the gradient will be ', 'row_sparse', '.', '\n', '\n', 'Note', '\n', 'SparseEmbedding', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L674', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.SyncBatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, ndev=_Null, key=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.\nStandard BN ', '1', ' implementation only normalize the data within each device.\nSyncBN normalizes the input within the whole mini-batch.\nWe follow the sync-onece implmentation described in the paper ', '2', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Reference:', '\n', '\n', '\n', 'Defined in src/operator/contrib/sync_batch_norm.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.allclose(a=None, b=None, rtol=_Null, atol=_Null, equal_nan=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)', '\n', '\n\\[f(x) = |aâ\x88\x92b|â\x89¤atol+rtol|b|\\]', '\n', 'where\n', '\\(a, b\\)', ' are the input tensors of equal types an shapes\n', '\\(atol, rtol\\)', ' the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/allclose_op.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.arange_like(data=None, start=_Null, step=_Null, repeat=_Null, ctx=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Return an array with evenly spaced values. If axis is not given, the output will\nhave the same shape as the input array. Otherwise, the output will be a 1-D array with size of\nthe specified axis in input shape.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.backward_gradientmultiplier(data=None, scalar=_Null, is_int=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.backward_hawkesll(name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'name', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.backward_index_copy(name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'name', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.backward_quadratic(name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'name', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.bipartite_matching(data=None, is_ascend=_Null, threshold=_Null, topk=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Compute bipartite matching.', 'The matching is performed on score matrix with shape [B, N, M]\n- B: batch_size\n- N: number of rows to match\n- M: number of columns as reference to be matched against.', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L182', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.boolean_mask(data=None, index=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Given an n-d NDArray data, and a 1-d NDArray index,\nthe operator produces an un-predeterminable shaped n-d NDArray out,\nwhich stands for the rows in x where the corresonding element in index is non-zero.', '\n', None, '\n', '\n', '[[4. 5. 6.]]\n<NDArray 1x3 @cpu(0)>', '\n', 'Defined in src/operator/contrib/boolean_mask.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.box_decode(data=None, anchors=None, std0=_Null, std1=_Null, std2=_Null, std3=_Null, clip=_Null, format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Decode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.box_encode(samples=None, matches=None, anchors=None, refs=None, means=None, stds=None, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Encode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L210', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.box_iou(lhs=None, rhs=None, format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Bounding box overlap of two arrays.', 'The overlap is defined as Intersection-over-Union, aka, IOU.\n- lhs: (a_1, a_2, â\x80¦, a_n, 4) array\n- rhs: (b_1, b_2, â\x80¦, b_n, 4) array\n- output: (a_1, a_2, â\x80¦, a_n, b_1, b_2, â\x80¦, b_n) array', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.box_nms(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.box_non_maximum_suppression(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.calibrate_entropy(hist=None, hist_edges=None, num_quantized_bins=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Provide calibrated min/max for input histogram.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/calibrate.cc:L196', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.count_sketch(data=None, h=None, s=None, out_dim=_Null, processing_batch_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply CountSketch to input: map a d-dimension data to k-dimension dataâ\x80\x9d', '\n', '\n', 'Note', '\n', 'count_sketch', '\n', '\n', 'Assume input data has shape (N, d), sign hash table s has shape (N, d),\nindex hash table h has shape (N, d) and mapping dimension out_dim = k,\neach element in s is either +1 or -1, each element in h is random integer from 0 to k-1.\nThen the operator computs:', '\n', '\n\\[out[h[i]] += data[i] * s[i]\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/count_sketch.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.dequantize(data=None, min_range=None, max_range=None, out_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Dequantize the input tensor into a float tensor.\nmin_range and max_range are scalar floats that specify the range for\nthe output data.', '\n', 'When input data type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = in[i] * (max_range - min_range) / 255.0', ',', '\n', 'When input data type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0', ',', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/dequantize.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.dgl_adjacency(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['This operator converts a CSR matrix whose values are edge Ids\nto an adjacency matrix whose values are ones. The output CSR matrix always has\nthe data value of float32.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1424', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.dgl_csr_neighbor_non_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graph from a csr graph via an\nnon-uniform probability. The operator is designed for DGL.', '\n', 'The operator outputs four sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,\n4) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L911\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.dgl_csr_neighbor_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graphs from a csr graph via an\nuniform probability. The operator is designed for DGL.', '\n', 'The operator outputs three sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L801\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.dgl_graph_compact(*graph_data, **kwargs)Â¶","['This operator compacts a CSR matrix generated by\ndgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.\nThe CSR matrices generated by these two operators may have many empty\nrows at the end and many empty columns. This operator removes these\nempty rows and empty columns.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1613\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.dgl_subgraph(*data, **kwargs)Â¶","['This operator constructs an induced subgraph for\na given set of vertices from a graph. The operator accepts multiple\nsets of vertices as input. For each set of vertices, it returns a pair\nof CSR matrices if return_mapping is True: the first matrix contains edges\nwith new edge Ids, the second matrix contains edges with the original\nedge Ids.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1171\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.div_sqrt_dim(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Rescale the input by the square root of the channel dimension.', '\n', '\n', 'out = data / sqrt(data.shape[-1])', '\n', 'Defined in src/operator/contrib/transformer.cc:L832', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.edge_id(data=None, u=None, v=None, name=None, attr=None, out=None, **kwargs)Â¶","['This operator implements the edge_id function for a graph\nstored in a CSR matrix (the value of the CSR stores the edge Id of the graph).\noutput[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],\notherwise output[i] will be -1. Both u and v should be 1D vectors.', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1352', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.fft(data=None, compute_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply 1D FFT to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'fft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.\nThe output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, â\x80¦].', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/fft.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.getnnz(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Number of stored values for a sparse tensor, including explicit zeros.', '\n', 'This operator only supports CSR matrix on CPU.', '\n', 'Defined in src/operator/contrib/nnz.cc:L176', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.gradientmultiplier(data=None, scalar=_Null, is_int=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator implements the gradient multiplier function.\nIn forward pass it acts as an identity transform. During backpropagation it\nmultiplies the gradient from the subsequent level by a scalar factor lambda and passes it to\nthe preceding layer.', '\n', 'Defined in src/operator/contrib/gradient_multiplier_op.cc:L78', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.group_adagrad_update(weight=None, grad=None, history=None, lr=_Null, rescale_grad=_Null, clip_gradient=_Null, epsilon=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Group AdaGrad optimizer.', '\n', 'Referenced from ', 'Adaptive Subgradient Methods for Online Learning and Stochastic Optimization', ',\nand available at ', 'http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf', ' but\nuses only a single learning rate for every row of the parameter array.', '\n', 'Updates are applied by:', '\n', None, '\n', '\n', 'Weights are updated lazily if the gradient is sparse.', '\n', 'Note that non-zero values for the weight decay option are not supported.', '\n', 'Defined in src/operator/contrib/optimizer_op.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.hawkesll(lda=None, alpha=None, beta=None, state=None, lags=None, marks=None, valid_length=None, max_time=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the log likelihood of a univariate Hawkes process.', '\n', 'The log likelihood is calculated on point process observations represented\nas ', 'ragged', ' matrices for ', 'lags', ' (interarrival times w.r.t. the previous point),\nand ', 'marks', ' (identifiers for the process ID). Note that each mark is considered independent,\ni.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:', '\n', '\n\\[\\lambda_k^*(t) = \\lambda_k + \\alpha_k \\sum_{\\{t_i < t, y_i = k\\}} \\beta_k \\exp(-\\beta_k (t - t_i))\\]', '\n', 'where ', '\\(\\lambda_k\\)', ' specifies the background intensity ', 'lda', ', ', '\\(\\alpha_k\\)', ' specifies the ', 'branching ratio', ' or ', 'alpha', ', and ', '\\(\\beta_k\\)', ' the delay density parameter ', 'beta', '.', '\n', 'lags', ' and ', 'marks', ' are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are â\x80\x9cleft-alignedâ\x80\x9d ', 'ragged', ' matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ', 'valid_length', ', of shape (N,) where ', 'valid_length[i]', ' corresponds to the number of valid points in ', 'lags[i,', ' and ', 'marks[i,', '.', '\n', 'max_time', ' is the length of the observation period of the point process. That is, specifying ', 'max_time[i]', ' computes the likelihood of the i-th sample as observed on the time interval ', '\\((0, 5]\\)', '. Naturally, the sum of all valid ', 'lags[i,', ' must be less than or equal to 5.', '\n', 'The input ', 'state', ' specifies the ', 'memory', ' of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the ', 'memory', ' as', '\n', '\n\\[s_k(t) = \\sum_{t_i < t} \\exp(-\\beta_k (t - t_i)).\\]', '\n', 'The ', 'state', ' to be provided is ', '\\(s_k(0)\\)', ' and carries the added intensity due to past events before the current batch. ', '\\(s_k(T)\\)', ' is returned from the function where ', '\\(T\\)', ' is ', 'max_time[T]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'References:', '\n', '\n', 'Bacry, E., Mastromatteo, I., & Muzy, J. F. (2015).\nHawkes processes in finance. Market Microstructure and Liquidity\n, 1(01), 1550005.', '\n', '\n', 'Defined in src/operator/contrib/hawkes_ll.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.ifft(data=None, compute_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply 1D ifft to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'ifft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, â\x80¦].\nLast dimension must be an even number.\nThe output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/ifft.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.index_array(data=None, axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns an array of indexes of the input array.', '\n', 'For an input array with shape  ', '\\((d_1, d_2, ..., d_n)\\)', ', ', 'index_array', ' returns a\n', '\\((d_1, d_2, ..., d_n, n)\\)', ' array ', 'idx', ', where\n', '\\(idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]\\)', '.', '\n', 'Additionally, when the parameter ', 'axes', ' is specified, ', 'idx', ' will be a\n', '\\((d_1, d_2, ..., d_n, m)\\)', ' array where ', 'm', ' is the length of ', 'axes', ', and the following\nequality will hold: ', '\\(idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}\\)', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_array.cc:L118', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.index_copy(old_tensor=None, index_vector=None, new_tensor=None, name=None, attr=None, out=None, **kwargs)Â¶","['Copies the elements of a ', 'new_tensor', ' into the ', 'old_tensor', '.', '\n', 'This operator copies the elements by selecting the indices in the order given in ', 'index', '.\nThe output will be a new tensor containing the rest elements of old tensor and\nthe copied elements of new tensor.\nFor example, if ', 'index[i] == j', ', then the ', 'i', ' th row of ', 'new_tensor', ' is copied to the\n', 'j', ' th row of output.', '\n', 'The ', 'index', ' must be a vector and it must have the same size with the ', '0', ' th dimension of\n', 'new_tensor', '. Also, the ', '0', ' th dimension of old_tensor must ', '>=', ' the ', '0', ' th dimension of\n', 'new_tensor', ', or an error will be raised.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_copy.cc:L183', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.interleaved_matmul_encdec_qk(queries=None, keys_values=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of projections of queries following the layout:\n(seq_length, batch_size, num_heads * head_dim)', '\n', 'and a tensor of interleaved projections of values and keys following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'the equivalent code would be:\nq_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\ntmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))\nk_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L753', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.interleaved_matmul_encdec_valatt(keys_values=None, attention=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of interleaved projections of\nkeys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:', '\n', 'tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L799', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.interleaved_matmul_selfatt_qk(queries_keys_values=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as self attention.', '\n', 'the input must be a single tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nq_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\nk_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L665', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.interleaved_matmul_selfatt_valatt(queries_keys_values=None, attention=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as self attention.', '\n', 'the inputs must be a tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L709', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.intgemm_fully_connected(data=None, weight=None, scaling=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Multiply matrices using 8-bit integers.  data * weight.', '\n', 'Input tensor arguments are: data weight [scaling] [bias]', '\n', 'data: either float32 or prepared using intgemm_prepare_data (in which case it is int8).', '\n', 'weight: must be prepared using intgemm_prepare_weight.', '\n', 'scaling: present if and only if out_type is float32. If so this is multiplied by the result before adding bias. Typically:\nscaling = (max passed to intgemm_prepare_weight)/127.0 if data is in float32\nscaling = (max_passed to intgemm_prepare_data)/127.0 * (max passed to intgemm_prepare_weight)/127.0 if data is in int8', '\n', 'bias: present if and only if !no_bias. This is added to the output after scaling and has the same number of columns as the output.', '\n', 'out_type: type of the output.', '\n', 'Defined in src/operator/contrib/intgemm/intgemm_fully_connected_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.intgemm_maxabsolute(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the maximum absolute value in a tensor of float32 fast on a CPU.  The tensorâ\x80\x99s total size must be a multiple of 16 and aligned to a multiple of 64 bytes.\nmxnet.nd.contrib.intgemm_maxabsolute(arr) == arr.abs().max()', '\n', 'Defined in src/operator/contrib/intgemm/max_absolute_op.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.intgemm_prepare_data(data=None, maxabs=None, name=None, attr=None, out=None, **kwargs)Â¶","['This operator converts quantizes float32 to int8 while also banning -128.', '\n', 'It it suitable for preparing an data matrix for use by intgemmâ\x80\x99s C=data * weights operation.', '\n', 'The float32 values are scaled such that maxabs maps to 127. Typically maxabs = maxabsolute(A).', '\n', 'Defined in src/operator/contrib/intgemm/prepare_data_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.intgemm_prepare_weight(weight=None, maxabs=None, already_quantized=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator converts a weight matrix in column-major format to intgemmâ\x80\x99s internal fast representation of weight matrices.  MXNet customarily stores weight matrices in column-major (transposed) format. This operator is not meant to be fast; it is meant to be run offline to quantize a model.', '\n', 'In other words, it prepares weight for the operation C = data * weight^T.', '\n', 'If the provided weight matrix is float32, it will be quantized first.  The quantization function is (int8_t)(127.0 / max * weight) where multiplier is provided as argument 1 (the weight matrix is argument 0).  Then the matrix will be rearranged into the CPU-dependent format.', '\n', 'If the provided weight matrix is already int8, the matrix will only be rearranged into the CPU-dependent format.  This way one can quantize with intgemm_prepare_data (which just quantizes), store to disk in a consistent format, then at load time convert to CPU-dependent format with intgemm_prepare_weight.', '\n', 'The internal representation depends on register length.  So AVX512, AVX2, and SSSE3 have different formats.  AVX512BW and AVX512VNNI have the same representation.', '\n', 'Defined in src/operator/contrib/intgemm/prepare_weight_op.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.intgemm_take_weight(weight=None, indices=None, name=None, attr=None, out=None, **kwargs)Â¶","['Index a weight matrix stored in intgemmâ\x80\x99s weight format.\nThe indices select the outputs of matrix multiplication, not the inner dot product dimension.', '\n', 'Defined in src/operator/contrib/intgemm/take_weight_op.cc:L128', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quadratic(data=None, a=_Null, b=_Null, c=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operators implements the quadratic function.', '\n', '\n\\[f(x) = ax^2+bx+c\\]', '\n', 'where ', '\\(x\\)', ' is an input tensor and all operations\nin the function are element-wise.', '\n', 'Example:', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/quadratic_op.cc:L50', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantize(data=None, min_range=None, max_range=None, out_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_range', ' and ', 'max_range', '.', '\n', 'min_range and max_range are scalar floats that specify the range for\nthe input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize.cc:L73', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantize_asym(data=None, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Quantize a input tensor from float to uint8_t.\nOutput ', 'scale', ' and ', 'shift', ' are scalar floats that specify the quantization parameters for the input\ndata.\nThe output is calculated using the following equation:\n', 'out[i] = in[i] * scale + shift + 0.5', ',\nwhere ', 'scale = uint8_range / (max_range - min_range)', ' and\n', 'shift = numeric_limits<T>::max - max_range * scale', '.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantize_asym.cc:L115', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantize_v2(data=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_calib_range', ' and ', 'max_calib_range', ' or the input range collected at runtime.', '\n', 'Output ', 'min_range', ' and ', 'max_range', ' are scalar floats that specify the range for the input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', 'When out_type is ', 'auto', ', the output type is automatically determined by min_calib_range if presented.\nIf min_calib_range < 0.0f, the output type will be int8, otherwise will be uint8.\nIf min_calib_range isnâ\x80\x99t presented, the output type will be int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize_v2.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_act(data=None, min_data=None, max_data=None, act_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Activation operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_activation.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_batch_norm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, min_data=None, max_data=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['BatchNorm operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_batch_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.\nAll inputs with different min/max will be rescaled by using largest [min, max] pairs.\nIf any input holds int8, then the output will be int8. Otherwise output will be uint8.', '\n', 'Defined in src/operator/quantization/quantized_concat.cc:L107\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_conv(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Convolution operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_conv.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_elemwise_add(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, name=None, attr=None, out=None, **kwargs)Â¶","['elemwise_add operator for input dataA and input dataB data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_elemwise_mul(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, min_calib_range=_Null, max_calib_range=_Null, enable_float_output=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplies arguments int8 element-wise.', '\n', 'Defined in src/operator/quantization/quantized_elemwise_mul.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_embedding(data=None, weight=None, min_weight=None, max_weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Maps integer indices to int8 vector representations (embeddings).', '\n', 'Defined in src/operator/quantization/quantized_indexing_op.cc:L133', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_flatten(data=None, min_data=None, max_data=None, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_fully_connected(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Fully Connected operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_fully_connected.cc:L312', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_pooling(data=None, min_data=None, max_data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Pooling operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_pooling.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.quantized_rnn(data=None, parameters=None, state=None, state_cell=None, data_scale=None, data_shift=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['RNN operator for input data type of uint8. The weight of each gates is converted\nto int8, while bias is accumulated in type float32. The hidden state and cell state are in type\nfloat32. For the input data, two more arguments of type float32 must be provided representing the\nthresholds of quantizing argument from data type float32 to uint8. The final outputs contain the\nrecurrent result in float32. It only supports quantization for Vanilla LSTM network.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantized_rnn.cc:L298', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.requantize(data=None, min_range=None, max_range=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Given data that is quantized in int32 and the corresponding thresholds,\nrequantize the data into int8 using min and max thresholds either calculated at runtime\nor from calibration. Itâ\x80\x99s highly recommended to pre-calucate the min and max thresholds\nthrough calibration since it is able to save the runtime of the operator and improve the\ninference accuracy.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/requantize.cc:L59', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.round_ste(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Straight-through-estimator of ', 'round()', '.', '\n', 'In forward pass, returns element-wise rounded value to the nearest integer of the input (same as ', 'round()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'round()', '):\n', '\\(\\frac{d}{dx}{round\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{round(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])\nx.backward()\nx = [-2.,  2., -2.,  2.,  3.]\nx.grad() = [1.,  1., 1.,  1.,  1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L54', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.contrib.sign_ste(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Straight-through-estimator of ', 'sign()', '.', '\n', 'In forward pass, returns element-wise sign of the input (same as ', 'sign()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'sign()', '):\n', '\\(\\frac{d}{dx}{sign\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{sign(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = sign_ste([-2, 0, 3])\nx.backward()\nx = [-1.,  0., 1.]\nx.grad() = [1.,  1., 1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L79', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.adjust_lighting(data=None, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Adjust the lighting level of the input. Follow the AlexNet style.', '\n', 'Defined in src/operator/image/image_random.cc:L254', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.crop(data=None, x=_Null, y=_Null, width=_Null, height=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Crop an image NDArray of shape (H x W x C) or (N x H x W x C)\nto the given size.\n.. rubric:: Example', '\n', 'Defined in src/operator/image/crop.cc:L65', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.flip_left_right(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.flip_top_bottom(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L205', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.normalize(data=None, mean=_Null, std=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and', 'standard deviation.', '\n', '\n', '\n\\[ \\begin{align}\\begin{aligned}    output[i] = (input[i] - m\\ :sub:`i`\\ ) / s\\ :sub:`i`\\\\If mean or std is scalar, the same value will be applied to all channels.\\\\Default value for mean is 0.0 and stand deviation is 1.0.\\end{aligned}\\end{align} \\]', '\n', 'Example', '\n', 'Defined in src/operator/image/image_random.cc:L167', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_brightness(data=None, min_factor=_Null, max_factor=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L215', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_color_jitter(data=None, brightness=_Null, contrast=_Null, saturation=_Null, hue=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L246', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_contrast(data=None, min_factor=_Null, max_factor=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L222', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_flip_left_right(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L200', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_flip_top_bottom(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L210', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_hue(data=None, min_factor=_Null, max_factor=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L238', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_lighting(data=None, alpha_std=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Randomly add PCA noise. Follow the AlexNet style.', '\n', 'Defined in src/operator/image/image_random.cc:L262', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.random_saturation(data=None, min_factor=_Null, max_factor=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Defined in src/operator/image/image_random.cc:L230', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.resize(data=None, size=_Null, keep_ratio=_Null, interp=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Resize an image NDArray of shape (H x W x C) or (N x H x W x C)\nto the given size\n.. rubric:: Example', '\n', 'Defined in src/operator/image/resize.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.image.to_tensor(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Converts an image NDArray of shape (H x W x C) or (N x H x W x C)\nwith values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W)\nwith values in the range [0, 1]', '\n', 'Example', '\n', 'Defined in src/operator/image/image_random.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.det(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'det', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'There is no gradient backwarded when A is non-invertible (which is\nequivalent to det(A) = 0) because zero is rarely hit upon in float\npoint computation and the Jacobiâ\x80\x99s formula on determinant gradient\nis not computationally efficient when A is non-invertible.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L974', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.extractdiag(A=None, offset=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts the diagonal entries of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an ', 'n-1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.extracttrian(A=None, offset=_Null, lower=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts a triangular sub-matrix from a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an ', 'n-1', '-dimensional tensor.', '\n', 'The ', 'offset', ' and ', 'lower', ' parameters determine the triangle to be extracted:', '\n', '\n', 'When ', '\n', 'When ', '\n', 'When ', '\n', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L604', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.gelqf(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['LQ factorization for general matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', we compute the LQ factorization (LAPACK ', 'gelqf', ', followed by ', 'orglq', '). ', 'A', '\nmust have shape ', '(x, y)', ' with ', 'x <= y', ', and must have full rank ', '=x', '. The LQ\nfactorization consists of ', 'L', ' with shape ', '(x, x)', ' and ', 'Q', ' with shape ', '(x, y)', ', so\nthat:', '\n', '\n', 'A', '\n', 'Here, ', 'L', ' is lower triangular (upper triangle equal to zero) with nonzero diagonal,\nand ', 'Q', ' is row-orthonormal, meaning that', '\n', '\n', 'Q', '\n', 'is equal to the identity matrix of shape ', '(x, x)', '.', '\n', 'If ', 'n>2', ', ', 'gelqf', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L797', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.gemm(A=None, B=None, C=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, beta=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs general matrix multiplication and accumulation.\nInput are tensors ', 'A', ', ', 'B', ', ', 'C', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here, ', 'alpha', ' and ', 'beta', ' are scalar parameters, and ', 'op()', ' is either the identity or\nmatrix transposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ', ', 'C', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', ', 'C', ', axis=1) is equivalent\nto the following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.gemm2(A=None, B=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs general matrix multiplication.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here ', 'alpha', ' is a scalar parameter and ', 'op()', ' is either the identity or the matrix\ntransposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', axis=1) is equivalent to\nthe following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.inverse(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the inverse of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'inverse', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L919', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.makediag(A=None, offset=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Constructs a square matrix with the input as diagonal.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.\nIf ', 'n>1', ', then ', 'A', ' represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.maketrian(A=None, offset=_Null, lower=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Constructs a square matrix with the input representing a specific triangular sub-matrix.\nThis is basically the inverse of ', 'linalg.extracttrian', '. Input is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the entries of a triangular matrix which is lower triangular if ', 'offset<0', ' or ', 'offset=0', ', ', 'lower=true', '. The resulting matrix is derived by first constructing the square\nmatrix with the entries outside the triangle set to zero and then adding ', 'offset', '-times an additional\ndiagonal with zero entries to the square matrix.', '\n', 'If ', 'n>1', ', then ', 'A', ' represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L672', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.potrf(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Performs Cholesky factorization of a symmetric positive-definite matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the Cholesky factor ', 'B', ' of the symmetric, positive definite matrix ', 'A', ' is\ncomputed. ', 'B', ' is triangular (entries of upper or lower triangle are all zero), has\npositive diagonal entries, and:', '\n', '\n', 'A', '\n', 'If ', 'n>2', ', ', 'potrf', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.potri(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Performs matrix inversion from a Cholesky factorization.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a triangular matrix (entries of upper or lower triangle are all zero)\nwith positive diagonal. We compute:', '\n', '\n', 'out', '\n', 'In other words, if ', 'A', ' is the Cholesky factor of a symmetric positive definite matrix\n', 'B', ' (obtained by ', 'potrf', '), then', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'potri', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Use this operator only if you are certain you need the inverse of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L274', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.slogdet(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the sign and log of the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'sign', '\n', 'If ', 'n>2', ', ', 'slogdet', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'The gradient is not properly defined on sign, so the gradient of\nit is not backwarded.', '\n', '\n', '\n', 'Note', '\n', 'No gradient is backwarded when A is non-invertible. Please see\nthe docs of operator det for detail.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L1033', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.sumlogdiag(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of the logarithms of the diagonal elements of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be square with positive diagonal entries. We sum the natural\nlogarithms of the diagonal elements, the result has shape (1,).', '\n', 'If ', 'n>2', ', ', 'sumlogdiag', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L444', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.syevd(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Eigendecomposition for symmetric matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be symmetric, of shape ', '(x, x)', '. We compute the eigendecomposition,\nresulting in the orthonormal matrix ', 'U', ' of eigenvectors, shape ', '(x, x)', ', and the\nvector ', 'L', ' of eigenvalues, shape ', '(x,)', ', so that:', '\n', '\n', 'U', '\n', 'Here:', '\n', '\n', 'U', '\n', 'where ', 'I', ' is the identity matrix. Also, ', 'L(0) <= L(1) <= L(2) <= â\x80¦', ' (ascending order).', '\n', 'If ', 'n>2', ', ', 'syevd', ' is performed separately on the trailing two dimensions of ', 'A', ' (batch\nmode). In this case, ', 'U', ' has ', 'n', ' dimensions like ', 'A', ', and ', 'L', ' has ', 'n-1', ' dimensions.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Derivatives for this operator are defined only if ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L867', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.syrk(A=None, transpose=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplication of matrix with its transpose.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the operator performs the BLAS3 function ', 'syrk', ':', '\n', '\n', 'out', '\n', 'if ', 'transpose=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'transpose=True', '.', '\n', 'If ', 'n>2', ', ', 'syrk', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L729', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.trmm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs multiplication with a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trmm', ':', '\n', '\n', 'out', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trmm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.linalg.trsm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Solves matrix equation involving a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trsm', ', solving for ', 'out', ' in:', '\n', '\n', 'op', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trsm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L395', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Activation(data=None, act_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies an activation function element-wise to the input.', '\n', 'The following activation functions are supported:', '\n', '\n', 'relu', '\n', 'sigmoid', '\n', 'tanh', '\n', 'softrelu', '\n', 'softsign', '\n', '\n', 'Defined in src/operator/nn/activation.cc:L164', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'A one-hidden-layer MLP with ReLU activation:', '\n', None, '\n', '\n', 'ReLU activation', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.op.BatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\nthe inverse of ', 'data_var', ', which are needed for the backward pass. Note that gradient of these\ntwo outputs are blocked.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is 1.  Specifying -1 sets the channel\naxis to be the last item in the input shape.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Note', '\n', 'When ', '\n', '\n', 'Defined in src/operator/nn/batch_norm.cc:L608', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.BatchNorm_v1(data=None, gamma=None, beta=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization.', '\n', 'This operator is DEPRECATED. Perform BatchNorm on the input.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', 'Thereâ\x80\x99s no sparse support for this operator, and it will exhibit problematic behavior if used with\nsparse tensors.', '\n', 'Defined in src/operator/batch_norm_v1.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.BilinearSampler(data=None, grid=None, cudnn_off=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies bilinear sampling to input feature map.', '\n', 'Bilinear Sampling is the key of  [NIPS2015] â\x80\x9cSpatial Transformer Networksâ\x80\x9d. The usage of the operator is very similar to remap function in OpenCV,\nexcept that the operator has the backward pass.', '\n', 'Given ', '\\(data\\)', ' and ', '\\(grid\\)', ', then the output is computed by', '\n', '\n\\[\\begin{split}x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\\\\ny_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\\\\noutput[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})\\end{split}\\]', '\n', '\\(x_{dst}\\)', ', ', '\\(y_{dst}\\)', ' enumerate all spatial locations in ', '\\(output\\)', ', and ', '\\(G()\\)', ' denotes the bilinear interpolation kernel.\nThe out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).', '\n', 'The operator assumes that ', '\\(data\\)', ' has â\x80\x98NCHWâ\x80\x99 layout and ', '\\(grid\\)', ' has been normalized to [-1, 1].', '\n', 'BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.\nGridGenerator supports two kinds of transformation: ', 'affine', ' and ', 'warp', '.\nIf users want to design a CustomOp to manipulate ', '\\(grid\\)', ', please firstly refer to the code of GridGenerator.', '\n', 'Example 1:', '\n', None, '\n', '\n', 'Example 2:', '\n', None, '\n', '\n', 'Defined in src/operator/bilinear_sampler.cc:L255', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.BlockGrad(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Cast(data=None, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Concat two (or more) inputs along a specific dimension:', '\n', None, '\n', '\n', 'Note the shape should be the same except on the dimension that is being\nconcatenated.', '\n', '\n']",,,
"
mxnet.symbol.op.Convolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute ', 'N', '-D convolution on ', '(N+2)', '-D input.', '\n', 'In the 2-D convolution, given input data with shape ', '(batch_size,\nchannel, height, width)', ', the output is computed by', '\n', '\n\\[out[n,i,:,:] = bias[i] + \\sum_{j=0}^{channel} data[n,j,:,:] \\star\nweight[i,j,:,:]\\]', '\n', 'where ', '\\(\\star\\)', ' is the 2-D cross-correlation operator.', '\n', 'For general 2-D convolution, the shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channel, height,\nwidth)', '. We can choose other layouts such as ', 'NWC', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concatenating all\nthe ', 'g', ' results.', '\n', '1-D convolution does not have ', 'height', ' dimension but only ', 'width', ' in space.', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', '3-D convolution adds an additional ', 'depth', ' dimension besides ', 'height', ' and\n', 'width', '. The shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'There are other options to tune the performance.', '\n', '\n', 'cudnn_tune', '\n', 'workspace', '\n', '\n', 'Defined in src/operator/nn/convolution.cc:L475', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Convolution_v1(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator is DEPRECATED. Apply convolution to input then add a bias.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Correlation(data1=None, data2=None, kernel_size=_Null, max_displacement=_Null, stride1=_Null, stride2=_Null, pad_size=_Null, is_multiply=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies correlation to inputs.', '\n', 'The correlation layer performs multiplicative patch comparisons between two feature maps.', '\n', 'Given two multi-channel feature maps ', '\\(f_{1}, f_{2}\\)', ', with ', '\\(w\\)', ', ', '\\(h\\)', ', and ', '\\(c\\)', ' being their width, height, and number of channels,\nthe correlation layer lets the network compare each patch from ', '\\(f_{1}\\)', ' with each patch from ', '\\(f_{2}\\)', '.', '\n', 'For now we consider only a single comparison of two patches. The â\x80\x98correlationâ\x80\x99 of two patches centered at ', '\\(x_{1}\\)', ' in the first map and\n', '\\(x_{2}\\)', ' in the second map is then defined as:', '\n', '\n\\[c(x_{1}, x_{2}) = \\sum_{o \\in [-k,k] \\times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\\]', '\n', 'for a square patch of size ', '\\(K:=2k+1\\)', '.', '\n', 'Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other\ndata. For this reason, it has no training weights.', '\n', 'Computing ', '\\(c(x_{1}, x_{2})\\)', ' involves ', '\\(c * K^{2}\\)', ' multiplications. Comparing all patch combinations involves ', '\\(w^{2}*h^{2}\\)', ' such computations.', '\n', 'Given a maximum displacement ', '\\(d\\)', ', for each location ', '\\(x_{1}\\)', ' it computes correlations ', '\\(c(x_{1}, x_{2})\\)', ' only in a neighborhood of size ', '\\(D:=2d+1\\)', ',\nby limiting the range of ', '\\(x_{2}\\)', '. We use strides ', '\\(s_{1}, s_{2}\\)', ', to quantize ', '\\(x_{1}\\)', ' globally and to quantize ', '\\(x_{2}\\)', ' within the neighborhood\ncentered around ', '\\(x_{1}\\)', '.', '\n', 'The final output is defined by the following expression:', '\n', '\n\\[out[n, q, i, j] = c(x_{i, j}, x_{q})\\]', '\n', 'where ', '\\(i\\)', ' and ', '\\(j\\)', ' enumerate spatial locations in ', '\\(f_{1}\\)', ', and ', '\\(q\\)', ' denotes the ', '\\(q^{th}\\)', ' neighborhood of ', '\\(x_{i,j}\\)', '.', '\n', 'Defined in src/operator/correlation.cc:L197', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Crop(*data, **kwargs)Â¶","['\n', 'Note', '\n', 'Crop', '\n', '\n', 'Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or\nwith width and height of the second input symbol, i.e., with one input, we need h_w to\nspecify the crop height and width, otherwise the second input symbolâ\x80\x99s size will be used', '\n', 'Defined in src/operator/crop.cc:L49\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Custom(*data, **kwargs)Â¶","['Apply a custom operator implemented in a frontend language (like Python).', '\n', 'Custom operators should override required methods like ', 'forward', ' and ', 'backward', '.\nThe custom operator must be registered before it can be used.\nPlease check the tutorial here: ', 'https://mxnet.incubator.apache.org/api/faq/new_op', '\n', 'Defined in src/operator/custom/custom.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Deconvolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, adj=_Null, target_shape=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Dropout(data=None, p=_Null, mode=_Null, axes=_Null, cudnn_off=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies dropout operation to input array.', '\n', '\n', 'During training, each element of the input is set to zero with probability p.\nThe whole array is rescaled by ', '\n', 'During testing, this operator does not change the input if mode is â\x80\x98trainingâ\x80\x99.\nIf mode is â\x80\x98alwaysâ\x80\x99, the same computaion as during training will be applied.', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/dropout.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Apply dropout to corrupt input as zero with probability 0.2:', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ElementWiseSum(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Embedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'When â\x80\x9csparse_gradâ\x80\x9d is False, if any index mentioned is too large, it is replaced by the index that\naddresses the last vector in an embedding matrix.\nWhen â\x80\x9csparse_gradâ\x80\x9d is True, an error will be raised if invalid indices are found.', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of weight can be either row_sparse or default.', '\n', '\n', 'Note', '\n', 'If â\x80\x9csparse_gradâ\x80\x9d is set to True, the storage type of gradient w.r.t weights will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L597', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Assume we want to map the 26 English alphabet letters to 16-dimensional\nvectorial representations.', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Flatten(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Flatten is usually applied before ', 'FullyConnected', ', to reshape the 4D tensor\nproduced by convolutional layers to 2D matrix:', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.op.FullyConnected(data=None, weight=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a linear transformation: ', '\\(Y = XW^T + b\\)', '.', '\n', 'If ', 'flatten', ' is set to be true, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'If ', 'flatten', ' is set to be false, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'The learnable parameters include both ', 'weight', ' and ', 'bias', '.', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', '\n', 'Note', '\n', 'The sparse support for FullyConnected is limited to forward evaluation with ', '\n', 'To compute linear transformation with â\x80\x98csrâ\x80\x99 sparse data, sparse.dot is recommended instead\nof sparse.FullyConnected.', '\n', '\n', 'Defined in src/operator/nn/fully_connected.cc:L286', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', 'Construct a fully connected operator with target dimension 512.', '\n', None, '\n', '\n', 'A simple 3-layer MLP with ReLU activation:', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.op.GridGenerator(data=None, transform_type=_Null, target_shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generates 2D sampling grid for bilinear sampling.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.GroupNorm(data=None, gamma=None, beta=None, num_groups=_Null, eps=_Null, output_mean_var=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Group normalization.', '\n', 'The input channels are separated into ', 'num_groups', ' groups, each containing ', 'num_channels', ' channels.\nThe mean and standard-deviation are calculated separately over the each group.', '\n', '\n\\[data = data.reshape((N, num_groups, C // num_groups, ...))\nout = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Defined in src/operator/nn/group_norm.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.IdentityAttachKLSparseReg(data=None, sparseness_target=_Null, penalty=_Null, momentum=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply a sparse regularization to the output a sigmoid activation function.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.InstanceNorm(data=None, gamma=None, beta=None, eps=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies instance normalization to the n-dimensional input array.', '\n', 'This operator takes an n-dimensional input array where (n>2) and normalizes\nthe input using the following formula:', '\n', '\n\\[out = \\frac{x - mean[data]}{ \\sqrt{Var[data]} + \\epsilon} * gamma + beta\\]', '\n', 'This layer is similar to batch normalization layer (', 'BatchNorm', ')\nwith two differences: first, the normalization is\ncarried out per example (instance), not over a batch. Second, the\nsame normalization is applied both at test and train time. This\noperation is also known as ', 'contrast normalization', '.', '\n', 'If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, â\x80¦],\n', 'gamma', ' and ', 'beta', ' parameters must be vectors of shape [channel].', '\n', 'This implementation is based on this paper ', '1', '\n', '\n', '1', '\n', 'Instance Normalization: The Missing Ingredient for Fast Stylization,\nD. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/instance_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.L2Normalization(data=None, eps=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Normalize the input array using the L2 norm.', '\n', 'For 1-D NDArray, it computes:', '\n', None, '\n', '\n', 'For N-D NDArray, if the input array has shape (N, N, â\x80¦, N),', '\n', 'with ', 'mode', ' = ', 'instance', ', it normalizes each instance in the multidimensional\narray by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'channel', ', it normalizes each channel in the array by its L2 norm.:', '\n', None, '\n', '\n', 'with ', 'mode', ' = ', 'spatial', ', it normalizes the cross channel norm for each position\nin the array by its L2 norm.:', '\n', None, '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/l2_normalization.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.LRN(data=None, alpha=_Null, beta=_Null, knorm=_Null, nsize=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies local response normalization to the input.', '\n', 'The local response normalization layer performs â\x80\x9clateral inhibitionâ\x80\x9d by normalizing\nover local input regions.', '\n', 'If ', '\\(a_{x,y}^{i}\\)', ' is the activity of a neuron computed by applying kernel ', '\\(i\\)', ' at position\n', '\\((x, y)\\)', ' and then applying the ReLU nonlinearity, the response-normalized\nactivity ', '\\(b_{x,y}^{i}\\)', ' is given by the expression:', '\n', '\n\\[b_{x,y}^{i} = \\frac{a_{x,y}^{i}}{\\Bigg({k + \\frac{\\alpha}{n} \\sum_{j=max(0, i-\\frac{n}{2})}^{min(N-1, i+\\frac{n}{2})} (a_{x,y}^{j})^{2}}\\Bigg)^{\\beta}}\\]', '\n', 'where the sum runs over ', '\\(n\\)', ' â\x80\x9cadjacentâ\x80\x9d kernel maps at the same spatial position, and ', '\\(N\\)', ' is the total\nnumber of kernels in the layer.', '\n', 'Defined in src/operator/nn/lrn.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.LayerNorm(data=None, gamma=None, beta=None, axis=_Null, eps=_Null, output_mean_var=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Layer normalization.', '\n', 'Normalizes the channels of the input tensor by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis and then\ncompute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\\]', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters.', '\n', 'Unlike BatchNorm and InstanceNorm,  the ', 'mean', ' and ', 'var', ' are computed along the channel dimension.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_std', '. Note that no gradient will be passed through these two outputs.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is -1, which sets the channel\naxis to be the last item in the input shape.', '\n', 'Defined in src/operator/nn/layer_norm.cc:L201', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.LeakyReLU(data=None, gamma=None, act_type=_Null, slope=_Null, lower_bound=_Null, upper_bound=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies Leaky rectified linear unit activation element-wise to the input.', '\n', 'Leaky ReLUs attempt to fix the â\x80\x9cdying ReLUâ\x80\x9d problem by allowing a small ', 'slope', '\nwhen the input is negative and has a slope of one when input is positive.', '\n', 'The following modified ReLU Activation functions are supported:', '\n', '\n', 'elu', '\n', 'selu', '\n', 'leaky', '\n', 'prelu', '\n', 'rrelu', '\n', '\n', 'Defined in src/operator/leaky_relu.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.LinearRegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes and optimizes for squared loss during backward propagation.\nJust outputs ', 'data', ' during forward propagation.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the squared loss estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{SquaredLoss}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert  \\textbf{y}_i - \\hat{\\textbf{y}}_i  \\rVert_2\\)', '\n', '\n', 'Note', '\n', 'Use the LinearRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LinearRegressionOutput(default, default) = default', '\n', 'LinearRegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.LogisticRegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a logistic function to the input.', '\n', 'The logistic function, also known as the sigmoid function, is computed as\n', '\\(\\frac{1}{1+exp(-\\textbf{x})}\\)', '.', '\n', 'Commonly, the sigmoid is used to squash the real-valued output of a linear model\n', '\\(wTx+b\\)', ' into the [0,1] range so that it can be interpreted as a probability.\nIt is suitable for binary classification or probability prediction tasks.', '\n', '\n', 'Note', '\n', 'Use the LogisticRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LogisticRegressionOutput(default, default) = default', '\n', 'LogisticRegressionOutput(default, csr) = default', '\n', '\n', 'The loss function used is the Binary Cross Entropy Loss:', '\n', '\\(-{(y\\log(p) + (1 - y)\\log(1 - p))}\\)', '\n', 'Where ', 'y', ' is the ground truth probability of positive outcome for a given example, and ', 'p', ' the probability predicted by the model. By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L152', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.MAERegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes mean absolute error of the input.', '\n', 'MAE is a risk metric corresponding to the expected value of the absolute error.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the mean absolute error (MAE) estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{MAE}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert \\textbf{y}_i - \\hat{\\textbf{y}}_i \\rVert_1\\)', '\n', '\n', 'Note', '\n', 'Use the MAERegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'MAERegressionOutput(default, default) = default', '\n', 'MAERegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L120', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.MakeLoss(data=None, grad_scale=_Null, valid_thresh=_Null, normalization=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'MakeLoss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'In addition, we can give a scale to the loss by setting ', 'grad_scale', ',\nso that the gradient of the loss will be rescaled in the backpropagation.', '\n', '\n', 'Note', '\n', 'This operator should be used as a Symbol instead of NDArray.', '\n', '\n', 'Defined in src/operator/make_loss.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Pooling(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs pooling on the input.', '\n', 'The shapes for 1-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The shapes for 2-D pooling are', '\n', '\n', 'data', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'When ', 'global_pool', ' is set to be true, then global pooling is performed. It will reset\n', 'kernel=(height,', ' and set the appropiate padding to 0.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', 'lp', '\n', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data and output will have shape ', '(batch_size, channel, depth,\nheight, width)', ' (NCDHW layout) or ', '(batch_size, depth, height, width, channel)', ' (NDHWC layout).', '\n', 'Notes on Lp pooling:', '\n', 'Lp pooling was first introduced by this paper: ', 'https://arxiv.org/pdf/1204.3968.pdf', '.\nL-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.\nWe can see that Lp pooling stands between those two, in practice the most common value for p is 2.', '\n', 'For each window ', 'X', ', the mathematical expression for Lp pooling is:', '\n', '\\(f(X) = \\sqrt[p]{\\sum_{x}^{X} x^p}\\)', '\n', 'Defined in src/operator/nn/pooling.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Pooling_v1(data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator is DEPRECATED.\nPerform pooling on the input.', '\n', 'The shapes for 2-D pooling is', '\n', '\n', 'data', '\n', 'out', '\n', '\n', 'The definition of ', 'f', ' depends on ', 'pooling_convention', ', which has two options:', '\n', '\n', 'valid', '\n', 'full', '\n', '\n', 'But ', 'global_pool', ' is set to be true, then do a global pooling, namely reset\n', 'kernel=(height,', '.', '\n', 'Three pooling options are supported by ', 'pool_type', ':', '\n', '\n', 'avg', '\n', 'max', '\n', 'sum', '\n', '\n', '1-D pooling is special case of 2-D pooling with ', 'weight=1', ' and\n', 'kernel[1]=1', '.', '\n', 'For 3-D pooling, an additional ', 'depth', ' dimension is added before\n', 'height', '. Namely the input data will have shape ', '(batch_size, channel, depth,\nheight, width)', '.', '\n', 'Defined in src/operator/pooling_v1.cc:L103', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.RNN(data=None, parameters=None, state=None, state_cell=None, sequence_length=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are\nimplemented, with both multi-layer and bidirectional support.', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', 'Vanilla RNN', '\n', 'Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:\nReLU and Tanh.', '\n', 'With ReLU activation function:', '\n', '\n\\[h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'With Tanh activtion function:', '\n', '\n\\[h_t = \\tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\\]', '\n', 'Reference paper: Finding structure in time - Elman, 1988.\n', 'https://crl.ucsd.edu/~elman/Papers/fsit.pdf', '\n', 'LSTM', '\n', 'Long Short-Term Memory - Hochreiter, 1997. ', 'http://www.bioinf.jku.at/publications/older/2604.pdf', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          \\end{array}\\end{split}\\]', '\n', 'With the projection size being set, LSTM could use the projection feature to reduce the parameters\nsize and give some speedups without significant damage to the accuracy.', '\n', 'Long Short-Term Memory Based Recurrent Neural Network Architectures for Large Vocabulary Speech\nRecognition - Sak et al. 2014. ', 'https://arxiv.org/abs/1402.1128', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{ri} r_{(t-1)} + b_{ri}) \\\\\n          f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{rf} r_{(t-1)} + b_{rf}) \\\\\n          g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{rc} r_{(t-1)} + b_{rg}) \\\\\n          o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{o} + W_{ro} r_{(t-1)} + b_{ro}) \\\\\n          c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n          h_t = o_t * \\tanh(c_t)\n          r_t = W_{hr} h_t\n          \\end{array}\\end{split}\\]', '\n', 'GRU', '\n', 'Gated Recurrent Unit - Cho et al. 2014. ', 'http://arxiv.org/abs/1406.1078', '\n', 'The definition of GRU here is slightly different from paper but compatible with CUDNN.', '\n', '\n\\[\\begin{split}\\begin{array}{ll}\n          r_t = \\mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\\\\n          z_t = \\mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\\\\n          n_t = \\tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\\\\n          h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\\\\n          \\end{array}\\end{split}\\]', '\n', 'Defined in src/operator/rnn.cc:L375', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ROIPooling(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs region of interest(ROI) pooling on the input array.', '\n', 'ROI pooling is a variant of a max pooling layer, in which the output size is fixed and\nregion of interest is a parameter. Its purpose is to perform max pooling on the inputs\nof non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net\nlayer mostly used in training a ', 'Fast R-CNN', ' network for object detection.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen it pools over sub-regions of input and produces a fixed-sized output array\nregardless of the ROI size.', '\n', 'To crop the feature map accordingly, you can resize the bounding box coordinates\nby changing the parameters ', 'rois', ' and ', 'spatial_scale', '.', '\n', 'The cropped feature maps are pooled by standard max pooling operation to a fixed size output\nindicated by a ', 'pooled_size', ' parameter. batch_size will change to the number of region\nbounding boxes after ', 'ROIPooling', '.', '\n', 'The size of each region of interest doesnâ\x80\x99t have to be perfectly divisible by\nthe number of pooling sections(', 'pooled_size', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/roi_pooling.cc:L224', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SVMOutput(data=None, label=None, margin=_Null, regularization_coefficient=_Null, use_linear=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes support vector machine based transformation of the input.', '\n', 'This tutorial demonstrates using SVM as output layer for classification instead of softmax:\n', 'https://github.com/apache/mxnet/tree/v1.x/example/svm_mnist', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SequenceLast(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Takes the last element of a sequence.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array\nof the form [batch_size, other_feature_dims].', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', ' should be\nan input array of positive ints of dimension [batch_size]. To use this parameter,\nset ', 'use_sequence_length', ' to ', 'True', ', otherwise each example in the batch is assumed\nto have the max sequence length.', '\n', '\n', 'Note', '\n', 'Alternatively, you can also use ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_last.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SequenceMask(data=None, sequence_length=None, use_sequence_length=_Null, value=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Sets all elements outside the sequence to a constant value.', '\n', 'This function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences. ', 'sequence_length', '\nshould be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length and\nthis operator works as the ', 'identity', ' operator.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_mask.cc:L185', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SequenceReverse(data=None, sequence_length=None, use_sequence_length=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reverses the elements of each sequence.', '\n', 'This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]\nand returns an array of the same shape.', '\n', 'Parameter ', 'sequence_length', ' is used to handle variable-length sequences.\n', 'sequence_length', ' should be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set ', 'use_sequence_length', ' to ', 'True', ',\notherwise each example in the batch is assumed to have the max sequence length.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/sequence_reverse.cc:L121', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SliceChannel(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.Softmax(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SoftmaxActivation(data=None, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies softmax activation to input. This is intended for internal layers.', '\n', '\n', 'Note', '\n', 'This operator has been deprecated, please use ', '\n', '\n', 'If ', 'mode', ' = ', 'instance', ', this operator will compute a softmax for each instance in the batch.\nThis is the default mode.', '\n', 'If ', 'mode', ' = ', 'channel', ', this operator will compute a k-class softmax at each position\nof each instance, where ', 'k', ' = ', 'num_channel', '. This mode can only be used when the input array\nhas at least 3 dimensions.\nThis can be used for ', 'fully convolutional network', ', ', 'image segmentation', ', etc.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax_activation.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SoftmaxOutput(data=None, label=None, grad_scale=_Null, ignore_label=_Null, multi_output=_Null, use_ignore=_Null, preserve_shape=_Null, normalization=_Null, out_grad=_Null, smooth_alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the gradient of cross entropy loss with respect to softmax output.', '\n', '\n', 'This operator computes the gradient in two steps.\nThe cross entropy loss does not actually need to be computed.', '\n', 'The softmax function, cross entropy loss and gradient is given by:', '\n', 'During forward propagation, the softmax function is computed for each instance in the input array.', '\n', 'During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\nThe provided label can be a one-hot label array or a probability label array.', '\n', '\n', 'Defined in src/operator/softmax_output.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SpatialTransformer(data=None, loc=None, target_shape=_Null, transform_type=_Null, sampler_type=_Null, cudnn_off=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a spatial transformer to input feature map.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.SwapAxis(data=None, dim1=_Null, dim2=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.UpSampling(*data, **kwargs)Â¶","['Upsamples the given input data.', '\n', 'Two algorithms (', 'sample_type', ') are available for upsampling:', '\n', '\n', 'Nearest Neighbor', '\n', 'Bilinear', '\n', '\n', 'Nearest Neighbor Upsampling', '\n', 'Input data is expected to be NCHW.', '\n', 'Example:', '\n', None, '\n', '\n', 'Bilinear Upsampling', '\n', 'Uses ', 'deconvolution', ' algorithm under the hood. You need provide both input data and the kernel.', '\n', 'Input data is expected to be NCHW.', '\n', 'num_filter', ' is expected to be same as the number of channels.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/upsampling.cc:L172\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.abs(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise absolute value of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'abs', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L720', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.adam_update(weight=None, grad=None, mean=None, var=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Adam optimizer. Adam is seen as a generalization\nof AdaGrad.', '\n', 'Adam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nW_t = W_{t-1} - \\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon }\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and the storage\ntype of weight is the same as those of m and v,\nonly the row slices whose indices appear in grad.indices are updated (for w, m and v):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L687', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.add_n(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.all_finite(data=None, init_output=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Check if all the float numbers in the array are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.amp_cast(data=None, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Cast function between low precision float/FP32 used by AMP.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L125', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.amp_multicast(*data, **kwargs)Â¶","['Cast function used by AMP, that casts its inputs to the common widest type.', '\n', 'It casts only between low precision float/FP32 and does not do anything for other types.', '\n', 'Defined in src/operator/tensor/amp_cast.cc:L169', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.arccos(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse cosine of the input array.', '\n', 'The input should be in range ', '[-1, 1]', '.\nThe output is in the closed interval ', '\\([0, \\pi]\\)', '\n', '\n\\[arccos([-1, -.707, 0, .707, 1]) = [\\pi, 3\\pi/4, \\pi/2, \\pi/4, 0]\\]', '\n', 'The storage type of ', 'arccos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.arccosh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arccosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L535', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.arcsin(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse sine of the input array.', '\n', 'The input should be in the range ', '[-1, 1]', '.\nThe output is in the closed interval of [', '\\(-\\pi/2\\)', ', ', '\\(\\pi/2\\)', '].', '\n', '\n\\[arcsin([-1, -.707, 0, .707, 1]) = [-\\pi/2, -\\pi/4, 0, \\pi/4, \\pi/2]\\]', '\n', 'The storage type of ', 'arcsin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.arcsinh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arcsinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.arctan(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse tangent of the input array.', '\n', 'The output is in the closed interval ', '\\([-\\pi/2, \\pi/2]\\)', '\n', '\n\\[arctan([-1, 0, 1]) = [-\\pi/4, 0, \\pi/4]\\]', '\n', 'The storage type of ', 'arctan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L282', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.arctanh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.', '\n', 'The storage type of ', 'arctanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L579', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.argmax(data=None, axis=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns indices of the maximum values along an axis.', '\n', 'In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L51', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.argmax_channel(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns argmax indices of each channel from the input array.', '\n', 'The result will be an NDArray of shape (num_channel,).', '\n', 'In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.argmin(data=None, axis=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns indices of the minimum values along an axis.', '\n', 'In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence\nare returned.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L76', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.argsort(data=None, axis=_Null, is_ascend=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the indices that would sort an input array along the given axis.', '\n', 'This function performs sorting along the given axis and returns an array of indices having same shape\nas an input array that index data in sorted order.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L184', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.batch_dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batchwise dot product.', '\n', 'batch_dot', ' is used to compute dot product of ', 'x', ' and ', 'y', ' when ', 'x', ' and\n', 'y', ' are data in batch, namely N-D (N >= 3) arrays in shape of ', '(B0, â\x80¦, B_i, :, :)', '.', '\n', 'For example, given ', 'x', ' with shape ', '(B_0, â\x80¦, B_i, N, M)', ' and ', 'y', ' with shape\n', '(B_0, â\x80¦, B_i, M, K)', ', the result array will have shape ', '(B_0, â\x80¦, B_i, N, K)', ',\nwhich is computed by:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L127', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.batch_take(a=None, indices=None, name=None, attr=None, out=None, **kwargs)Â¶","['Takes elements from a data batch.', '\n', '\n', 'Note', '\n', 'batch_take', '\n', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_add(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_axes(data=None, axis=_Null, size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_axis(data=None, axis=_Null, size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts the input array over particular axes.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'broadcast_axes', ' is an alias to the function ', 'broadcast_axis', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_div(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_div(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'equal to', ' (==) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L45', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_greater(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than', ' (>) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L81', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_greater_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'greater than or equal to', ' (>=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_hypot(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hypotenuse of a right angled triangle, given its â\x80\x9clegsâ\x80\x9d\nwith broadcasting.', '\n', 'It is equivalent to doing ', '\\(sqrt(x_1^2 + x_2^2)\\)', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L157', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_lesser(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than', ' (<) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L117', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_lesser_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'lesser than or equal to', ' (<=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_like(lhs=None, rhs=None, lhs_axes=_Null, rhs_axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts lhs to have the same shape as rhs.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_logical_and(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical and', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_logical_or(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical or', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L171', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_logical_xor(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'logical xor', ' with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L189', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_maximum(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise maximum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise maxima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_minimum(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise minimum of the input arrays with broadcasting.', '\n', 'This function compares two input arrays and returns a new array having the element-wise minima.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_minus(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_mod(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise modulo of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_mul(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_mul(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L145', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_not_equal(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of element-wise ', 'not equal to', ' (!=) comparison operation with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L63', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_plus(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_power(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns result of first array elements raised to powers from second array, element-wise with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L44', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_sub(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.broadcast_to(data=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Broadcasts the input array to a new shape.', '\n', 'Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, ', 'Broadcasting', ' for more explanation.', '\n', 'Broadcasting is allowed on axes with size 1, such as from ', '(2,1,3,1)', ' to\n', '(2,8,3,9)', '. Elements will be duplicated on the broadcasted axes.', '\n', 'For example:', '\n', None, '\n', '\n', 'The dimension which you do not want to change can also be kept as ', '0', ' which means copy the original value.\nSo with ', 'shape=(2,0)', ', we will obtain the same result as in the above example.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L116', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.cast(data=None, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.cast_storage(data=None, stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Casts tensor storage type to the new type.', '\n', 'When an NDArray with default storage type is cast to csr or row_sparse storage,\nthe result is compact, which means:', '\n', '\n', 'for csr, zero values will not be retained', '\n', 'for row_sparse, row slices of all zeros will not be retained', '\n', '\n', 'The storage type of ', 'cast_storage', ' output depends on stype parameter:', '\n', '\n', 'cast_storage(csr, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(row_sparse, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(default, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(default, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', 'cast_storage(csr, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(row_sparse, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/cast_storage.cc:L71', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.cbrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise cube-root value of the input.', '\n', '\n\\[cbrt(x) = \\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'cbrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L270', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ceil(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise ceiling of the input.', '\n', 'The ceil of the scalar x is the smallest integer i, such that i >= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'ceil', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L817', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.choose_element_0index(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.clip(data=None, a_min=_Null, a_max=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Clips (limits) the values in an array.\nGiven an interval, values outside the interval are clipped to the interval edges.\nClipping ', 'x', ' between ', 'a_min', ' and ', 'a_max', ' would be::\n.. math:', '\n', None, '\n', '\n', '\n', 'Example::', 'x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nclip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]', '\n', '\n', 'The storage type of ', 'clip', ' output depends on storage types of inputs and the a_min, a_max parameter values:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L676', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.col2im(data=None, output_size=_Null, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Combining the output column matrix of im2col back to image array.', '\n', 'Like ', 'im2col', ', this operator is also used in the vanilla convolution\nimplementation. Despite the name, col2im is not the reverse operation of im2col. Since there\nmay be overlaps between neighbouring sliding blocks, the column elements cannot be directly\nput back into image. Instead, they are accumulated (i.e., summed) in the input image\njust like the gradient computation, so col2im is the gradient of im2col and vice versa.', '\n', 'Using the notation in im2col, given an input column array of shape\n', '\\((N, C \\times  \\prod(\\text{kernel}), W)\\)', ', this operator accumulates the column elements\ninto output array of shape ', '\\((N, C, \\text{output_size}[0], \\text{output_size}[1], \\dots)\\)', '.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L181', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.cos(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise cosine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[cos([0, \\pi/4, \\pi/2]) = [1, 0.707, 0]\\]', '\n', 'The storage type of ', 'cos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.cosh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic cosine  of the input array, computed element-wise.', '\n', '\n\\[cosh(x) = 0.5\\times(exp(x) + exp(-x))\\]', '\n', 'The storage type of ', 'cosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L409', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.crop(data=None, begin=_Null, end=_Null, step=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.cumsum(a=None, axis=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Return the cumulative sum of the elements along a given axis.', '\n', 'Defined in src/operator/numpy/np_cumsum.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.degrees(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Converts each element of the input array from radians to degrees.', '\n', '\n\\[degrees([0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]) = [0, 90, 180, 270, 360]\\]', '\n', 'The storage type of ', 'degrees', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.depth_to_space(data=None, block_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Rearranges(permutes) data from depth into blocks of spatial data.\nSimilar to ONNX DepthToSpace operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace', '.\nThe output is a new tensor where the values from depth dimension are moved in spatial blocks\nto height and width dimension. The reverse of this operation is ', 'space_to_depth', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C / (block\\_size ^ 2), H * block\\_size, W * block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L971', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.diag(data=None, k=_Null, axis1=_Null, axis2=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts a diagonal or constructs a diagonal array.', '\n', 'diag', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.', '\n', 'N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/diag_op.cc:L86', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Dot product of two arrays.', '\n', 'dot', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: inner product of vectors', '\n', '2-D arrays: matrix multiplication', '\n', 'N-D arrays: a sum product over the last axis of the first input and the first\naxis of the second input', '\n', '\n', 'The storage type of ', 'dot', ' output depends on storage types of inputs, transpose option and\nforward_stype option for output storage type. Implemented sparse operations include:', '\n', '\n', 'dot(default, default, transpose_a=True/False, transpose_b=True/False) = default', '\n', 'dot(csr, default, transpose_a=True) = default', '\n', 'dot(csr, default, transpose_a=True) = row_sparse', '\n', 'dot(csr, default) = default', '\n', 'dot(csr, row_sparse) = default', '\n', 'dot(default, csr) = csr (CPU only)', '\n', 'dot(default, csr, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', 'dot(default, csr, transpose_b=True, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', '\n', 'If the combination of input storage types and forward_stype does not match any of the\nabove patterns, ', 'dot', ' will fallback and generate output with default storage.', '\n', '\n', 'Note', '\n', 'If the storage type of the lhs is â\x80\x9ccsrâ\x80\x9d, the storage type of gradient w.r.t rhs will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.elemwise_add(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Adds arguments element-wise.', '\n', 'The storage type of ', 'elemwise_add', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.elemwise_div(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Divides arguments element-wise.', '\n', 'The storage type of ', 'elemwise_div', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.elemwise_mul(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplies arguments element-wise.', '\n', 'The storage type of ', 'elemwise_mul', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.elemwise_sub(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Subtracts arguments element-wise.', '\n', 'The storage type of ', 'elemwise_sub', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.erf(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L886', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.erfinv(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse gauss error function of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L908', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.exp(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise exponential value of the input.', '\n', '\n\\[exp(x) = e^x \\approx 2.718^x\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'exp', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L64', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.expand_dims(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Inserts a new axis of size 1 into the array shape\nFor example, given ', 'x', ' with shape ', '(2,3,4)', ', then ', 'expand_dims(x,', '\nwill return a new array with shape ', '(2,1,3,4)', '.', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L394', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.expm1(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns ', 'exp(x)', ' computed element-wise on the input.', '\n', 'This function provides greater precision than ', 'exp(x)', ' for small values of ', 'x', '.', '\n', 'The storage type of ', 'expm1', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.fill_element_0index(lhs=None, mhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.fix(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer towards zero of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'fix', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L874', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.flatten(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Flattens the input array into a 2-D array by collapsing the higher dimensions.\n.. note:: ', 'Flatten', ' is deprecated. Use ', 'flatten', ' instead.\nFor an input array with shape ', '(d1,', ', ', 'flatten', ' operation reshapes\nthe input array into an output array of shape ', '(d1,', '.\nNote that the behavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.flip(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.floor(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise floor of the input.', '\n', 'The floor of the scalar x is the largest integer i, such that i <= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'floor', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L836', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ftml_update(weight=None, grad=None, d=None, v=None, z=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, wd=_Null, rescale_grad=_Null, clip_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['The FTML optimizer described in\n', 'FTML - Follow the Moving Leader in Deep Learning', ',\navailable at ', 'http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf', '.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nd_t = \\frac{ 1 - \\beta_1^t }{ \\eta_t } (\\sqrt{ \\frac{ v_t }{ 1 - \\beta_2^t } } + \\epsilon)\n\\sigma_t = d_t - \\beta_1 d_{t-1}\nz_t = \\beta_1 z_{ t-1 } + (1 - \\beta_1^t) g_t - \\sigma_t W_{t-1}\nW_t = - \\frac{ z_t }{ d_t }\\end{split}\\]', '\n', 'Defined in src/operator/optimizer_op.cc:L639', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ftrl_update(weight=None, grad=None, z=None, n=None, lr=_Null, lamda1=_Null, beta=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Ftrl optimizer.\nReferenced from ', 'Ad Click Prediction: a View from the Trenches', ', available at\n', 'http://dl.acm.org/citation.cfm?id=2488200', '.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'If w, z and n are all of ', 'row_sparse', ' storage type,\nonly the row slices whose indices appear in grad.indices are updated (for w, z and n):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L875', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.gamma(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.', '\n', 'The storage type of ', 'gamma', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.gammaln(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise log of the absolute value of the gamma function of the input.', '\n', 'The storage type of ', 'gammaln', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.gather_nd(data=None, indices=None, name=None, attr=None, out=None, **kwargs)Â¶","['Gather elements or slices from ', 'data', ' and store to a tensor whose\nshape is defined by ', 'indices', '.', '\n', 'Given ', 'data', ' with shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', output shape will simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.hard_sigmoid(data=None, alpha=_Null, beta=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes hard sigmoid of x element-wise.', '\n', '\n\\[y = max(0, min(1, alpha * x + beta))\\]', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L161', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.identity(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a copy of the input.', '\n', 'From:src/operator/tensor/elemwise_unary_op_basic.cc:244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.im2col(data=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extract sliding blocks from input array.', '\n', 'This operator is used in vanilla convolution implementation to transform the sliding\nblocks on image to column matrix, then the convolution operation can be computed\nby matrix multiplication between column and convolution weight. Due to the close\nrelation between im2col and convolution, the concept of ', 'kernel', ', ', 'stride', ',\n', 'dilate', ' and ', 'pad', ' in this operator are inherited from convolution operation.', '\n', 'Given the input data of shape ', '\\((N, C, *)\\)', ', where ', '\\(N\\)', ' is the batch size,\n', '\\(C\\)', ' is the channel size, and ', '\\(*\\)', ' is the arbitrary spatial dimension,\nthe output column array is always with shape ', '\\((N, C \\times \\prod(\\text{kernel}), W)\\)', ',\nwhere ', '\\(C \\times \\prod(\\text{kernel})\\)', ' is the block size, and ', '\\(W\\)', ' is the\nblock number which is the spatial size of the convolution output with same input parameters.\nOnly 1-D, 2-D and 3-D of spatial dimension is supported in this operator.', '\n', 'Defined in src/operator/nn/im2col.cc:L99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.khatri_rao(*args, **kwargs)Â¶","['Computes the Khatri-Rao product of the input matrices.', '\n', 'Given a collection of ', '\\(n\\)', ' input matrices,', '\n', '\n\\[A_1 \\in \\mathbb{R}^{M_1 \\times M}, \\ldots, A_n \\in \\mathbb{R}^{M_n \\times N},\\]', '\n', 'the (column-wise) Khatri-Rao product is defined as the matrix,', '\n', '\n\\[X = A_1 \\otimes \\cdots \\otimes A_n \\in \\mathbb{R}^{(M_1 \\cdots M_n) \\times N},\\]', '\n', 'where the ', '\\(k\\)', ' th column is equal to the column-wise outer product\n', '\\({A_1}_k \\otimes \\cdots \\otimes {A_n}_k\\)', ' where ', '\\({A_i}_k\\)', ' is the kth\ncolumn of the ith matrix.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/krprod.cc:L108\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.lamb_update_phase1(weight=None, grad=None, mean=None, var=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Phase I of lamb update it performs the following operations and returns g:.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\ngrad = grad * rescale_grad\nif (grad < -clip_gradient)\nthen\n     grad = -clip_gradient\nif (grad > clip_gradient)\nthen\n     grad = clip_gradient\\\\mean = beta1 * mean + (1 - beta1) * grad;\nvariance = beta2 * variance + (1. - beta2) * grad ^ 2;\\\\if (bias_correction)\nthen\n     mean_hat = mean / (1. - beta1^t);\n     var_hat = var / (1 - beta2^t);\n     g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;\nelse\n     g = mean / (var_data^(1/2) + epsilon) + wd * weight;\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L952', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.lamb_update_phase2(weight=None, g=None, r1=None, r2=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Phase II of lamb update it performs the following operations and updates grad.', '\n', 'Link to paper: ', 'https://arxiv.org/pdf/1904.00962.pdf', '\n', '\n\\[ \\begin{align}\\begin{aligned}\\begin{gather*}\nif (lower_bound >= 0)\nthen\n     r1 = max(r1, lower_bound)\nif (upper_bound >= 0)\nthen\n     r1 = max(r1, upper_bound)\\\\if (r1 == 0 or r2 == 0)\nthen\n     lr = lr\nelse\n     lr = lr * (r1/r2)\nweight = weight - lr * g\n\\end{gather*}\\end{aligned}\\end{align} \\]', '\n', 'Defined in src/operator/optimizer_op.cc:L991', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_det(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'det', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'There is no gradient backwarded when A is non-invertible (which is\nequivalent to det(A) = 0) because zero is rarely hit upon in float\npoint computation and the Jacobiâ\x80\x99s formula on determinant gradient\nis not computationally efficient when A is non-invertible.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L974', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_extractdiag(A=None, offset=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts the diagonal entries of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an ', 'n-1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_extracttrian(A=None, offset=_Null, lower=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Extracts a triangular sub-matrix from a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', then ', 'A', ' represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.', '\n', 'If ', 'n>2', ', then ', 'A', ' represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an ', 'n-1', '-dimensional tensor.', '\n', 'The ', 'offset', ' and ', 'lower', ' parameters determine the triangle to be extracted:', '\n', '\n', 'When ', '\n', 'When ', '\n', 'When ', '\n', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L604', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_gelqf(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['LQ factorization for general matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', we compute the LQ factorization (LAPACK ', 'gelqf', ', followed by ', 'orglq', '). ', 'A', '\nmust have shape ', '(x, y)', ' with ', 'x <= y', ', and must have full rank ', '=x', '. The LQ\nfactorization consists of ', 'L', ' with shape ', '(x, x)', ' and ', 'Q', ' with shape ', '(x, y)', ', so\nthat:', '\n', '\n', 'A', '\n', 'Here, ', 'L', ' is lower triangular (upper triangle equal to zero) with nonzero diagonal,\nand ', 'Q', ' is row-orthonormal, meaning that', '\n', '\n', 'Q', '\n', 'is equal to the identity matrix of shape ', '(x, x)', '.', '\n', 'If ', 'n>2', ', ', 'gelqf', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L797', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_gemm(A=None, B=None, C=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, beta=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs general matrix multiplication and accumulation.\nInput are tensors ', 'A', ', ', 'B', ', ', 'C', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here, ', 'alpha', ' and ', 'beta', ' are scalar parameters, and ', 'op()', ' is either the identity or\nmatrix transposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ', ', 'C', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', ', 'C', ', axis=1) is equivalent\nto the following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_gemm2(A=None, B=None, transpose_a=_Null, transpose_b=_Null, alpha=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs general matrix multiplication.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', the BLAS3 function ', 'gemm', ' is performed:', '\n', '\n', 'out', '\n', 'Here ', 'alpha', ' is a scalar parameter and ', 'op()', ' is either the identity or the matrix\ntransposition (depending on ', 'transpose_a', ', ', 'transpose_b', ').', '\n', 'If ', 'n>2', ', ', 'gemm', ' is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the ', 'axis', '\nparameter. By default, the trailing two dimensions will be used for matrix encoding.', '\n', 'For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let ', 'A', ', ', 'B', ' be 5 dimensional tensors. Then gemm(', 'A', ', ', 'B', ', axis=1) is equivalent to\nthe following without the overhead of the additional swapaxis operations:', '\n', None, '\n', '\n', 'When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L162', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_inverse(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the inverse of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'inverse', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L919', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_makediag(A=None, offset=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Constructs a square matrix with the input as diagonal.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.\nIf ', 'n>1', ', then ', 'A', ' represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L546', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_maketrian(A=None, offset=_Null, lower=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Constructs a square matrix with the input representing a specific triangular sub-matrix.\nThis is basically the inverse of ', 'linalg.extracttrian', '. Input is a tensor ', 'A', ' of dimension ', 'n >= 1', '.', '\n', 'If ', 'n=1', ', then ', 'A', ' represents the entries of a triangular matrix which is lower triangular if ', 'offset<0', ' or ', 'offset=0', ', ', 'lower=true', '. The resulting matrix is derived by first constructing the square\nmatrix with the entries outside the triangle set to zero and then adding ', 'offset', '-times an additional\ndiagonal with zero entries to the square matrix.', '\n', 'If ', 'n>1', ', then ', 'A', ' represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an ', 'n+1', '-dimensional tensor.', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L672', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_potrf(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Performs Cholesky factorization of a symmetric positive-definite matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the Cholesky factor ', 'B', ' of the symmetric, positive definite matrix ', 'A', ' is\ncomputed. ', 'B', ' is triangular (entries of upper or lower triangle are all zero), has\npositive diagonal entries, and:', '\n', '\n', 'A', '\n', 'If ', 'n>2', ', ', 'potrf', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_potri(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Performs matrix inversion from a Cholesky factorization.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a triangular matrix (entries of upper or lower triangle are all zero)\nwith positive diagonal. We compute:', '\n', '\n', 'out', '\n', 'In other words, if ', 'A', ' is the Cholesky factor of a symmetric positive definite matrix\n', 'B', ' (obtained by ', 'potrf', '), then', '\n', '\n', 'out', '\n', 'If ', 'n>2', ', ', 'potri', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'Use this operator only if you are certain you need the inverse of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L274', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_slogdet(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the sign and log of the determinant of a matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' is a square matrix. We compute:', '\n', '\n', 'sign', '\n', 'If ', 'n>2', ', ', 'slogdet', ' is performed separately on the trailing two dimensions\nfor all inputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', '\n', 'Note', '\n', 'The gradient is not properly defined on sign, so the gradient of\nit is not backwarded.', '\n', '\n', '\n', 'Note', '\n', 'No gradient is backwarded when A is non-invertible. Please see\nthe docs of operator det for detail.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L1033', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_sumlogdiag(A=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of the logarithms of the diagonal elements of a square matrix.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', ', 'A', ' must be square with positive diagonal entries. We sum the natural\nlogarithms of the diagonal elements, the result has shape (1,).', '\n', 'If ', 'n>2', ', ', 'sumlogdiag', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L444', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_syrk(A=None, transpose=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplication of matrix with its transpose.\nInput is a tensor ', 'A', ' of dimension ', 'n >= 2', '.', '\n', 'If ', 'n=2', ', the operator performs the BLAS3 function ', 'syrk', ':', '\n', '\n', 'out', '\n', 'if ', 'transpose=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'transpose=True', '.', '\n', 'If ', 'n>2', ', ', 'syrk', ' is performed separately on the trailing two dimensions for all\ninputs (batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L729', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_trmm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs multiplication with a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trmm', ':', '\n', '\n', 'out', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trmm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.linalg_trsm(A=None, B=None, transpose=_Null, rightside=_Null, lower=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Solves matrix equation involving a lower triangular matrix.\nInput are tensors ', 'A', ', ', 'B', ', each of dimension ', 'n >= 2', ' and having the same shape\non the leading ', 'n-2', ' dimensions.', '\n', 'If ', 'n=2', ', ', 'A', ' must be triangular. The operator performs the BLAS3 function\n', 'trsm', ', solving for ', 'out', ' in:', '\n', '\n', 'op', '\n', 'if ', 'rightside=False', ', or', '\n', '\n', 'out', '\n', 'if ', 'rightside=True', '. Here, ', 'alpha', ' is a scalar parameter, and ', 'op()', ' is either the\nidentity or the matrix transposition (depending on ', 'transpose', ').', '\n', 'If ', 'n>2', ', ', 'trsm', ' is performed separately on the trailing two dimensions for all inputs\n(batch mode).', '\n', '\n', 'Note', '\n', 'The operator supports float32 and float64 data types only.', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/la_op.cc:L395', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.log(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Natural logarithmic value of the input.', '\n', 'The natural logarithm is logarithm in base ', 'e', ', so that ', 'log(exp(x))', '\n', 'The storage type of ', 'log', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.log10(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Base-10 logarithmic value of the input.', '\n', '10**log10(x)', '\n', 'The storage type of ', 'log10', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.log1p(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise ', 'log(1', ' value of the input.', '\n', 'This function is more accurate than ', 'log(1', '  for small ', 'x', ' so that\n', '\\(1+x\\approx 1\\)', '\n', 'The storage type of ', 'log1p', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.log2(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Base-2 logarithmic value of the input.', '\n', '2**log2(x)', '\n', 'The storage type of ', 'log2', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.log_softmax(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the log softmax of the input.\nThis is equivalent to computing softmax followed by log.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.logical_not(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the result of logical NOT (!) function', '\n', 'Example', '\n', 'logical_not([-2., 0., 1.]) = [0., 1., 0.]', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.make_loss(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'make_loss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'The storage type of ', 'make_loss', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L358', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.max(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.max_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the max of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L31', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.mean(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the mean of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.min(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.min_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the min of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.moments(data=None, axes=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Calculate the mean and variance of ', 'data', '.', '\n', 'The mean and variance are calculated by aggregating the contents of data across axes.\nIf x is 1-D and axes = [0] this is just the mean and variance of a vector.', '\n', 'Example', '\n', 'x = [[1, 2, 3], [4, 5, 6]]\nmean, var = moments(data=x, axes=[0])\nmean = [2.5, 3.5, 4.5]\nvar = [2.25, 2.25, 2.25]\nmean, var = moments(data=x, axes=[1])\nmean = [2.0, 5.0]\nvar = [0.66666667, 0.66666667]\nmean, var = moments(data=x, axis=[0, 1])\nmean = [3.5]\nvar = [2.9166667]', '\n', 'Defined in src/operator/nn/moments.cc:L53', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.mp_lamb_update_phase1(weight=None, grad=None, mean=None, var=None, weight32=None, beta1=_Null, beta2=_Null, epsilon=_Null, t=_Null, bias_correction=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Mixed Precision version of Phase I of lamb update\nit performs the following operations and returns g:.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1032', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.mp_lamb_update_phase2(weight=None, g=None, r1=None, r2=None, weight32=None, lr=_Null, lower_bound=_Null, upper_bound=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Mixed Precision version Phase II of lamb update\nit performs the following operations and updates grad.', '\n', '\n', 'Link to paper: ', '\n', 'Defined in src/operator/optimizer_op.cc:L1074', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.mp_nag_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.', '\n', 'Defined in src/operator/optimizer_op.cc:L744', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.mp_sgd_mom_update(weight=None, grad=None, mom=None, weight32=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.mp_sgd_update(weight=None, grad=None, weight32=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Updater function for multi-precision sgd optimizer', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.multi_all_finite(*data, **kwargs)Â¶","['Check if all the float numbers in all the arrays are finite (used for AMP)', '\n', 'Defined in src/operator/contrib/all_finite.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.multi_lars(lrs=None, weights_sum_sq=None, grads_sum_sq=None, wds=None, eta=_Null, eps=_Null, rescale_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the LARS coefficients of multiple weights and grads from their sums of squareâ\x80\x9d', '\n', 'Defined in src/operator/contrib/multi_lars.cc:L36', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L471', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L416', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/optimizer_op.cc:L373', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L328', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.multi_sum_sq(*data, **kwargs)Â¶","['Compute the sums of squares of multiple arrays', '\n', 'Defined in src/operator/contrib/multi_sum_sq.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.nag_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Nesterov Accelerated Gradient( NAG) optimizer.\nIt updates the weights using the following formula,', '\n', '\n\\[\\begin{split}v_t = \\gamma v_{t-1} + \\eta * \\nabla J(W_{t-1} - \\gamma v_{t-1})\\\\\nW_t = W_{t-1} - v_t\\end{split}\\]', '\n', 'Where\n', '\\(\\eta\\)', ' is the learning rate of the optimizer\n', '\\(\\gamma\\)', ' is the decay rate of the momentum estimate\n', '\\(\\v_t\\)', ' is the update vector at time step ', 't', '\n', '\\(\\W_t\\)', ' is the weight vector at time step ', 't', '\n', 'Defined in src/operator/optimizer_op.cc:L725', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.nanprod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the product of array elements over given axes treating Not a Numbers (', 'NaN', ') as one.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_prod_value.cc:L46', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.nansum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of array elements over given axes treating Not a Numbers (', 'NaN', ') as zero.', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.negative(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Numerical negative of the argument, element-wise.', '\n', 'The storage type of ', 'negative', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.norm(data=None, ord=_Null, axis=_Null, out_dtype=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the norm on an NDArray.', '\n', 'This operator computes the norm on an NDArray with the specified axis, depending\non the value of the ord parameter. By default, it computes the L2 norm on the entire\narray. Currently only ord=2 supports sparse ndarrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_norm_value.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.one_hot(indices=None, depth=_Null, on_value=_Null, off_value=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a one-hot array.', '\n', 'The locations represented by ', 'indices', ' take value ', 'on_value', ', while all\nother locations take value ', 'off_value', '.', '\n', 'one_hot', ' operation with ', 'indices', ' of shape ', '(i0,', ' and ', 'depth', '  of ', 'd', ' would result\nin an output array of shape ', '(i0,', ' with:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L882', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ones_like(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return an array of ones with the same shape and type\nas the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.pad(data=None, mode=_Null, pad_width=_Null, constant_value=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Pads an input array with a constant or edge values of the array.', '\n', '\n', 'Note', '\n', 'Pad', '\n', '\n', '\n', 'Note', '\n', 'Current implementation only supports 4D and 5D input arrays with padding applied\nonly on axes 1, 2 and 3. Expects axes 4 and 5 in ', '\n', '\n', 'This operation pads an input array with either a ', 'constant_value', ' or edge values\nalong each axis of the input array. The amount of padding is specified by ', 'pad_width', '.', '\n', 'pad_width', ' is a tuple of integer padding widths for each axis of the format\n', '(before_1,', '. The ', 'pad_width', ' should be of length ', '2*N', '\nwhere ', 'N', ' is the number of dimensions of the array.', '\n', 'For dimension ', 'N', ' of the input array, ', 'before_N', ' and ', 'after_N', ' indicates how many values\nto add before and after the elements of the array along dimension ', 'N', '.\nThe widths of the higher two dimensions ', 'before_1', ', ', 'after_1', ', ', 'before_2', ',\n', 'after_2', ' must be 0.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/pad.cc:L765', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.pick(data=None, index=None, axis=_Null, keepdims=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Picks elements from an input array according to the input indices along the given axis.', '\n', 'Given an input array of shape ', '(d0,', ' and indices of shape ', '(i0,)', ', the result will be\nan output array of shape ', '(i0,)', ' with:', '\n', None, '\n', '\n', 'By default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the ', 'clip', ' mode).', '\n', 'This function supports n-dimensional input and (n-1)-dimensional indices arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L150', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.preloaded_multi_mp_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.preloaded_multi_mp_sgd_update(*data, **kwargs)Â¶","['Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L139', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.preloaded_multi_sgd_mom_update(*data, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.preloaded_multi_sgd_update(*data, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SDG) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/preloaded_multi_sgd.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.prod(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the product of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L30', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.radians(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Converts each element of the input array from degrees to radians.', '\n', '\n\\[radians([0, 90, 180, 270, 360]) = [0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]\\]', '\n', 'The storage type of ', 'radians', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L351', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_exponential(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from an exponential distribution.', '\n', 'Samples are distributed according to an exponential distribution parametrized by ', 'lambda', ' (rate).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_gamma(alpha=_Null, beta=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a gamma distribution.', '\n', 'Samples are distributed according to a gamma distribution parametrized by ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L124', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_generalized_negative_binomial(mu=_Null, alpha=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a generalized negative binomial distribution.', '\n', 'Samples are distributed according to a generalized negative binomial distribution parametrized by\n', 'mu', ' (mean) and ', 'alpha', ' (dispersion). ', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L178', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_negative_binomial(k=_Null, p=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a negative binomial distribution.', '\n', 'Samples are distributed according to a negative binomial distribution parametrized by\n', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure probability in each experiment).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L163', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_normal(loc=_Null, scale=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_dirichlet(sample=None, alpha=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nDirichlet distributions with parameter ', 'alpha', '.', '\n', 'The shape of ', 'alpha', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'alpha', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'alpha', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L315', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_exponential(sample=None, lam=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nexponential distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L304', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_gamma(sample=None, alpha=None, beta=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (rate).', '\n', 'alpha', ' and ', 'beta', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'alpha', ' and ', 'beta', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'alpha', ' and ', 'beta', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L302', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_generalized_negative_binomial(sample=None, mu=None, alpha=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean)\nand ', 'alpha', ' (dispersion).  This can be understood as a reparameterization of\nthe negative binomial, where ', 'k', ' = ', '1 / alpha', ' and ', 'p', ' = ', '1 / (mu * alpha + 1)', '.', '\n', 'mu', ' and ', 'alpha', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'alpha', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'alpha', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L313', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_negative_binomial(sample=None, k=None, p=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of samples of\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'k', ' and ', 'p', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'k', ' and ', 'p', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'k', ' and ', 'p', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L309', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_normal(sample=None, mu=None, sigma=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'mu', ' and ', 'sigma', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'mu', ' and ', 'sigma', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'mu', ' and ', 'sigma', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L299', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_poisson(sample=None, lam=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nPoisson distributions with parameters ', 'lam', ' (rate).', '\n', 'The shape of ', 'lam', ' must match the leftmost subshape of ', 'sample', '.  That is, ', 'sample', '\ncan have the same shape as ', 'lam', ', in which case the output contains one density per\ndistribution, or ', 'sample', ' can be a tensor of tensors with that shape, in which case\nthe output is a tensor of densities such that the densities at index ', 'i', ' in the output\nare given by the samples at index ', 'i', ' in ', 'sample', ' parameterized by the value of ', 'lam', '\nat index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L306', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_pdf_uniform(sample=None, low=None, high=None, is_log=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the value of the PDF of ', 'sample', ' of\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'low', ' and ', 'high', ' must have the same shape, which must match the leftmost subshape\nof ', 'sample', '.  That is, ', 'sample', ' can have the same shape as ', 'low', ' and ', 'high', ', in which\ncase the output contains one density per distribution, or ', 'sample', ' can be a tensor\nof tensors with that shape, in which case the output is a tensor of densities such that\nthe densities at index ', 'i', ' in the output are given by the samples at index ', 'i', ' in ', 'sample', '\nparameterized by the values of ', 'low', ' and ', 'high', ' at index ', 'i', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/pdf_op.cc:L297', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_poisson(lam=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a Poisson distribution.', '\n', 'Samples are distributed according to a Poisson distribution parametrized by ', 'lambda', ' (rate).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L149', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_randint(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a discrete uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L193', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.random_uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.ravel_multi_index(data=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L41', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.rcbrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse cube-root value of the input.', '\n', '\n\\[rcbrt(x) = 1/\\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L323', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.reciprocal(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the reciprocal of the argument, element-wise.', '\n', 'Calculates 1/x.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L43', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.relu(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes rectified linear activation.', '\n', '\n\\[max(features, 0)\\]', '\n', 'The storage type of ', 'relu', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.repeat(data=None, repeats=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Repeats elements of an array.\nBy default, ', 'repeat', ' flattens the input array into 1-D and then repeats the\nelements:', '\n', None, '\n', '\n', '\n', 'The parameter ', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L743', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.reset_arrays(*data, **kwargs)Â¶","['Set to zero multiple arrays', '\n', 'Defined in src/operator/contrib/reset_arrays.cc:L35', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.reshape(data=None, shape=_Null, reverse=_Null, target_shape=_Null, keep_highest=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reshapes the input array.\n.. note:: ', 'Reshape', ' is deprecated, use ', 'reshape', '\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\nExample:', '\n', None, '\n', '\n', 'Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n- ', '0', '  copy this dimension from the input to the output shape.', '\n', '\n', 'Example::\n- input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n- input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)', '\n', '\n', '-1', '\n', '-2', '\n', '-3', '\n', '-4', '\n', '\n', '\n', 'If the argument ', 'Example::\n- without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n- with reverse=1, output shape will be (50,4).', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L174', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.reshape_like(lhs=None, rhs=None, lhs_begin=_Null, lhs_end=_Null, rhs_begin=_Null, rhs_end=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reshape some or all dimensions of ', 'lhs', ' to have the same shape as some or all dimensions of ', 'rhs', '.', '\n', 'Returns a ', 'view', ' of the ', 'lhs', ' array with a new shape without altering any data.', '\n', 'Example:', '\n', None, '\n', '\n', 'More precise control over how dimensions are inherited is achieved by specifying slices over the ', 'lhs', ' and ', 'rhs', ' array dimensions. Only the sliced ', 'lhs', ' dimensions are reshaped to the ', 'rhs', ' sliced dimensions, with the non-sliced ', 'lhs', ' dimensions staying the same.', '\n', '\n', 'Examples:', '\n', 'Negative indices are supported, and ', 'None', ' can be used for either ', 'lhs_end', ' or ', 'rhs_end', ' to indicate the end of the range.', '\n', '\n', 'Example:', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L511', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.reverse(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Reverses the order of elements along given axis while preserving array shape.\nNote: reverse and flip are equivalent. We use reverse in the following examples.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L831', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.rint(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rint', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L798', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.rmsprop_update(weight=None, grad=None, n=None, lr=_Null, gamma1=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for ', 'RMSProp', ' optimizer.', '\n', 'RMSprop', ' is a variant of stochastic gradient descent where the gradients are\ndivided by a cache which grows with the sum of squares of recent gradients?', '\n', 'RMSProp', ' is similar to ', 'AdaGrad', ', a popular variant of ', 'SGD', ' which adaptively\ntunes the learning rate of each parameter. ', 'AdaGrad', ' lowers the learning rate for\neach parameter monotonically over the course of training.\nWhile this is analytically motivated for convex optimizations, it may not be ideal\nfor non-convex problems. ', 'RMSProp', ' deals with this heuristically by allowing the\nlearning rates to rebound as the denominator decays over time.', '\n', 'Define the Root Mean Square (RMS) error criterion of the gradient as\n', '\\(RMS[g]_t = \\sqrt{E[g^2]_t + \\epsilon}\\)', ', where ', '\\(g\\)', ' represents\ngradient and ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient.', '\n', 'The ', '\\(E[g^2]_t\\)', ' is given by:', '\n', '\n\\[E[g^2]_t = \\gamma * E[g^2]_{t-1} + (1-\\gamma) * g_t^2\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t - \\frac{\\eta}{RMS[g]_t} g_t\\]', '\n', 'The RMSProp code follows the version in\n', 'http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf', '\nTieleman & Hinton, 2012.', '\n', 'Hinton suggests the momentum term ', '\\(\\gamma\\)', ' to be 0.9 and the learning rate\n', '\\(\\eta\\)', ' to be 0.001.', '\n', 'Defined in src/operator/optimizer_op.cc:L796', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.rmspropalex_update(weight=None, grad=None, n=None, g=None, delta=None, lr=_Null, gamma1=_Null, gamma2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, clip_weights=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for RMSPropAlex optimizer.', '\n', 'RMSPropAlex', ' is non-centered version of ', 'RMSProp', '.', '\n', 'Define ', '\\(E[g^2]_t\\)', ' is the decaying average over past squared gradient and\n', '\\(E[g]_t\\)', ' is the decaying average over past gradient.', '\n', '\n\\[\\begin{split}E[g^2]_t = \\gamma_1 * E[g^2]_{t-1} + (1 - \\gamma_1) * g_t^2\\\\\nE[g]_t = \\gamma_1 * E[g]_{t-1} + (1 - \\gamma_1) * g_t\\\\\n\\Delta_t = \\gamma_2 * \\Delta_{t-1} - \\frac{\\eta}{\\sqrt{E[g^2]_t - E[g]_t^2 + \\epsilon}} g_t\\\\\\end{split}\\]', '\n', 'The update step is', '\n', '\n\\[\\theta_{t+1} = \\theta_t + \\Delta_t\\]', '\n', 'The RMSPropAlex code follows the version in\n', 'http://arxiv.org/pdf/1308.0850v5.pdf', ' Eq(38) - Eq(45) by Alex Graves, 2013.', '\n', 'Graves suggests the momentum term ', '\\(\\gamma_1\\)', ' to be 0.95, ', '\\(\\gamma_2\\)', '\nto be 0.9 and the learning rate ', '\\(\\eta\\)', ' to be 0.0001.', '\n', 'Defined in src/operator/optimizer_op.cc:L835', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.round(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'round', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L777', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.rsqrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse square-root value of the input.', '\n', '\n\\[rsqrt(x) = 1/\\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rsqrt', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_exponential(lam=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nexponential distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_gamma(alpha=None, beta=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngamma distributions with parameters ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L281', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_generalized_negative_binomial(mu=None, alpha=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\ngeneralized negative binomial distributions with parameters ', 'mu', ' (mean) and ', 'alpha', ' (dispersion).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L292', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_multinomial(data=None, shape=_Null, get_prob=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple multinomial distributions.', '\n', 'data', ' is an ', 'n', ' dimensional array whose last dimension has length ', 'k', ', where\n', 'k', ' is the number of possible outcomes of each multinomial distribution. This\noperator will draw ', 'shape', ' samples from each distribution. If shape is empty\none sample will be drawn from each distribution.', '\n', 'If ', 'get_prob', ' is true, a second array containing log likelihood of the drawn\nsamples will also be returned. This is usually used for reinforcement learning\nwhere you can provide reward as head gradient for this array to estimate\ngradient.', '\n', 'Note that the input distribution must be normalized, i.e. ', 'data', ' must sum to\n1 along its last axis.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_negative_binomial(k=None, p=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnegative binomial distributions with parameters ', 'k', ' (failure limit) and ', 'p', ' (failure probability).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L288', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_normal(mu=None, sigma=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nnormal distributions with parameters ', 'mu', ' (mean) and ', 'sigma', ' (standard deviation).', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L278', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_poisson(lam=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nPoisson distributions with parameters lambda (rate).', '\n', 'The parameters of the distributions are provided as an input array.\nLet ', '[s]', ' be the shape of the input array, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input array, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.', '\n', 'Samples will always be returned as a floating point data type.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L285', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sample_uniform(low=None, high=None, shape=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Concurrent sampling from multiple\nuniform distributions on the intervals given by ', '[low,high)', '.', '\n', 'The parameters of the distributions are provided as input arrays.\nLet ', '[s]', ' be the shape of the input arrays, ', 'n', ' be the dimension of ', '[s]', ', ', '[t]', '\nbe the shape specified as the parameter of the operator, and ', 'm', ' be the dimension\nof ', '[t]', '. Then the output will be a ', '(n+m)', '-dimensional array with shape ', '[s]x[t]', '.', '\n', 'For any valid ', 'n', '-dimensional index ', 'i', ' with respect to the input arrays, ', 'output[i]', '\nwill be an ', 'm', '-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index ', 'i', '. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/random/multisample_op.cc:L276', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.scatter_nd(data=None, indices=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Scatters data into a new tensor according to indices.', '\n', 'Given ', 'data', ' with shape ', '(Y_0, â\x80¦, Y_{K-1}, X_M, â\x80¦, X_{N-1})', ' and indices with shape\n', '(M, Y_0, â\x80¦, Y_{K-1})', ', the output will have shape ', '(X_0, X_1, â\x80¦, X_{N-1})', ',\nwhere ', 'M <= N', '. If ', 'M == N', ', data shape should simply be ', '(Y_0, â\x80¦, Y_{K-1})', '.', '\n', 'The elements in output is defined as follows:', '\n', None, '\n', '\n', 'all other entries in output are 0.', '\n', '\n', 'Warning', '\n', 'If the indices have duplicates, the result will be non-deterministic and\nthe gradient of ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sgd_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and weightâ\x80\x99s storage\ntype is the same as momentumâ\x80\x99s storage type,\nonly the row slices whose indices appear in grad.indices are updated (for both weight and momentum):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L564', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradient is of ', 'row_sparse', ' storage type and ', 'lazy_update', ' is True,\nonly the row slices whose indices appear in grad.indices are updated:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L523', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.shape_array(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a 1D int64 array containing the shape of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L573', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.shuffle(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Randomly shuffle the elements.', '\n', 'This shuffles the array along the first axis.\nThe order of the elements in each subarray does not change.\nFor example, if a 2D array is given, the order of the rows randomly changes,\nbut the order of the elements in each row does not change.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sigmoid(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes sigmoid of x element-wise.', '\n', '\n\\[y = 1 / (1 + exp(-x))\\]', '\n', 'The storage type of ', 'sigmoid', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sign(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sign of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sign', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L758', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.signsgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for SignSGD optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(g_t)\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L62', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.signum_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, wd_lh=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['SIGN momentUM (Signum) optimizer.', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta m_{t-1} + (1 - \\beta) g_t\\\\\nW_t = W_{t-1} - \\eta_t \\text{sign}(m_t)\\end{split}\\]', '\n', '\n', 'It updates the weights using::', 'state = momentum * state + (1-momentum) * gradient\nweight = weight - learning_rate * sign(state)', '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L91', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sin(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise sine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[sin([0, \\pi/4, \\pi/2]) = [0, 0.707, 1]\\]', '\n', 'The storage type of ', 'sin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L47', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sinh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic sine of the input array, computed element-wise.', '\n', '\n\\[sinh(x) = 0.5\\times(exp(x) - exp(-x))\\]', '\n', 'The storage type of ', 'sinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L371', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.size_array(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a 1D int64 array containing the size of data.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.slice(data=None, begin=_Null, end=_Null, step=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.slice_axis(data=None, axis=_Null, begin=_Null, end=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices along a given axis.\nReturns an array slice along a given ', 'axis', ' starting from the ', 'begin', ' index\nto the ', 'end', ' index.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L570', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.slice_like(data=None, shape_like=None, axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices a region of the array like the shape of another array.\nThis function is similar to ', 'slice', ', however, the ', 'begin', ' are always ', '0`s\nand `end', ' of specific axes are inferred from the second input ', 'shape_like', '.\nGiven the second ', 'shape_like', ' input of ', 'shape=(d_0,', ',\na ', 'slice_like', ' operator with default empty ', 'axes', ', it performs the\nfollowing operation:\n`` out = slice(input, begin=(0, 0, â\x80¦, 0), end=(d_0, d_1, â\x80¦, d_n-1))``.\nWhen ', 'axes', ' is not empty, it is used to speficy which axes are being sliced.\nGiven a 4-d input data, ', 'slice_like', ' operator with ', 'axes=(0,', '\nwill perform the following operation:\n`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.\nNote that it is allowed to have first and second input with different dimensions,\nhowever, you have to make sure the ', 'axes', ' are specified and not exceeding the\ndimension limits.\nFor example, given ', 'input_1', ' with ', 'shape=(2,3,4,5)', ' and ', 'input_2', ' with\n', 'shape=(1,2,3)', ', it is not allowed to use:\n`` out = slice_like(a, b)`` because ndim of ', 'input_1', ' is 4, and ndim of ', 'input_2', '\nis 3.\nThe following is allowed in this situation:\n`` out = slice_like(a, b, axes=(0, 2))``\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L624', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.smooth_l1(data=None, scalar=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Calculate Smooth L1 Loss(lhs, scalar) by summing', '\n', '\n\\[\\begin{split}f(x) =\n\\begin{cases}\n(\\sigma x)^2/2,& \\text{if }x < 1/\\sigma^2\\\\\n|x|-0.5/\\sigma^2,& \\text{otherwise}\n\\end{cases}\\end{split}\\]', '\n', 'where ', '\\(x\\)', ' is an element of the tensor ', 'lhs', ' and ', '\\(\\sigma\\)', ' is the scalar.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L108', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.softmax(data=None, length=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies the softmax function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.', '\n', '\n\\[softmax(\\mathbf{z/t})_j = \\frac{e^{z_j/t}}{\\sum_{k=1}^K e^{z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmax.cc:L135', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.softmax_cross_entropy(data=None, label=None, name=None, attr=None, out=None, **kwargs)Â¶","['Calculate cross entropy of softmax output and one-hot label.', '\n', '\n', 'This operator computes the cross entropy in two steps:\n- Applies softmax function on the input array.\n- Computes and returns the cross entropy loss between the softmax output and the labels.', '\n', 'The softmax function and cross entropy loss is given by:', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/loss_binary_op.cc:L58', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.softmin(data=None, axis=_Null, temperature=_Null, dtype=_Null, use_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies the softmin function.', '\n', 'The resulting array contains elements in the range (0,1) and the elements along the given axis sum\nup to 1.', '\n', '\n\\[softmin(\\mathbf{z/t})_j = \\frac{e^{-z_j/t}}{\\sum_{k=1}^K e^{-z_k/t}}\\]', '\n', 'for ', '\\(j = 1, ..., K\\)', '\n', 't is the temperature parameter in softmax function. By default, t equals 1.0', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/softmin.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.softsign(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes softsign of x element-wise.', '\n', '\n\\[y = x / (1 + abs(x))\\]', '\n', 'The storage type of ', 'softsign', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L191', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sort(data=None, axis=_Null, is_ascend=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns a sorted copy of an input array along the given axis.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L132', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.space_to_depth(data=None, block_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Rearranges(permutes) blocks of spatial data into depth.\nSimilar to ONNX SpaceToDepth operator:\n', 'https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth', '\nThe output is a new tensor where the values from height and width dimension are\nmoved to the depth dimension. The reverse of this operation is ', 'depth_to_space', '.\n.. math:', '\n', None, '\n', '\n', 'where ', '\\(x\\)', ' is an input tensor with default layout as ', '\\([N, C, H, W]\\)', ': [batch, channels, height, width]\nand ', '\\(y\\)', ' is the output tensor of layout ', '\\([N, C * (block\\_size ^ 2), H / block\\_size, W / block\\_size]\\)', '\nExample:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L1018', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.split(data=None, num_outputs=_Null, axis=_Null, squeeze_axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Splits an array along a particular axis into multiple sub-arrays.', '\n', '\n', 'Note', '\n', 'SliceChannel', '\n', '\n', 'Note', ' that ', 'num_outputs', ' should evenly divide the length of the axis\nalong which to split the array.', '\n', 'Example:', '\n', None, '\n', '\n', 'squeeze_axis=1', ' removes the axis with length 1 from the shapes of the output arrays.\n', 'Note', ' that setting ', 'squeeze_axis', ' to ', '1', ' removes axis with length 1 only\nalong the ', 'axis', ' which it is split.\nAlso ', 'squeeze_axis', ' can be set to true only if ', 'input.shape[axis]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/slice_channel.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sqrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise square-root value of the input.', '\n', '\n\\[\\textrm{sqrt}(x) = \\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sqrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L170', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.square(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise squared value of the input.', '\n', '\n\\[square(x) = x^2\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'square', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.squeeze(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Remove single-dimensional entries from the shape of an array.\nSame behavior of defining the output tensor shape as numpy.squeeze for the most of cases.\nSee the following note for exception.\nExamples:', '\n', None, '\n', '\n', '\n', 'Note', '\n', 'The output of this operator will keep at least one dimension not removed. For example,\nsqueeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.stack(*data, **kwargs)Â¶","['Join a sequence of arrays along a new axis.\nThe axis parameter specifies the index of the new axis in the dimensions of the\nresult. For example, if axis=0 it will be the first dimension and if axis=-1 it\nwill be the last dimension.\nExamples:', '\n', None, '\n', '\n', 'This function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.stop_gradient(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.sum_axis(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.swapaxes(data=None, dim1=_Null, dim2=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Interchanges two axes of an array.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/swapaxis.cc:L69', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.take(a=None, indices=None, axis=_Null, mode=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Takes elements from an input array along the given axis.', '\n', 'This function slices the input array along a particular axis with the provided indices.', '\n', 'Given data tensor of rank r >= 1, and indices tensor of rank q, gather entries of the axis\ndimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them\nin an output tensor of rank q + (r - 1).', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of ', 'take', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L776', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.tan(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise tangent of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[tan([0, \\pi/4, \\pi/2]) = [0, 1, -inf]\\]', '\n', 'The storage type of ', 'tan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L140', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.tanh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic tangent of the input array, computed element-wise.', '\n', '\n\\[tanh(x) = sinh(x) / cosh(x)\\]', '\n', 'The storage type of ', 'tanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L451', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.tile(data=None, reps=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Repeats the whole array multiple times.\nIf ', 'reps', ' has length ', 'd', ', and input array has dimension of ', 'n', '. There are\nthree cases:\n- ', 'n=d', '. Repeat ', 'i', '-th dimension of the input by ', 'reps[i]', ' times:', '\n', None, '\n', '\n', '\n', 'n>d', '\n', 'n<d', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L795', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.topk(data=None, axis=_Null, k=_Null, ret_typ=_Null, is_ascend=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Returns the indices of the top ', 'axis (by default).\nIf ret_type is set to â\x80\x98valueâ\x80\x99 returns the value of top ', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ordering_op.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.transpose(data=None, axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Permutes the dimensions of an array.\nExamples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L327', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.trunc(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return the element-wise truncated value of the input.', '\n', 'The truncated value of the scalar x is the nearest integer i which is closer to\nzero than x is. In short, the fractional part of the signed number x is discarded.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'trunc', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L856', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.uniform(low=_Null, high=_Null, shape=_Null, ctx=_Null, dtype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a uniform distribution.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L95', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.unravel_index(data=None, shape=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/ravel.cc:L67', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.where(condition=None, x=None, y=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return the elements, either from x or y, depending on the condition.', '\n', 'Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,\ndepending on the elements from condition are true or false. x and y must have the same shape.\nIf condition has the same shape as x, each element in the output array is from x if the\ncorresponding element in the condition is true, and from y if false.', '\n', 'If condition does not have the same shape as x, it must be a 1D array whose size is\nthe same as xâ\x80\x99s first dimension size. Each row of the output array is from xâ\x80\x99s row\nif the corresponding element from condition is true, and from yâ\x80\x99s row if false.', '\n', 'Note that all non-zero values are interpreted as ', 'True', ' in condition.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/control_flow_op.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.op.zeros_like(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return an array of zeros with the same shape, type and storage type\nas the input array.', '\n', 'The storage type of ', 'zeros_like', ' output depends on the storage type of the input', '\n', '\n', 'zeros_like(row_sparse) = row_sparse', '\n', 'zeros_like(csr) = csr', '\n', 'zeros_like(default) = default', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.uniform(low=0, high=1, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw random samples from a uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.normal(loc=0, scale=1, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', 'Samples are distributed according to a normal distribution parametrized\nby ', 'loc', ' (mean) and ', 'scale', ' (standard deviation).', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.randn(*shape, **kwargs)[source]Â¶","['Draw random samples from a normal (Gaussian) distribution.', '\n', 'Samples are distributed according to a normal distribution parametrized\nby ', 'loc', ' (mean) and ', 'scale', ' (standard deviation).', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.poisson(lam=1, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw random samples from a Poisson distribution.', '\n', 'Samples are distributed according to a Poisson distribution parametrized\nby ', 'lambda', ' (rate). Samples will always be returned as a floating point data type.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.exponential(scale=1, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw samples from an exponential distribution.', '\n', 'Its probability density function is', '\n', '\n\\[f(x; \\frac{1}{\\beta}) = \\frac{1}{\\beta} \\exp(-\\frac{x}{\\beta}),\\]', '\n', 'for x > 0 and 0 elsewhere. beta is the scale parameter, which is the\ninverse of the rate parameter lambda = 1/beta.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.gamma(alpha=1, beta=1, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw random samples from a gamma distribution.', '\n', 'Samples are distributed according to a gamma distribution parametrized\nby ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.multinomial(data, shape=_Null, get_prob=True, dtype='int32', **kwargs)[source]Â¶","['Concurrent sampling from multiple multinomial distributions.', '\n', '\n', 'Note', '\n', 'The input distribution must be normalized, i.e. ', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'For input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.negative_binomial(k=1, p=1, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw random samples from a negative binomial distribution.', '\n', 'Samples are distributed according to a negative binomial distribution\nparametrized by ', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure\nprobability in each experiment). Samples will always be returned as a\nfloating point data type.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.generalized_negative_binomial(mu=1, alpha=1, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw random samples from a generalized negative binomial distribution.', '\n', 'Samples are distributed according to a generalized negative binomial\ndistribution parametrized by ', 'mu', ' (mean) and ', 'alpha', ' (dispersion).\n', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.shuffle(data, **kwargs)[source]Â¶","['Shuffle the elements randomly.', '\n', 'This shuffles the array along the first axis.\nThe order of the elements in each subarray does not change.\nFor example, if a 2D array is given, the order of the rows randomly changes,\nbut the order of the elements in each row does not change.', '\n', '\n', 'Parameters', '\n', 'data', '\n', 'Returns', '\n', 'A new symbol representing the shuffled version of input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.symbol.random.randint(low, high, shape=_Null, dtype=_Null, **kwargs)[source]Â¶","['Draw random samples from a discrete uniform distribution.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'If input ', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.exponential_like(data=None, lam=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from an exponential distribution according to the input array shape.', '\n', 'Samples are distributed according to an exponential distribution parametrized by ', 'lambda', ' (rate).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L242', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.gamma_like(data=None, alpha=_Null, beta=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a gamma distribution according to the input array shape.', '\n', 'Samples are distributed according to a gamma distribution parametrized by ', 'alpha', ' (shape) and ', 'beta', ' (scale).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L231', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.generalized_negative_binomial_like(data=None, mu=_Null, alpha=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a generalized negative binomial distribution according to the\ninput array shape.', '\n', 'Samples are distributed according to a generalized negative binomial distribution parametrized by\n', 'mu', ' (mean) and ', 'alpha', ' (dispersion). ', 'alpha', ' is defined as ', '1/k', ' where ', 'k', ' is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.negative_binomial_like(data=None, k=_Null, p=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a negative binomial distribution according to the input array shape.', '\n', 'Samples are distributed according to a negative binomial distribution parametrized by\n', 'k', ' (limit of unsuccessful experiments) and ', 'p', ' (failure probability in each experiment).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L267', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.normal_like(data=None, loc=_Null, scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a normal (Gaussian) distribution according to the input array shape.', '\n', 'Samples are distributed according to a normal distribution parametrized by ', 'loc', ' (mean) and ', 'scale', '\n(standard deviation).', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L220', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.poisson_like(data=None, lam=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a Poisson distribution according to the input array shape.', '\n', 'Samples are distributed according to a Poisson distribution parametrized by ', 'lambda', ' (rate).\nSamples will always be returned as a floating point data type.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L254', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.random.uniform_like(data=None, low=_Null, high=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Draw random samples from a uniform distribution according to the input array shape.', '\n', 'Samples are uniformly distributed over the half-open interval ', '[low, high)', '\n(includes ', 'low', ', but excludes ', 'high', ').', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/random/sample_op.cc:L208', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.ElementWiseSum(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.Embedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'When â\x80\x9csparse_gradâ\x80\x9d is False, if any index mentioned is too large, it is replaced by the index that\naddresses the last vector in an embedding matrix.\nWhen â\x80\x9csparse_gradâ\x80\x9d is True, an error will be raised if invalid indices are found.', '\n', 'Examples:', '\n', None, '\n', '\n', 'The storage type of weight can be either row_sparse or default.', '\n', '\n', 'Note', '\n', 'If â\x80\x9csparse_gradâ\x80\x9d is set to True, the storage type of gradient w.r.t weights will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L597', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.FullyConnected(data=None, weight=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a linear transformation: ', '\\(Y = XW^T + b\\)', '.', '\n', 'If ', 'flatten', ' is set to be true, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'If ', 'flatten', ' is set to be false, then the shapes are:', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'The learnable parameters include both ', 'weight', ' and ', 'bias', '.', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', '\n', 'Note', '\n', 'The sparse support for FullyConnected is limited to forward evaluation with ', '\n', 'To compute linear transformation with â\x80\x98csrâ\x80\x99 sparse data, sparse.dot is recommended instead\nof sparse.FullyConnected.', '\n', '\n', 'Defined in src/operator/nn/fully_connected.cc:L286', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.LinearRegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes and optimizes for squared loss during backward propagation.\nJust outputs ', 'data', ' during forward propagation.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the squared loss estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{SquaredLoss}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert  \\textbf{y}_i - \\hat{\\textbf{y}}_i  \\rVert_2\\)', '\n', '\n', 'Note', '\n', 'Use the LinearRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LinearRegressionOutput(default, default) = default', '\n', 'LinearRegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L92', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.LogisticRegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a logistic function to the input.', '\n', 'The logistic function, also known as the sigmoid function, is computed as\n', '\\(\\frac{1}{1+exp(-\\textbf{x})}\\)', '.', '\n', 'Commonly, the sigmoid is used to squash the real-valued output of a linear model\n', '\\(wTx+b\\)', ' into the [0,1] range so that it can be interpreted as a probability.\nIt is suitable for binary classification or probability prediction tasks.', '\n', '\n', 'Note', '\n', 'Use the LogisticRegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'LogisticRegressionOutput(default, default) = default', '\n', 'LogisticRegressionOutput(default, csr) = default', '\n', '\n', 'The loss function used is the Binary Cross Entropy Loss:', '\n', '\\(-{(y\\log(p) + (1 - y)\\log(1 - p))}\\)', '\n', 'Where ', 'y', ' is the ground truth probability of positive outcome for a given example, and ', 'p', ' the probability predicted by the model. By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L152', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.MAERegressionOutput(data=None, label=None, grad_scale=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes mean absolute error of the input.', '\n', 'MAE is a risk metric corresponding to the expected value of the absolute error.', '\n', 'If ', '\\(\\hat{y}_i\\)', ' is the predicted value of the i-th sample, and ', '\\(y_i\\)', ' is the corresponding target value,\nthen the mean absolute error (MAE) estimated over ', '\\(n\\)', ' samples is defined as', '\n', '\\(\\text{MAE}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert \\textbf{y}_i - \\hat{\\textbf{y}}_i \\rVert_1\\)', '\n', '\n', 'Note', '\n', 'Use the MAERegressionOutput as the final output layer of a net.', '\n', '\n', 'The storage type of ', 'label', ' can be ', 'default', ' or ', 'csr', '\n', '\n', 'MAERegressionOutput(default, default) = default', '\n', 'MAERegressionOutput(default, csr) = default', '\n', '\n', 'By default, gradients of this loss function are scaled by factor ', '1/m', ', where m is the number of regression outputs of a training example.\nThe parameter ', 'grad_scale', ' can be used to change this scale to ', 'grad_scale/m', '.', '\n', 'Defined in src/operator/regression_output.cc:L120', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.abs(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise absolute value of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'abs', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L720', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.adagrad_update(weight=None, grad=None, history=None, lr=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for AdaGrad optimizer.', '\n', 'Referenced from ', 'Adaptive Subgradient Methods for Online Learning and Stochastic Optimization', ',\nand available at ', 'http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf', '.', '\n', 'Updates are applied by:', '\n', None, '\n', '\n', 'Note that non-zero values for the weight decay option are not supported.', '\n', 'Defined in src/operator/optimizer_op.cc:L908', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.adam_update(weight=None, grad=None, mean=None, var=None, lr=_Null, beta1=_Null, beta2=_Null, epsilon=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Adam optimizer. Adam is seen as a generalization\nof AdaGrad.', '\n', 'Adam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).', '\n', '\n\\[\\begin{split}g_t = \\nabla J(W_{t-1})\\\\\nm_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\nv_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\nW_t = W_{t-1} - \\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon }\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and the storage\ntype of weight is the same as those of m and v,\nonly the row slices whose indices appear in grad.indices are updated (for w, m and v):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L687', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.add_n(*args, **kwargs)Â¶","['Adds all input arguments element-wise.', '\n', '\n\\[add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\\]', '\n', 'add_n', ' is potentially more efficient than calling ', 'add', ' by ', 'n', ' times.', '\n', 'The storage type of ', 'add_n', ' output depends on storage types of inputs', '\n', '\n', 'add_n(row_sparse, row_sparse, ..) = row_sparse', '\n', 'add_n(default, csr, default) = default', '\n', 'add_n(any input combinations longer than 4 (>4) with at least one default type) = default', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/elemwise_sum.cc:L155\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.arccos(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse cosine of the input array.', '\n', 'The input should be in range ', '[-1, 1]', '.\nThe output is in the closed interval ', '\\([0, \\pi]\\)', '\n', '\n\\[arccos([-1, -.707, 0, .707, 1]) = [\\pi, 3\\pi/4, \\pi/2, \\pi/4, 0]\\]', '\n', 'The storage type of ', 'arccos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.arccosh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arccosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L535', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.arcsin(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse sine of the input array.', '\n', 'The input should be in the range ', '[-1, 1]', '.\nThe output is in the closed interval of [', '\\(-\\pi/2\\)', ', ', '\\(\\pi/2\\)', '].', '\n', '\n\\[arcsin([-1, -.707, 0, .707, 1]) = [-\\pi/2, -\\pi/4, 0, \\pi/4, \\pi/2]\\]', '\n', 'The storage type of ', 'arcsin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.arcsinh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.', '\n', 'The storage type of ', 'arcsinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L494', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.arctan(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse tangent of the input array.', '\n', 'The output is in the closed interval ', '\\([-\\pi/2, \\pi/2]\\)', '\n', '\n\\[arctan([-1, 0, 1]) = [-\\pi/4, 0, \\pi/4]\\]', '\n', 'The storage type of ', 'arctan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L282', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.arctanh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.', '\n', 'The storage type of ', 'arctanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L579', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.broadcast_add(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.broadcast_div(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise division of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_div(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.broadcast_minus(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.broadcast_mul(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise product of the input arrays with broadcasting.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_mul(csr, dense(1D)) = csr', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L145', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.broadcast_plus(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sum of the input arrays with broadcasting.', '\n', 'broadcast_plus', ' is an alias to the function ', 'broadcast_add', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_add(csr, dense(1D)) = dense\nbroadcast_add(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.broadcast_sub(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise difference of the input arrays with broadcasting.', '\n', 'broadcast_minus', ' is an alias to the function ', 'broadcast_sub', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'Supported sparse operations:', '\n', '\n', 'broadcast_sub/minus(csr, dense(1D)) = dense\nbroadcast_sub/minus(dense(1D), csr) = dense', '\n', 'Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L105', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.cast_storage(data=None, stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Casts tensor storage type to the new type.', '\n', 'When an NDArray with default storage type is cast to csr or row_sparse storage,\nthe result is compact, which means:', '\n', '\n', 'for csr, zero values will not be retained', '\n', 'for row_sparse, row slices of all zeros will not be retained', '\n', '\n', 'The storage type of ', 'cast_storage', ' output depends on stype parameter:', '\n', '\n', 'cast_storage(csr, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(row_sparse, â\x80\x98defaultâ\x80\x99) = default', '\n', 'cast_storage(default, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(default, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', 'cast_storage(csr, â\x80\x98csrâ\x80\x99) = csr', '\n', 'cast_storage(row_sparse, â\x80\x98row_sparseâ\x80\x99) = row_sparse', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/cast_storage.cc:L71', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.cbrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise cube-root value of the input.', '\n', '\n\\[cbrt(x) = \\sqrt[3]{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'cbrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L270', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.ceil(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise ceiling of the input.', '\n', 'The ceil of the scalar x is the smallest integer i, such that i >= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'ceil', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L817', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.clip(data=None, a_min=_Null, a_max=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Clips (limits) the values in an array.\nGiven an interval, values outside the interval are clipped to the interval edges.\nClipping ', 'x', ' between ', 'a_min', ' and ', 'a_max', ' would be::\n.. math:', '\n', None, '\n', '\n', '\n', 'Example::', 'x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nclip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]', '\n', '\n', 'The storage type of ', 'clip', ' output depends on storage types of inputs and the a_min, a_max parameter values:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L676', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.cos(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise cosine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[cos([0, \\pi/4, \\pi/2]) = [1, 0.707, 0]\\]', '\n', 'The storage type of ', 'cos', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.cosh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic cosine  of the input array, computed element-wise.', '\n', '\n\\[cosh(x) = 0.5\\times(exp(x) + exp(-x))\\]', '\n', 'The storage type of ', 'cosh', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L409', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.degrees(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Converts each element of the input array from radians to degrees.', '\n', '\n\\[degrees([0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]) = [0, 90, 180, 270, 360]\\]', '\n', 'The storage type of ', 'degrees', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L332', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.dot(lhs=None, rhs=None, transpose_a=_Null, transpose_b=_Null, forward_stype=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Dot product of two arrays.', '\n', 'dot', 'â\x80\x99s behavior depends on the input array dimensions:', '\n', '\n', '1-D arrays: inner product of vectors', '\n', '2-D arrays: matrix multiplication', '\n', 'N-D arrays: a sum product over the last axis of the first input and the first\naxis of the second input', '\n', '\n', 'The storage type of ', 'dot', ' output depends on storage types of inputs, transpose option and\nforward_stype option for output storage type. Implemented sparse operations include:', '\n', '\n', 'dot(default, default, transpose_a=True/False, transpose_b=True/False) = default', '\n', 'dot(csr, default, transpose_a=True) = default', '\n', 'dot(csr, default, transpose_a=True) = row_sparse', '\n', 'dot(csr, default) = default', '\n', 'dot(csr, row_sparse) = default', '\n', 'dot(default, csr) = csr (CPU only)', '\n', 'dot(default, csr, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', 'dot(default, csr, transpose_b=True, forward_stype=â\x80\x99defaultâ\x80\x99) = default', '\n', '\n', 'If the combination of input storage types and forward_stype does not match any of the\nabove patterns, ', 'dot', ' will fallback and generate output with default storage.', '\n', '\n', 'Note', '\n', 'If the storage type of the lhs is â\x80\x9ccsrâ\x80\x9d, the storage type of gradient w.r.t rhs will be\nâ\x80\x9crow_sparseâ\x80\x9d. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\nand Adam. Note that by default lazy updates is turned on, which may perform differently\nfrom standard updates. For more details, please check the Optimization API at:\n', '\n', '\n', 'Defined in src/operator/tensor/dot.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.elemwise_add(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Adds arguments element-wise.', '\n', 'The storage type of ', 'elemwise_add', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.elemwise_div(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Divides arguments element-wise.', '\n', 'The storage type of ', 'elemwise_div', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.elemwise_mul(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplies arguments element-wise.', '\n', 'The storage type of ', 'elemwise_mul', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.elemwise_sub(lhs=None, rhs=None, name=None, attr=None, out=None, **kwargs)Â¶","['Subtracts arguments element-wise.', '\n', 'The storage type of ', 'elemwise_sub', ' output depends on storage types of inputs', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.exp(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise exponential value of the input.', '\n', '\n\\[exp(x) = e^x \\approx 2.718^x\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'exp', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L64', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.expm1(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns ', 'exp(x)', ' computed element-wise on the input.', '\n', 'This function provides greater precision than ', 'exp(x)', ' for small values of ', 'x', '.', '\n', 'The storage type of ', 'expm1', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L244', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.fix(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer towards zero of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'fix', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L874', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.floor(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise floor of the input.', '\n', 'The floor of the scalar x is the largest integer i, such that i <= x.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'floor', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L836', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.ftrl_update(weight=None, grad=None, z=None, n=None, lr=_Null, lamda1=_Null, beta=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Ftrl optimizer.\nReferenced from ', 'Ad Click Prediction: a View from the Trenches', ', available at\n', 'http://dl.acm.org/citation.cfm?id=2488200', '.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'If w, z and n are all of ', 'row_sparse', ' storage type,\nonly the row slices whose indices appear in grad.indices are updated (for w, z and n):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L875', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.gamma(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.', '\n', 'The storage type of ', 'gamma', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.gammaln(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise log of the absolute value of the gamma function of the input.', '\n', 'The storage type of ', 'gammaln', ' output is always dense', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.log(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Natural logarithmic value of the input.', '\n', 'The natural logarithm is logarithm in base ', 'e', ', so that ', 'log(exp(x))', '\n', 'The storage type of ', 'log', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L77', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.log10(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Base-10 logarithmic value of the input.', '\n', '10**log10(x)', '\n', 'The storage type of ', 'log10', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.log1p(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise ', 'log(1', ' value of the input.', '\n', 'This function is more accurate than ', 'log(1', '  for small ', 'x', ' so that\n', '\\(1+x\\approx 1\\)', '\n', 'The storage type of ', 'log1p', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L199', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.log2(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise Base-2 logarithmic value of the input.', '\n', '2**log2(x)', '\n', 'The storage type of ', 'log2', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_logexp.cc:L106', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.make_loss(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Make your own loss function in network construction.', '\n', 'This operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.', '\n', 'For example, if you are a making a cross entropy loss function. Assume ', 'out', ' is the\npredicted output and ', 'label', ' is the true label, then the cross entropy can be defined as:', '\n', None, '\n', '\n', 'We will need to use ', 'make_loss', ' when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variablesâ\x80\x99 gradients\nfrom backpropagation. See more detail in ', 'BlockGrad', ' or ', 'stop_gradient', '.', '\n', 'The storage type of ', 'make_loss', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L358', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.mean(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the mean of array elements over given axes.', '\n', 'Defined in src/operator/tensor/./broadcast_reduce_op.h:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.negative(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Numerical negative of the argument, element-wise.', '\n', 'The storage type of ', 'negative', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.norm(data=None, ord=_Null, axis=_Null, out_dtype=_Null, keepdims=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the norm on an NDArray.', '\n', 'This operator computes the norm on an NDArray with the specified axis, depending\non the value of the ord parameter. By default, it computes the L2 norm on the entire\narray. Currently only ord=2 supports sparse ndarrays.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_norm_value.cc:L88', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.radians(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Converts each element of the input array from degrees to radians.', '\n', '\n\\[radians([0, 90, 180, 270, 360]) = [0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]\\]', '\n', 'The storage type of ', 'radians', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L351', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.relu(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes rectified linear activation.', '\n', '\n\\[max(features, 0)\\]', '\n', 'The storage type of ', 'relu', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.retain(data=None, indices=None, name=None, attr=None, out=None, **kwargs)Â¶","['Pick rows specified by user input index array from a row sparse matrix\nand save them in the output sparse matrix.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'retain', ' output depends on storage types of inputs', '\n', '\n', 'retain(row_sparse, default) = row_sparse', '\n', 'otherwise, ', '\n', '\n', 'Defined in src/operator/tensor/sparse_retain.cc:L53', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.rint(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', '\n', 'Note', '\n', '\n', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rint', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L798', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.round(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise rounded value to the nearest integer of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'round', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L777', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.rsqrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise inverse square-root value of the input.', '\n', '\n\\[rsqrt(x) = 1/\\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'rsqrt', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sgd_mom_update(weight=None, grad=None, mom=None, lr=_Null, momentum=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Momentum update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'Momentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:', '\n', '\n\\[\\begin{split}v_1 = \\alpha * \\nabla J(W_0)\\\\\nv_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\nW_t = W_{t-1} + v_t\\end{split}\\]', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'Where the parameter ', 'momentum', ' is the decay rate of momentum estimates at each epoch.', '\n', 'However, if gradâ\x80\x99s storage type is ', 'row_sparse', ', ', 'lazy_update', ' is True and weightâ\x80\x99s storage\ntype is the same as momentumâ\x80\x99s storage type,\nonly the row slices whose indices appear in grad.indices are updated (for both weight and momentum):', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L564', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sgd_update(weight=None, grad=None, lr=_Null, wd=_Null, rescale_grad=_Null, clip_gradient=_Null, lazy_update=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Stochastic Gradient Descent (SGD) optimizer.', '\n', 'It updates the weights using:', '\n', None, '\n', '\n', 'However, if gradient is of ', 'row_sparse', ' storage type and ', 'lazy_update', ' is True,\nonly the row slices whose indices appear in grad.indices are updated:', '\n', None, '\n', '\n', 'Defined in src/operator/optimizer_op.cc:L523', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sigmoid(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes sigmoid of x element-wise.', '\n', '\n\\[y = 1 / (1 + exp(-x))\\]', '\n', 'The storage type of ', 'sigmoid', ' output is always dense', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sign(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise sign of the input.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sign', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L758', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sin(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise sine of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[sin([0, \\pi/4, \\pi/2]) = [0, 0.707, 1]\\]', '\n', 'The storage type of ', 'sin', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L47', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sinh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic sine of the input array, computed element-wise.', '\n', '\n\\[sinh(x) = 0.5\\times(exp(x) - exp(-x))\\]', '\n', 'The storage type of ', 'sinh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L371', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.slice(data=None, begin=_Null, end=_Null, step=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Slices a region of the array.\n.. note:: ', 'crop', ' is deprecated. Use ', 'slice', ' instead.\nThis function returns a sliced array between the indices given\nby ', 'begin', ' and ', 'end', ' with the corresponding ', 'step', '.\nFor an input array of ', 'shape=(d_0,', ',\nslice operation with ', 'begin=(b_0,', ',\n', 'end=(e_0,', ', and ', 'step=(s_0,', ',\nwhere m <= n, results in an array with the shape\n', '(|e_0-b_0|/|s_0|,', '.\nThe resulting arrayâ\x80\x99s ', 'k', '-th dimension contains elements\nfrom the ', 'k', '-th dimension of the input array starting\nfrom index ', 'b_k', ' (inclusive) with step ', 's_k', '\nuntil reaching ', 'e_k', ' (exclusive).\nIf the ', 'k', '-th elements are ', 'None', ' in the sequence of ', 'begin', ', ', 'end', ',\nand ', 'step', ', the following rule will be used to set default values.\nIf ', 's_k', ' is ', 'None', ', set ', 's_k=1', '. If ', 's_k > 0', ', set ', 'b_k=0', ', ', 'e_k=d_k', ';\nelse, set ', 'b_k=d_k-1', ', ', 'e_k=-1', '.\nThe storage type of ', 'slice', ' output depends on storage types of inputs\n- slice(csr) = csr\n- otherwise, ', 'slice', ' generates output with default storage\n.. note:: When input data storage type is csr, it only supports', '\n', '\n', 'step=(), or step=(None,), or step=(1,) to generate a csr output.\nFor other step parameter values, it falls back to slicing\na dense tensor.', '\n', '\n', 'Example::', '\n', '\n', '\n', 'Defined in src/operator/tensor/matrix_op.cc:L481', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sqrt(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise square-root value of the input.', '\n', '\n\\[\\textrm{sqrt}(x) = \\sqrt{x}\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'sqrt', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L170', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.square(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns element-wise squared value of the input.', '\n', '\n\\[square(x) = x^2\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'square', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_pow.cc:L119', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.stop_gradient(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.sum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the sum of array elements over given axes.', '\n', '\n', 'Note', '\n', 'sum', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/broadcast_reduce_sum_value.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.tan(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the element-wise tangent of the input array.', '\n', 'The input should be in radians (', '\\(2\\pi\\)', ' rad equals 360 degrees).', '\n', '\n\\[tan([0, \\pi/4, \\pi/2]) = [0, 1, -inf]\\]', '\n', 'The storage type of ', 'tan', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L140', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.tanh(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Returns the hyperbolic tangent of the input array, computed element-wise.', '\n', '\n\\[tanh(x) = sinh(x) / cosh(x)\\]', '\n', 'The storage type of ', 'tanh', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L451', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.trunc(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return the element-wise truncated value of the input.', '\n', 'The truncated value of the scalar x is the nearest integer i which is closer to\nzero than x is. In short, the fractional part of the signed number x is discarded.', '\n', 'Example:', '\n', None, '\n', '\n', 'The storage type of ', 'trunc', ' output depends upon the input storage type:', '\n', '\n', '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L856', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.where(condition=None, x=None, y=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return the elements, either from x or y, depending on the condition.', '\n', 'Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,\ndepending on the elements from condition are true or false. x and y must have the same shape.\nIf condition has the same shape as x, each element in the output array is from x if the\ncorresponding element in the condition is true, and from y if false.', '\n', 'If condition does not have the same shape as x, it must be a 1D array whose size is\nthe same as xâ\x80\x99s first dimension size. Each row of the output array is from xâ\x80\x99s row\nif the corresponding element from condition is true, and from yâ\x80\x99s row if false.', '\n', 'Note that all non-zero values are interpreted as ', 'True', ' in condition.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/control_flow_op.cc:L56', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.symbol.sparse.zeros_like(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Return an array of zeros with the same shape, type and storage type\nas the input array.', '\n', 'The storage type of ', 'zeros_like', ' output depends on the storage type of the input', '\n', '\n', 'zeros_like(row_sparse) = row_sparse', '\n', 'zeros_like(csr) = csr', '\n', 'zeros_like(default) = default', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
class mxnet.module.BaseModule(logger=<module 'logging' from '/work/conda_env/lib/python3.9/logging/__init__.py'>)[source]Â¶","['Bases: ', 'object', '\n', 'The base class of a module.', '\n', 'A module represents a computation component. One can think of module as a computation machine.\nA module can execute forward and backward passes and update parameters in a model.\nWe aim to make the APIs easy to use, especially in the case when we need to use the imperative\nAPI to work with multiple modules (e.g. stochastic depth network).', '\n', 'A module has several states:', '\n', '\n', 'Initial state: Memory is not allocated yet, so the module is not ready for computation yet.', '\n', 'Binded: Shapes for inputs, outputs, and parameters are all known, memory has been allocated,\nand the module is ready for computation.', '\n', 'Parameters are initialized: For modules with parameters, doing computation before\ninitializing the parameters might result in undefined outputs.', '\n', 'Optimizer is installed: An optimizer can be installed to a module. After this, the parameters\nof the module can be updated according to the optimizer after gradients are computed\n(forward-backward).', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'In order for a module to interact with others, it must be able to report the\nfollowing information in its initial state (before binding):', '\n', '\n', 'data_names', '\n', 'output_names', '\n', '\n', 'After binding, a module should be able to report the following richer information:', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'When those intermediate-level API are implemented properly, the following\nhigh-level API will be automatically available for a module:', '\n', '\n', 'fit', '\n', 'predict', '\n', 'score', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Backward computation.', '\n', '\n', '\n', '\n', 'Binds the symbols to construct executors. This is necessary before one\ncan perform computation with the module.', '\n', '\n', '\n', '\n', 'A list of names for data required by this module.', '\n', '\n', '\n', '\n', 'A list of (name, shape) pairs specifying the data inputs to this module.', '\n', '\n', '\n', '\n', 'Trains the module parameters.', '\n', '\n', '\n', '\n', 'Forward computation. It supports data batches with different shapes, such as\ndifferent batch sizes or different image sizes.\nIf reshaping of data batch relates to modification of symbol or module, such as\nchanging image layout ordering or switching from training to predicting, module\nrebinding is required.', '\n', '\n', '\n', '\n', 'A convenient function that calls both ', '\n', '\n', '\n', '\n', 'Gets the gradients to the inputs, computed in the previous backward computation.', '\n', '\n', '\n', '\n', 'Gets outputs of the previous forward computation.', '\n', '\n', '\n', '\n', 'Gets parameters, those are potentially copies of the actual parameters used\nto do computation on the device.', '\n', '\n', '\n', '\n', 'Gets states from all devices', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Initializes the parameters and auxiliary states.', '\n', '\n', '\n', '\n', 'Installs monitor on all executors.', '\n', '\n', '\n', '\n', 'Iterates over predictions.', '\n', '\n', '\n', '\n', 'A list of (name, shape) pairs specifying the label inputs to this module.\nIf this module does not accept labels â\x80\x93 either it is a module without loss\nfunction, or it is not bound for training, then this should return an empty\nlist ', '\n', '\n', '\n', '\n', 'Loads model parameters from file.', '\n', '\n', '\n', '\n', 'A list of names for the outputs of this module.', '\n', '\n', '\n', '\n', 'A list of (name, shape) pairs specifying the outputs of this module.', '\n', '\n', '\n', '\n', 'Runs prediction and collects the outputs.', '\n', '\n', '\n', '\n', 'Prepares the module for processing a data batch.', '\n', '\n', '\n', '\n', 'Saves model parameters to file.', '\n', '\n', '\n', '\n', 'Runs prediction on ', '\n', '\n', '\n', '\n', 'Assigns parameter and aux state values.', '\n', '\n', '\n', '\n', 'Sets value for states. Only one of states & value can be specified.', '\n', '\n', '\n', '\n', 'Gets the symbol associated with this module.', '\n', '\n', '\n', '\n', 'Updates parameters according to the installed optimizer and the gradients computed\nin the previous forward-backward batch.', '\n', '\n', '\n', '\n', 'Evaluates and accumulates evaluation metric on outputs of the last forward\ncomputation.', '\n', '\n']",,,
"
class mxnet.module.BucketingModule(sym_gen, default_bucket_key=None, logger=<module 'logging' from '/work/conda_env/lib/python3.9/logging/__init__.py'>, context=cpu(0), work_load_list=None, fixed_param_names=None, state_names=None, group2ctxs=None, compression_params=None)[source]Â¶","['Bases: ', 'mxnet.module.base_module.BaseModule', '\n', 'This module helps to deal efficiently with varying-length inputs.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Backward computation.', '\n', '\n', '\n', '\n', 'Binding for a ', '\n', '\n', '\n', '\n', 'A list of names for data required by this module.', '\n', '\n', '\n', '\n', 'Get data shapes.', '\n', '\n', '\n', '\n', 'Forward computation.', '\n', '\n', '\n', '\n', 'Gets the gradients with respect to the inputs of the module.', '\n', '\n', '\n', '\n', 'Gets outputs from a previous forward computation.', '\n', '\n', '\n', '\n', 'Gets current parameters.', '\n', '\n', '\n', '\n', 'Gets states from all devices.', '\n', '\n', '\n', '\n', 'Installs and initializes optimizers.', '\n', '\n', '\n', '\n', 'Initializes parameters.', '\n', '\n', '\n', '\n', 'Installs monitor on all executors', '\n', '\n', '\n', '\n', 'Get label shapes.', '\n', '\n', '\n', '\n', 'Creates a model from previously saved checkpoint.', '\n', '\n', '\n', '\n', 'Creates a model from a dict mapping bucket_key to symbols and shared arg_params\nand aux_params.', '\n', '\n', '\n', '\n', 'A list of names for the outputs of this module.', '\n', '\n', '\n', '\n', 'Gets output shapes.', '\n', '\n', '\n', '\n', 'Prepares the module for processing a data batch.', '\n', '\n', '\n', '\n', 'Saves current progress to checkpoint for all buckets in BucketingModule\nUse ', '\n', '\n', '\n', '\n', 'Assigns parameters and aux state values.', '\n', '\n', '\n', '\n', 'Sets value for states. Only one of states & values can be specified.', '\n', '\n', '\n', '\n', 'Switches to a different bucket. This will change ', '\n', '\n', '\n', '\n', 'The symbol of the current bucket being used.', '\n', '\n', '\n', '\n', 'Updates parameters according to installed optimizer and the gradient computed\nin the previous forward-backward cycle.', '\n', '\n', '\n', '\n', 'Evaluates and accumulates evaluation metric on outputs of the last forward computation.', '\n', '\n']",,,
"
class mxnet.module.Module(symbol, data_names=('data', ), label_names=('softmax_label', ), logger=<module 'logging' from '/work/conda_env/lib/python3.9/logging/__init__.py'>, context=cpu(0), work_load_list=None, fixed_param_names=None, state_names=None, group2ctxs=None, compression_params=None)[source]Â¶","['Bases: ', 'mxnet.module.base_module.BaseModule', '\n', 'Module is a basic module that wrap a ', 'Symbol', '. It is functionally the same\nas the ', 'FeedForward', ' model, except under the module API.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Backward computation.', '\n', '\n', '\n', '\n', 'Binds the symbols to construct executors. This is necessary before one\ncan perform computation with the module.', '\n', '\n', '\n', '\n', 'Borrows optimizer from a shared module. Used in bucketing, where exactly the same\noptimizer (esp. kvstore) is used.', '\n', '\n', '\n', '\n', 'A list of names for data required by this module.', '\n', '\n', '\n', '\n', 'Gets data shapes.', '\n', '\n', '\n', '\n', 'Forward computation. It supports data batches with different shapes, such as\ndifferent batch sizes or different image sizes.\nIf reshaping of data batch relates to modification of symbol or module, such as\nchanging image layout ordering or switching from training to predicting, module\nrebinding is required.', '\n', '\n', '\n', '\n', 'Gets the gradients with respect to the inputs of the module.', '\n', '\n', '\n', '\n', 'Gets outputs of the previous forward computation.', '\n', '\n', '\n', '\n', 'Gets current parameters.', '\n', '\n', '\n', '\n', 'Gets states from all devices.', '\n', '\n', '\n', '\n', 'Installs and initializes optimizers.', '\n', '\n', '\n', '\n', 'Initializes the parameters and auxiliary states.', '\n', '\n', '\n', '\n', 'Installs monitor on all executors.', '\n', '\n', '\n', '\n', 'A list of names for labels required by this module.', '\n', '\n', '\n', '\n', 'Gets label shapes.', '\n', '\n', '\n', '\n', 'Creates a model from previously saved checkpoint.', '\n', '\n', '\n', '\n', 'Loads optimizer (updater) state from a file.', '\n', '\n', '\n', '\n', 'A list of names for the outputs of this module.', '\n', '\n', '\n', '\n', 'Gets output shapes.', '\n', '\n', '\n', '\n', 'Prepares the module for processing a data batch.', '\n', '\n', '\n', '\n', 'Reshapes the module for new input shapes.', '\n', '\n', '\n', '\n', 'Saves current progress to checkpoint.\nUse ', '\n', '\n', '\n', '\n', 'Saves optimizer (updater) state to a file.', '\n', '\n', '\n', '\n', 'Assigns parameter and aux state values.', '\n', '\n', '\n', '\n', 'Sets value for states. Only one of the states & value can be specified.', '\n', '\n', '\n', '\n', 'Updates parameters according to the installed optimizer and the gradients computed\nin the previous forward-backward batch.', '\n', '\n', '\n', '\n', 'Evaluates and accumulates evaluation metric on outputs of the last forward computation.', '\n', '\n']",,,
"
class mxnet.module.PythonLossModule(name='pyloss', data_names=('data', ), label_names=('softmax_label', ), logger=<module 'logging' from '/work/conda_env/lib/python3.9/logging/__init__.py'>, grad_func=None)[source]Â¶","['Bases: ', 'mxnet.module.python_module.PythonModule', '\n', 'A convenient module class that implements many of the module APIs as\nempty functions.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Backward computation.', '\n', '\n', '\n', '\n', 'Forward computation. Here we do nothing but to keep a reference to\nthe scores and the labels so that we can do backward computation.', '\n', '\n', '\n', '\n', 'Gets the gradients to the inputs, computed in the previous backward computation.', '\n', '\n', '\n', '\n', 'Gets outputs of the previous forward computation. As a output loss module,\nwe treat the inputs to this module as scores, and simply return them.', '\n', '\n', '\n', '\n', 'Installs monitor on all executors.', '\n', '\n']",,,
"
class mxnet.module.PythonModule(data_names, label_names, output_names, logger=<module 'logging' from '/work/conda_env/lib/python3.9/logging/__init__.py'>)[source]Â¶","['Bases: ', 'mxnet.module.base_module.BaseModule', '\n', 'A convenient module class that implements many of the module APIs as\nempty functions.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Binds the symbols to construct executors. This is necessary before one\ncan perform computation with the module.', '\n', '\n', '\n', '\n', 'A list of names for data required by this module.', '\n', '\n', '\n', '\n', 'A list of (name, shape) pairs specifying the data inputs to this module.', '\n', '\n', '\n', '\n', 'Gets parameters, those are potentially copies of the actual parameters used\nto do computation on the device. Subclass should override this method if contains\nparameters.', '\n', '\n', '\n', '\n', 'Installs and initializes optimizers. By default we do nothing. Subclass should\noverride this method if needed.', '\n', '\n', '\n', '\n', 'Initializes the parameters and auxiliary states. By default this function\ndoes nothing. Subclass should override this method if contains parameters.', '\n', '\n', '\n', '\n', 'A list of (name, shape) pairs specifying the label inputs to this module.\nIf this module does not accept labels â\x80\x93 either it is a module without loss\nfunction, or it is not bound for training, then this should return an empty\nlist ', '\n', '\n', '\n', '\n', 'A list of names for the outputs of this module.', '\n', '\n', '\n', '\n', 'A list of (name, shape) pairs specifying the outputs of this module.', '\n', '\n', '\n', '\n', 'Updates parameters according to the installed optimizer and the gradients computed\nin the previous forward-backward batch. Currently we do nothing here. Subclass should\noverride this method if contains parameters.', '\n', '\n', '\n', '\n', 'Evaluates and accumulates evaluation metric on outputs of the last forward computation.\nSubclass should override this method if needed.', '\n', '\n']",,,
"
class mxnet.module.SequentialModule(logger=<module 'logging' from '/work/conda_env/lib/python3.9/logging/__init__.py'>)[source]Â¶","['Bases: ', 'mxnet.module.base_module.BaseModule', '\n', 'A SequentialModule is a container module that can chain multiple modules together.', '\n', '\n', 'Note', '\n', 'Building a computation graph with this kind of imperative container is less\nflexible and less efficient than the symbolic graph. So, this should be only used as a\nhandy utility.', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Add a module to the chain.', '\n', '\n', '\n', '\n', 'Backward computation.', '\n', '\n', '\n', '\n', 'Binds the symbols to construct executors. This is necessary before one\ncan perform computation with the module.', '\n', '\n', '\n', '\n', 'A list of names for data required by this module.', '\n', '\n', '\n', '\n', 'Gets data shapes.', '\n', '\n', '\n', '\n', 'Forward computation.', '\n', '\n', '\n', '\n', 'Gets the gradients with respect to the inputs of the module.', '\n', '\n', '\n', '\n', 'Gets outputs from a previous forward computation.', '\n', '\n', '\n', '\n', 'Gets current parameters.', '\n', '\n', '\n', '\n', 'Installs and initializes optimizers.', '\n', '\n', '\n', '\n', 'Initializes parameters.', '\n', '\n', '\n', '\n', 'Installs monitor on all executors.', '\n', '\n', '\n', '\n', 'Gets label shapes.', '\n', '\n', '\n', '\n', 'A list of names for the outputs of this module.', '\n', '\n', '\n', '\n', 'Gets output shapes.', '\n', '\n', '\n', '\n', 'Updates parameters according to installed optimizer and the gradient computed\nin the previous forward-backward cycle.', '\n', '\n', '\n', '\n', 'Evaluates and accumulates evaluation metric on outputs of the last forward computation.', '\n', '\n']",,,
"
class mxnet.contrib.autograd.TrainingStateScope(enter_state)[source]Â¶","['Bases: ', 'object', '\n', 'Scope for managing training state.', '\n', '\n', 'Example::', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.autograd.backward(outputs, out_grads=None, retain_graph=False)[source]Â¶","['Compute the gradients of outputs w.r.t variables.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.autograd.compute_gradient(outputs)[source]Â¶","['Deprecated. Please use backward', '\n', '\n']",,,
"
mxnet.contrib.autograd.grad(func, argnum=None)[source]Â¶","['Return function that computes gradient of arguments.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'grad_func', '\n', 'Return type', '\n', 'a python function', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.contrib.autograd.grad_and_loss(func, argnum=None)[source]Â¶","['Return function that computes both gradient of arguments and loss value.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'grad_and_loss_func', '\n', 'Return type', '\n', 'a python function', '\n', '\n', '\n']",,,
"
mxnet.contrib.autograd.mark_variables(variables, gradients, grad_reqs='write')[source]Â¶","['Mark NDArrays as variables to compute gradient for autograd.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.autograd.set_is_training(is_train)[source]Â¶","['Set status to training/not training. When training, graph will be constructed\nfor gradient computation. Operators will also run with ctx.is_train=True. For example,\nDropout will drop inputs randomly when is_train=True while simply passing through\nif is_train=False.', '\n', '\n', 'Parameters', '\n', 'is_train', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'previous state before this set.', '\n', '\n', '\n']",,,
"
mxnet.contrib.autograd.test_section()[source]Â¶","['Returns a testing scope context to be used in â\x80\x98withâ\x80\x99 statement\nand captures testing code.', '\n', '\n', 'Example::', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.autograd.train_section()[source]Â¶","['Returns a training scope context to be used in â\x80\x98withâ\x80\x99 statement\nand captures training code.', '\n', '\n', 'Example::', '\n', '\n', '\n', '\n']",,,
"
class mxnet.contrib.io.DataLoaderIter(loader, data_name='data', label_name='softmax_label', dtype='float32')[source]Â¶","['Bases: ', 'mxnet.io.io.DataIter', '\n', 'Returns an iterator for ', 'mx.gluon.data.Dataloader', ' so gluon dataloader\ncan be used in symbolic module.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Get data of current batch.', '\n', '\n', '\n', '\n', 'Get index of the current batch.', '\n', '\n', '\n', '\n', 'Get label of the current batch.', '\n', '\n', '\n', '\n', 'Get the number of padding examples in the current batch.', '\n', '\n', '\n', '\n', 'Move to the next batch.', '\n', '\n', '\n', '\n', 'Reset the iterator to the begin of the data.', '\n', '\n']",,,
"
mxnet.contrib.ndarray.AdaptiveAvgPooling2D(data=None, output_size=_Null, out=None, name=None, **kwargs)Â¶","['Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).\nThe pooling kernel and stride sizes are automatically chosen for desired output sizes.', '\n', '\n', 'If a single integer is provided for output_size, the output size is (N x C x output_size x output_size) for any input (NCHW).', '\n', 'If a tuple of integers (height, width) are provided for output_size, the output size is (N x C x height x width) for any input (NCHW).', '\n', '\n', 'Defined in src/operator/contrib/adaptive_avg_pooling.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.BatchNormWithReLU(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization with ReLU fusion.', '\n', 'An extented operator of Batch normalization which can fuse ReLU activation.', '\n', 'Defined in src/operator/contrib/batch_norm_relu.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.BilinearResize2D(data=None, like=None, height=_Null, width=_Null, scale_height=_Null, scale_width=_Null, mode=_Null, align_corners=_Null, out=None, name=None, **kwargs)Â¶","['Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.', '\n', 'Expected input is a 4 dimensional NDArray (NCHW) and the output\nwith the shape of (N x C x height x width).\nThe key idea of bilinear interpolation is to perform linear interpolation\nfirst in one direction, and then again in the other direction. See the wikipedia of\n', 'Bilinear interpolation', '\nfor more details.', '\n', 'Defined in src/operator/contrib/bilinear_resize.cc:L219', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.DeformableConvolution(data=None, offset=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Compute 2-D deformable convolution on 4-D input.', '\n', 'The deformable convolution operation is described in ', 'https://arxiv.org/abs/1703.06211', '\n', 'For 2-D deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'data', ' into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset on the ', 'i', '-th part\nof the data.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.DeformablePSROIPooling(data=None, rois=None, trans=None, spatial_scale=_Null, output_dim=_Null, group_size=_Null, pooled_size=_Null, part_size=_Null, sample_per_part=_Null, trans_std=_Null, no_trans=_Null, out=None, name=None, **kwargs)Â¶","['Performs deformable position-sensitive region-of-interest pooling on inputs.\nThe DeformablePSROIPooling operation is described in ', 'https://arxiv.org/abs/1703.06211', ' .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.ModulatedDeformableConvolution(data=None, offset=None, mask=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, im2col_step=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Compute 2-D modulated deformable convolution on 4-D input.', '\n', 'The modulated deformable convolution operation is described in ', 'https://arxiv.org/abs/1811.11168', '\n', 'For 2-D modulated deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'mask', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'out', ' evenly into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset part on the ', 'i', '-th\nout.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/modulated_deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.MultiBoxDetection(cls_prob=None, loc_pred=None, anchor=None, clip=_Null, threshold=_Null, background_id=_Null, nms_threshold=_Null, force_suppress=_Null, variances=_Null, nms_topk=_Null, out=None, name=None, **kwargs)Â¶","['Convert multibox detection predictions.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.MultiBoxPrior(data=None, sizes=_Null, ratios=_Null, clip=_Null, steps=_Null, offsets=_Null, out=None, name=None, **kwargs)Â¶","['Generate prior(anchor) boxes from data, sizes and ratios.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.MultiBoxTarget(anchor=None, label=None, cls_pred=None, overlap_threshold=_Null, ignore_label=_Null, negative_mining_ratio=_Null, negative_mining_thresh=_Null, minimum_negative_samples=_Null, variances=_Null, out=None, name=None, **kwargs)Â¶","['Compute Multibox training targets', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.MultiProposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, out=None, name=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.PSROIPooling(data=None, rois=None, spatial_scale=_Null, output_dim=_Null, pooled_size=_Null, group_size=_Null, out=None, name=None, **kwargs)Â¶","['Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.Proposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, out=None, name=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.ROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sample_ratio=_Null, position_sensitive=_Null, aligned=_Null, out=None, name=None, **kwargs)Â¶","['This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.\nThis operator is typically used in Faster R-CNN & Mask R-CNN networks. If roi batchid is less\nthan 0, it will be ignored, and the corresponding output will be set to 0.', '\n', 'Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning\nthe extracted features with the input. RoIAlign computes the value of each sampling point\nby bilinear interpolation from the nearby grid points on the feature map. No quantization is\nperformed on any coordinates involved in the RoI, its bins, or the sampling points.\nBilinear interpolation is used to compute the exact values of the\ninput features at four regularly sampled locations in each RoI bin.\nThen the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'He, Kaiming, et al. â\x80\x9cMask R-CNN.â\x80\x9d ICCV, 2017', '\n', 'Defined in src/operator/contrib/roi_align.cc:L558', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.RROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sampling_ratio=_Null, out=None, name=None, **kwargs)Â¶","['Performs Rotated ROI Align on the input array.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.', '\n', 'Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.\nRRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby\ngrid points on the rotated feature map. No quantization is performed on any coordinates\ninvolved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to\ncompute the exact values of the input features at four regularly sampled locations in\neach RoI bin. Then the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'Ma, Jianqi, et al. â\x80\x9cArbitrary-Oriented Scene Text Detection via Rotation Proposals.â\x80\x9d\nIEEE Transactions on Multimedia, 2018.', '\n', 'Defined in src/operator/contrib/rroi_align.cc:L273', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.SparseEmbedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, out=None, name=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'note:: ', 'contrib.SparseEmbedding', ' is deprecated, use ', 'Embedding', ' instead.', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'The storage type of the gradient will be ', 'row_sparse', '.', '\n', '\n', 'Note', '\n', 'SparseEmbedding', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L674', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.SyncBatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, ndev=_Null, key=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.\nStandard BN ', '1', ' implementation only normalize the data within each device.\nSyncBN normalizes the input within the whole mini-batch.\nWe follow the sync-onece implmentation described in the paper ', '2', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Reference:', '\n', '\n', '\n', 'Defined in src/operator/contrib/sync_batch_norm.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.allclose(a=None, b=None, rtol=_Null, atol=_Null, equal_nan=_Null, out=None, name=None, **kwargs)Â¶","['This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)', '\n', '\n\\[f(x) = |aâ\x88\x92b|â\x89¤atol+rtol|b|\\]', '\n', 'where\n', '\\(a, b\\)', ' are the input tensors of equal types an shapes\n', '\\(atol, rtol\\)', ' the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/allclose_op.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.arange_like(data=None, start=_Null, step=_Null, repeat=_Null, ctx=_Null, axis=_Null, out=None, name=None, **kwargs)Â¶","['Return an array with evenly spaced values. If axis is not given, the output will\nhave the same shape as the input array. Otherwise, the output will be a 1-D array with size of\nthe specified axis in input shape.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.backward_gradientmultiplier(data=None, scalar=_Null, is_int=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.backward_hawkesll(out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'out', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.backward_index_copy(out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'out', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.backward_quadratic(out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'out', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.bipartite_matching(data=None, is_ascend=_Null, threshold=_Null, topk=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Compute bipartite matching.', 'The matching is performed on score matrix with shape [B, N, M]\n- B: batch_size\n- N: number of rows to match\n- M: number of columns as reference to be matched against.', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L182', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.boolean_mask(data=None, index=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Given an n-d NDArray data, and a 1-d NDArray index,\nthe operator produces an un-predeterminable shaped n-d NDArray out,\nwhich stands for the rows in x where the corresonding element in index is non-zero.', '\n', None, '\n', '\n', '[[4. 5. 6.]]\n<NDArray 1x3 @cpu(0)>', '\n', 'Defined in src/operator/contrib/boolean_mask.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.box_decode(data=None, anchors=None, std0=_Null, std1=_Null, std2=_Null, std3=_Null, clip=_Null, format=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Decode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.box_encode(samples=None, matches=None, anchors=None, refs=None, means=None, stds=None, out=None, name=None, **kwargs)Â¶","['\n', 'Encode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L210', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.box_iou(lhs=None, rhs=None, format=_Null, out=None, name=None, **kwargs)Â¶","['\n', 'Bounding box overlap of two arrays.', 'The overlap is defined as Intersection-over-Union, aka, IOU.\n- lhs: (a_1, a_2, â\x80¦, a_n, 4) array\n- rhs: (b_1, b_2, â\x80¦, b_n, 4) array\n- output: (a_1, a_2, â\x80¦, a_n, b_1, b_2, â\x80¦, b_n) array', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.box_nms(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, out=None, name=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.box_non_maximum_suppression(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, out=None, name=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.calibrate_entropy(hist=None, hist_edges=None, num_quantized_bins=_Null, out=None, name=None, **kwargs)Â¶","['Provide calibrated min/max for input histogram.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/calibrate.cc:L196', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.count_sketch(data=None, h=None, s=None, out_dim=_Null, processing_batch_size=_Null, out=None, name=None, **kwargs)Â¶","['Apply CountSketch to input: map a d-dimension data to k-dimension dataâ\x80\x9d', '\n', '\n', 'Note', '\n', 'count_sketch', '\n', '\n', 'Assume input data has shape (N, d), sign hash table s has shape (N, d),\nindex hash table h has shape (N, d) and mapping dimension out_dim = k,\neach element in s is either +1 or -1, each element in h is random integer from 0 to k-1.\nThen the operator computs:', '\n', '\n\\[out[h[i]] += data[i] * s[i]\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/count_sketch.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.dequantize(data=None, min_range=None, max_range=None, out_type=_Null, out=None, name=None, **kwargs)Â¶","['Dequantize the input tensor into a float tensor.\nmin_range and max_range are scalar floats that specify the range for\nthe output data.', '\n', 'When input data type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = in[i] * (max_range - min_range) / 255.0', ',', '\n', 'When input data type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0', ',', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/dequantize.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.dgl_adjacency(data=None, out=None, name=None, **kwargs)Â¶","['This operator converts a CSR matrix whose values are edge Ids\nto an adjacency matrix whose values are ones. The output CSR matrix always has\nthe data value of float32.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1424', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.dgl_csr_neighbor_non_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graph from a csr graph via an\nnon-uniform probability. The operator is designed for DGL.', '\n', 'The operator outputs four sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,\n4) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L911', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.dgl_csr_neighbor_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graphs from a csr graph via an\nuniform probability. The operator is designed for DGL.', '\n', 'The operator outputs three sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L801', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.dgl_graph_compact(*graph_data, **kwargs)Â¶","['This operator compacts a CSR matrix generated by\ndgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.\nThe CSR matrices generated by these two operators may have many empty\nrows at the end and many empty columns. This operator removes these\nempty rows and empty columns.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1613', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.dgl_subgraph(*data, **kwargs)Â¶","['This operator constructs an induced subgraph for\na given set of vertices from a graph. The operator accepts multiple\nsets of vertices as input. For each set of vertices, it returns a pair\nof CSR matrices if return_mapping is True: the first matrix contains edges\nwith new edge Ids, the second matrix contains edges with the original\nedge Ids.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1171', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.div_sqrt_dim(data=None, out=None, name=None, **kwargs)Â¶","['Rescale the input by the square root of the channel dimension.', '\n', '\n', 'out = data / sqrt(data.shape[-1])', '\n', 'Defined in src/operator/contrib/transformer.cc:L832', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.edge_id(data=None, u=None, v=None, out=None, name=None, **kwargs)Â¶","['This operator implements the edge_id function for a graph\nstored in a CSR matrix (the value of the CSR stores the edge Id of the graph).\noutput[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],\notherwise output[i] will be -1. Both u and v should be 1D vectors.', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1352', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.fft(data=None, compute_size=_Null, out=None, name=None, **kwargs)Â¶","['Apply 1D FFT to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'fft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.\nThe output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, â\x80¦].', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/fft.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.getnnz(data=None, axis=_Null, out=None, name=None, **kwargs)Â¶","['Number of stored values for a sparse tensor, including explicit zeros.', '\n', 'This operator only supports CSR matrix on CPU.', '\n', 'Defined in src/operator/contrib/nnz.cc:L176', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.gradientmultiplier(data=None, scalar=_Null, is_int=_Null, out=None, name=None, **kwargs)Â¶","['This operator implements the gradient multiplier function.\nIn forward pass it acts as an identity transform. During backpropagation it\nmultiplies the gradient from the subsequent level by a scalar factor lambda and passes it to\nthe preceding layer.', '\n', 'Defined in src/operator/contrib/gradient_multiplier_op.cc:L78', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.group_adagrad_update(weight=None, grad=None, history=None, lr=_Null, rescale_grad=_Null, clip_gradient=_Null, epsilon=_Null, out=None, name=None, **kwargs)Â¶","['Update function for Group AdaGrad optimizer.', '\n', 'Referenced from ', 'Adaptive Subgradient Methods for Online Learning and Stochastic Optimization', ',\nand available at ', 'http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf', ' but\nuses only a single learning rate for every row of the parameter array.', '\n', 'Updates are applied by:', '\n', None, '\n', '\n', 'Weights are updated lazily if the gradient is sparse.', '\n', 'Note that non-zero values for the weight decay option are not supported.', '\n', 'Defined in src/operator/contrib/optimizer_op.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.hawkesll(lda=None, alpha=None, beta=None, state=None, lags=None, marks=None, valid_length=None, max_time=None, out=None, name=None, **kwargs)Â¶","['Computes the log likelihood of a univariate Hawkes process.', '\n', 'The log likelihood is calculated on point process observations represented\nas ', 'ragged', ' matrices for ', 'lags', ' (interarrival times w.r.t. the previous point),\nand ', 'marks', ' (identifiers for the process ID). Note that each mark is considered independent,\ni.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:', '\n', '\n\\[\\lambda_k^*(t) = \\lambda_k + \\alpha_k \\sum_{\\{t_i < t, y_i = k\\}} \\beta_k \\exp(-\\beta_k (t - t_i))\\]', '\n', 'where ', '\\(\\lambda_k\\)', ' specifies the background intensity ', 'lda', ', ', '\\(\\alpha_k\\)', ' specifies the ', 'branching ratio', ' or ', 'alpha', ', and ', '\\(\\beta_k\\)', ' the delay density parameter ', 'beta', '.', '\n', 'lags', ' and ', 'marks', ' are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are â\x80\x9cleft-alignedâ\x80\x9d ', 'ragged', ' matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ', 'valid_length', ', of shape (N,) where ', 'valid_length[i]', ' corresponds to the number of valid points in ', 'lags[i,', ' and ', 'marks[i,', '.', '\n', 'max_time', ' is the length of the observation period of the point process. That is, specifying ', 'max_time[i]', ' computes the likelihood of the i-th sample as observed on the time interval ', '\\((0, 5]\\)', '. Naturally, the sum of all valid ', 'lags[i,', ' must be less than or equal to 5.', '\n', 'The input ', 'state', ' specifies the ', 'memory', ' of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the ', 'memory', ' as', '\n', '\n\\[s_k(t) = \\sum_{t_i < t} \\exp(-\\beta_k (t - t_i)).\\]', '\n', 'The ', 'state', ' to be provided is ', '\\(s_k(0)\\)', ' and carries the added intensity due to past events before the current batch. ', '\\(s_k(T)\\)', ' is returned from the function where ', '\\(T\\)', ' is ', 'max_time[T]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'References:', '\n', '\n', 'Bacry, E., Mastromatteo, I., & Muzy, J. F. (2015).\nHawkes processes in finance. Market Microstructure and Liquidity\n, 1(01), 1550005.', '\n', '\n', 'Defined in src/operator/contrib/hawkes_ll.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.ifft(data=None, compute_size=_Null, out=None, name=None, **kwargs)Â¶","['Apply 1D ifft to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'ifft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, â\x80¦].\nLast dimension must be an even number.\nThe output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/ifft.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.index_array(data=None, axes=_Null, out=None, name=None, **kwargs)Â¶","['Returns an array of indexes of the input array.', '\n', 'For an input array with shape  ', '\\((d_1, d_2, ..., d_n)\\)', ', ', 'index_array', ' returns a\n', '\\((d_1, d_2, ..., d_n, n)\\)', ' array ', 'idx', ', where\n', '\\(idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]\\)', '.', '\n', 'Additionally, when the parameter ', 'axes', ' is specified, ', 'idx', ' will be a\n', '\\((d_1, d_2, ..., d_n, m)\\)', ' array where ', 'm', ' is the length of ', 'axes', ', and the following\nequality will hold: ', '\\(idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}\\)', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_array.cc:L118', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.index_copy(old_tensor=None, index_vector=None, new_tensor=None, out=None, name=None, **kwargs)Â¶","['Copies the elements of a ', 'new_tensor', ' into the ', 'old_tensor', '.', '\n', 'This operator copies the elements by selecting the indices in the order given in ', 'index', '.\nThe output will be a new tensor containing the rest elements of old tensor and\nthe copied elements of new tensor.\nFor example, if ', 'index[i] == j', ', then the ', 'i', ' th row of ', 'new_tensor', ' is copied to the\n', 'j', ' th row of output.', '\n', 'The ', 'index', ' must be a vector and it must have the same size with the ', '0', ' th dimension of\n', 'new_tensor', '. Also, the ', '0', ' th dimension of old_tensor must ', '>=', ' the ', '0', ' th dimension of\n', 'new_tensor', ', or an error will be raised.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_copy.cc:L183', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.interleaved_matmul_encdec_qk(queries=None, keys_values=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of projections of queries following the layout:\n(seq_length, batch_size, num_heads * head_dim)', '\n', 'and a tensor of interleaved projections of values and keys following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'the equivalent code would be:\nq_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\ntmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))\nk_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L753', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.interleaved_matmul_encdec_valatt(keys_values=None, attention=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of interleaved projections of\nkeys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:', '\n', 'tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L799', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.interleaved_matmul_selfatt_qk(queries_keys_values=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as self attention.', '\n', 'the input must be a single tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nq_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\nk_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L665', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.interleaved_matmul_selfatt_valatt(queries_keys_values=None, attention=None, heads=_Null, out=None, name=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as self attention.', '\n', 'the inputs must be a tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L709', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.intgemm_fully_connected(data=None, weight=None, scaling=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out_type=_Null, out=None, name=None, **kwargs)Â¶","['Multiply matrices using 8-bit integers.  data * weight.', '\n', 'Input tensor arguments are: data weight [scaling] [bias]', '\n', 'data: either float32 or prepared using intgemm_prepare_data (in which case it is int8).', '\n', 'weight: must be prepared using intgemm_prepare_weight.', '\n', 'scaling: present if and only if out_type is float32. If so this is multiplied by the result before adding bias. Typically:\nscaling = (max passed to intgemm_prepare_weight)/127.0 if data is in float32\nscaling = (max_passed to intgemm_prepare_data)/127.0 * (max passed to intgemm_prepare_weight)/127.0 if data is in int8', '\n', 'bias: present if and only if !no_bias. This is added to the output after scaling and has the same number of columns as the output.', '\n', 'out_type: type of the output.', '\n', 'Defined in src/operator/contrib/intgemm/intgemm_fully_connected_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.intgemm_maxabsolute(data=None, out=None, name=None, **kwargs)Â¶","['Compute the maximum absolute value in a tensor of float32 fast on a CPU.  The tensorâ\x80\x99s total size must be a multiple of 16 and aligned to a multiple of 64 bytes.\nmxnet.nd.contrib.intgemm_maxabsolute(arr) == arr.abs().max()', '\n', 'Defined in src/operator/contrib/intgemm/max_absolute_op.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.intgemm_prepare_data(data=None, maxabs=None, out=None, name=None, **kwargs)Â¶","['This operator converts quantizes float32 to int8 while also banning -128.', '\n', 'It it suitable for preparing an data matrix for use by intgemmâ\x80\x99s C=data * weights operation.', '\n', 'The float32 values are scaled such that maxabs maps to 127. Typically maxabs = maxabsolute(A).', '\n', 'Defined in src/operator/contrib/intgemm/prepare_data_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.intgemm_prepare_weight(weight=None, maxabs=None, already_quantized=_Null, out=None, name=None, **kwargs)Â¶","['This operator converts a weight matrix in column-major format to intgemmâ\x80\x99s internal fast representation of weight matrices.  MXNet customarily stores weight matrices in column-major (transposed) format. This operator is not meant to be fast; it is meant to be run offline to quantize a model.', '\n', 'In other words, it prepares weight for the operation C = data * weight^T.', '\n', 'If the provided weight matrix is float32, it will be quantized first.  The quantization function is (int8_t)(127.0 / max * weight) where multiplier is provided as argument 1 (the weight matrix is argument 0).  Then the matrix will be rearranged into the CPU-dependent format.', '\n', 'If the provided weight matrix is already int8, the matrix will only be rearranged into the CPU-dependent format.  This way one can quantize with intgemm_prepare_data (which just quantizes), store to disk in a consistent format, then at load time convert to CPU-dependent format with intgemm_prepare_weight.', '\n', 'The internal representation depends on register length.  So AVX512, AVX2, and SSSE3 have different formats.  AVX512BW and AVX512VNNI have the same representation.', '\n', 'Defined in src/operator/contrib/intgemm/prepare_weight_op.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.intgemm_take_weight(weight=None, indices=None, out=None, name=None, **kwargs)Â¶","['Index a weight matrix stored in intgemmâ\x80\x99s weight format.\nThe indices select the outputs of matrix multiplication, not the inner dot product dimension.', '\n', 'Defined in src/operator/contrib/intgemm/take_weight_op.cc:L128', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quadratic(data=None, a=_Null, b=_Null, c=_Null, out=None, name=None, **kwargs)Â¶","['This operators implements the quadratic function.', '\n', '\n\\[f(x) = ax^2+bx+c\\]', '\n', 'where ', '\\(x\\)', ' is an input tensor and all operations\nin the function are element-wise.', '\n', 'Example:', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/quadratic_op.cc:L50', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantize(data=None, min_range=None, max_range=None, out_type=_Null, out=None, name=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_range', ' and ', 'max_range', '.', '\n', 'min_range and max_range are scalar floats that specify the range for\nthe input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize.cc:L73', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantize_asym(data=None, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Quantize a input tensor from float to uint8_t.\nOutput ', 'scale', ' and ', 'shift', ' are scalar floats that specify the quantization parameters for the input\ndata.\nThe output is calculated using the following equation:\n', 'out[i] = in[i] * scale + shift + 0.5', ',\nwhere ', 'scale = uint8_range / (max_range - min_range)', ' and\n', 'shift = numeric_limits<T>::max - max_range * scale', '.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantize_asym.cc:L115', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantize_v2(data=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_calib_range', ' and ', 'max_calib_range', ' or the input range collected at runtime.', '\n', 'Output ', 'min_range', ' and ', 'max_range', ' are scalar floats that specify the range for the input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', 'When out_type is ', 'auto', ', the output type is automatically determined by min_calib_range if presented.\nIf min_calib_range < 0.0f, the output type will be int8, otherwise will be uint8.\nIf min_calib_range isnâ\x80\x99t presented, the output type will be int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize_v2.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_act(data=None, min_data=None, max_data=None, act_type=_Null, out=None, name=None, **kwargs)Â¶","['Activation operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_activation.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_batch_norm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, min_data=None, max_data=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['BatchNorm operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_batch_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.\nAll inputs with different min/max will be rescaled by using largest [min, max] pairs.\nIf any input holds int8, then the output will be int8. Otherwise output will be uint8.', '\n', 'Defined in src/operator/quantization/quantized_concat.cc:L107', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_conv(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Convolution operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_conv.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_elemwise_add(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, out=None, name=None, **kwargs)Â¶","['elemwise_add operator for input dataA and input dataB data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_elemwise_mul(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, min_calib_range=_Null, max_calib_range=_Null, enable_float_output=_Null, out=None, name=None, **kwargs)Â¶","['Multiplies arguments int8 element-wise.', '\n', 'Defined in src/operator/quantization/quantized_elemwise_mul.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_embedding(data=None, weight=None, min_weight=None, max_weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, out=None, name=None, **kwargs)Â¶","['Maps integer indices to int8 vector representations (embeddings).', '\n', 'Defined in src/operator/quantization/quantized_indexing_op.cc:L133', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_flatten(data=None, min_data=None, max_data=None, out=None, name=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_fully_connected(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out=None, name=None, **kwargs)Â¶","['Fully Connected operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_fully_connected.cc:L312', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_pooling(data=None, min_data=None, max_data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Pooling operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_pooling.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.quantized_rnn(data=None, parameters=None, state=None, state_cell=None, data_scale=None, data_shift=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, out=None, name=None, **kwargs)Â¶","['RNN operator for input data type of uint8. The weight of each gates is converted\nto int8, while bias is accumulated in type float32. The hidden state and cell state are in type\nfloat32. For the input data, two more arguments of type float32 must be provided representing the\nthresholds of quantizing argument from data type float32 to uint8. The final outputs contain the\nrecurrent result in float32. It only supports quantization for Vanilla LSTM network.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantized_rnn.cc:L298', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.requantize(data=None, min_range=None, max_range=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Given data that is quantized in int32 and the corresponding thresholds,\nrequantize the data into int8 using min and max thresholds either calculated at runtime\nor from calibration. Itâ\x80\x99s highly recommended to pre-calucate the min and max thresholds\nthrough calibration since it is able to save the runtime of the operator and improve the\ninference accuracy.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/requantize.cc:L59', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.round_ste(data=None, out=None, name=None, **kwargs)Â¶","['Straight-through-estimator of ', 'round()', '.', '\n', 'In forward pass, returns element-wise rounded value to the nearest integer of the input (same as ', 'round()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'round()', '):\n', '\\(\\frac{d}{dx}{round\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{round(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])\nx.backward()\nx = [-2.,  2., -2.,  2.,  3.]\nx.grad() = [1.,  1., 1.,  1.,  1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L54', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.ndarray.sign_ste(data=None, out=None, name=None, **kwargs)Â¶","['Straight-through-estimator of ', 'sign()', '.', '\n', 'In forward pass, returns element-wise sign of the input (same as ', 'sign()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'sign()', '):\n', '\\(\\frac{d}{dx}{sign\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{sign(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = sign_ste([-2, 0, 3])\nx.backward()\nx = [-1.,  0., 1.]\nx.grad() = [1.,  1., 1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L79', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.contrib.onnx.export_model_(sym, params, in_shapes=None, in_types=<class 'numpy.float32'>, onnx_file_path='model.onnx', verbose=False, dynamic=False, dynamic_input_shapes=None, run_shape_inference=False, input_type=None, input_shape=None)Â¶","['Exports the MXNet model file, passed as a parameter, into ONNX model.\nAccepts both symbol,parameter objects as well as json and params filepaths as input.\nOperator support and coverage -\n', 'https://github.com/apache/incubator-mxnet/tree/v1.x/python/mxnet/onnx#operator-support-matrix', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'onnx_file_path', '\n', 'Return type', '\n', 'str', '\n', '\n', 'Notes', '\n', 'This method is available when you ', 'import', '\n', '\n']",,,
"
mxnet.contrib.onnx.get_model_metadata_(model_file)Â¶","['Returns the name and shape information of input and output tensors of the given ONNX model file.', '\n', 'Notes', '\n', 'This method is available when you ', 'import', '\n', '\n', 'Parameters', '\n', 'model_file', '\n', 'Returns', '\n', 'model_metadata', '\n', 'Return type', '\n', 'dict', '\n', '\n', '\n']",,,
"
mxnet.contrib.onnx.import_model_(model_file)Â¶","['Imports the ONNX model file, passed as a parameter, into MXNet symbol and parameters.\nOperator support and coverage -\n', 'https://cwiki.apache.org/confluence/display/MXNET/ONNX+Operator+Coverage', '\n', '\n', 'Parameters', '\n', 'model_file', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Notes', '\n', 'This method is available when you ', 'import', '\n', '\n']",,,
"
mxnet.contrib.onnx.import_to_gluon_(model_file, ctx)Â¶","['Imports the ONNX model files, passed as a parameter, into Gluon SymbolBlock object.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'sym_block', '\n', 'Return type', '\n', 'SymbolBlock', '\n', '\n', 'Notes', '\n', 'This method is available when you ', 'import', '\n', '\n']",,,
"
mxnet.contrib.quantization.calib_graph(qsym, arg_params, aux_params, collector, calib_mode='entropy', quantized_dtype='int8', logger=<module 'logging' from '/work/conda_env/lib/python3.9/logging/__init__.py'>)[source]Â¶","['User-level API for calibrating a quantized model using a filled collector.\nThe backend quantized operators are only enabled for Linux systems. Please do not run\ninference using the quantized models on Windows for now.\n:param qsym: Defines the structure of a neural network for INT8 data types.\n:type qsym: str or Symbol\n:param arg_params: Dictionary of name to ', 'NDArray', '.\n:type arg_params: dict\n:param aux_params: Dictionary of name to ', 'NDArray', '.\n:type aux_params: dict\n:param collector: layer collector for naive or entropy calibration.\n:type collector: function\n:param calib_mode: If calib_mode=â\x80\x99noneâ\x80\x99, no calibration will be used and the thresholds for', '\n', '\n', 'requantization after the corresponding layers will be calculated at runtime by\ncalling min and max operators. The quantized models generated in this\nmode are normally 10-20% slower than those with calibrations during inference.\nIf calib_mode=â\x80\x99naiveâ\x80\x99, the min and max values of the layer outputs from a calibration\ndataset will be directly taken as the thresholds for quantization.\nIf calib_mode=â\x80\x99entropyâ\x80\x99 (default mode), the thresholds for quantization will be\nderived such that the KL divergence between the distributions of FP32 layer outputs and\nquantized layer outputs is minimized based upon the calibration dataset.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.quantization.combine_histogram(old_hist, arr, new_min, new_max, new_th)[source]Â¶","['Collect layer histogram for arr and combine it with old histogram.', '\n', '\n']",,,
"
mxnet.contrib.quantization.quantize_graph(sym, arg_params, aux_params, ctx=cpu(0), excluded_sym_names=None, excluded_op_names=None, calib_mode='entropy', quantized_dtype='int8', quantize_mode='full', quantize_granularity='tensor-wise', LayerOutputCollector=None, logger=None)[source]Â¶","['User-level API for generating a quantized model from a FP32 model w/o calibration\nand a collector for naive or entropy calibration.\nThe backend quantized operators are only enabled for Linux systems. Please do not run\ninference using the quantized models on Windows for now.\n:param sym: Defines the structure of a neural network for FP32 data types.\n:type sym: str or Symbol\n:param ctx: Defines the device that users want to run forward propagation on the calibration', '\n', '\n', 'dataset for collecting layer output statistics. Currently, only supports single context.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.quantization.quantize_model(sym, arg_params, aux_params, data_names=('data', ), label_names=('softmax_label', ), ctx=cpu(0), excluded_sym_names=None, excluded_op_names=None, calib_mode='entropy', calib_data=None, num_calib_examples=None, quantized_dtype='int8', quantize_mode='smart', quantize_granularity='tensor-wise', logger=None)[source]Â¶","['User-level API for generating a quantized model from a FP32 model w/ or w/o calibration.\nThe backend quantized operators are only enabled for Linux systems. Please do not run\ninference using the quantized models on Windows for now.\nThe quantization implementation adopts the TensorFlowâ\x80\x99s approach:\n', 'https://www.tensorflow.org/performance/quantization', '.\nThe calibration implementation borrows the idea of Nvidiaâ\x80\x99s 8-bit Inference with TensorRT:\n', 'http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf', '\nand adapts the method to MXNet.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.quantization.quantize_model_mkldnn(sym, arg_params, aux_params, data_names=('data', ), label_names=('softmax_label', ), ctx=cpu(0), excluded_sym_names=None, excluded_op_names=None, calib_mode='entropy', calib_data=None, num_calib_examples=None, quantized_dtype='int8', quantize_mode='smart', quantize_granularity='tensor-wise', logger=None)[source]Â¶","['User-level API for generating a fusion + quantized model from a FP32 model\nw/ or w/o calibration with Intel MKL-DNN.\nThe backend quantized operators are only enabled for Linux systems. Please do not run\ninference using the quantized models on Windows for now.', '\n', '\n', 'Parameters', '\n', 'with quantize_model', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.quantization.quantize_net(network, quantized_dtype='auto', quantize_mode='full', exclude_layers=None, exclude_layers_match=None, exclude_operators=None, calib_data=None, data_shapes=None, calib_mode='none', num_calib_examples=None, ctx=cpu(0), logger=None)[source]Â¶","['User-level API for Gluon users to generate a quantized SymbolBlock from a FP32 HybridBlock w/ or w/o calibration.\nWill be deprecated after MXNet 2.0, please use quantize_net_v2.', '\n', '\n']",,,
"
mxnet.contrib.quantization.quantize_net_v2(network, quantized_dtype='auto', quantize_mode='full', quantize_granularity='tensor-wise', exclude_layers=None, exclude_layers_match=None, exclude_operators=None, calib_data=None, data_shapes=None, calib_mode='none', num_calib_examples=None, ctx=cpu(0), LayerOutputCollector=None, logger=None)[source]Â¶","['User-level API for Gluon users to generate a quantized SymbolBlock from a FP32 HybridBlock w/ or w/o calibration.\nThe backend quantized operators are only enabled for Linux systems. Please do not run\ninference using the quantized models on Windows for now.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.AdaptiveAvgPooling2D(data=None, output_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).\nThe pooling kernel and stride sizes are automatically chosen for desired output sizes.', '\n', '\n', 'If a single integer is provided for output_size, the output size is (N x C x output_size x output_size) for any input (NCHW).', '\n', 'If a tuple of integers (height, width) are provided for output_size, the output size is (N x C x height x width) for any input (NCHW).', '\n', '\n', 'Defined in src/operator/contrib/adaptive_avg_pooling.cc:L213', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.BatchNormWithReLU(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization with ReLU fusion.', '\n', 'An extented operator of Batch normalization which can fuse ReLU activation.', '\n', 'Defined in src/operator/contrib/batch_norm_relu.cc:L249', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.BilinearResize2D(data=None, like=None, height=_Null, width=_Null, scale_height=_Null, scale_width=_Null, mode=_Null, align_corners=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.', '\n', 'Expected input is a 4 dimensional NDArray (NCHW) and the output\nwith the shape of (N x C x height x width).\nThe key idea of bilinear interpolation is to perform linear interpolation\nfirst in one direction, and then again in the other direction. See the wikipedia of\n', 'Bilinear interpolation', '\nfor more details.', '\n', 'Defined in src/operator/contrib/bilinear_resize.cc:L219', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.DeformableConvolution(data=None, offset=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute 2-D deformable convolution on 4-D input.', '\n', 'The deformable convolution operation is described in ', 'https://arxiv.org/abs/1703.06211', '\n', 'For 2-D deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'data', ' into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset on the ', 'i', '-th part\nof the data.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.DeformablePSROIPooling(data=None, rois=None, trans=None, spatial_scale=_Null, output_dim=_Null, group_size=_Null, pooled_size=_Null, part_size=_Null, sample_per_part=_Null, trans_std=_Null, no_trans=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs deformable position-sensitive region-of-interest pooling on inputs.\nThe DeformablePSROIPooling operation is described in ', 'https://arxiv.org/abs/1703.06211', ' .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.ModulatedDeformableConvolution(data=None, offset=None, mask=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, num_deformable_group=_Null, workspace=_Null, no_bias=_Null, im2col_step=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute 2-D modulated deformable convolution on 4-D input.', '\n', 'The modulated deformable convolution operation is described in ', 'https://arxiv.org/abs/1811.11168', '\n', 'For 2-D modulated deformable convolution, the shapes are', '\n', '\n', 'data', '\n', 'offset', '\n', 'mask', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channle, height,\nwidth)', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concating all\nthe ', 'g', ' results.', '\n', 'If ', 'num_deformable_group', ' is larger than 1, denoted by ', 'dg', ', then split the\ninput ', 'offset', ' evenly into ', 'dg', ' parts along the channel axis, and also evenly\nsplit ', 'out', ' evenly into ', 'dg', ' parts along the channel axis. Next compute the\ndeformable convolution, apply the ', 'i', '-th part of the offset part on the ', 'i', '-th\nout.', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'Defined in src/operator/contrib/modulated_deformable_convolution.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.MultiBoxDetection(cls_prob=None, loc_pred=None, anchor=None, clip=_Null, threshold=_Null, background_id=_Null, nms_threshold=_Null, force_suppress=_Null, variances=_Null, nms_topk=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Convert multibox detection predictions.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.MultiBoxPrior(data=None, sizes=_Null, ratios=_Null, clip=_Null, steps=_Null, offsets=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generate prior(anchor) boxes from data, sizes and ratios.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.MultiBoxTarget(anchor=None, label=None, cls_pred=None, overlap_threshold=_Null, ignore_label=_Null, negative_mining_ratio=_Null, negative_mining_thresh=_Null, minimum_negative_samples=_Null, variances=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute Multibox training targets', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.MultiProposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.PSROIPooling(data=None, rois=None, spatial_scale=_Null, output_dim=_Null, pooled_size=_Null, group_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.Proposal(cls_prob=None, bbox_pred=None, im_info=None, rpn_pre_nms_top_n=_Null, rpn_post_nms_top_n=_Null, threshold=_Null, rpn_min_size=_Null, scales=_Null, ratios=_Null, feature_stride=_Null, output_score=_Null, iou_loss=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Generate region proposals via RPN', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.ROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sample_ratio=_Null, position_sensitive=_Null, aligned=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.\nThis operator is typically used in Faster R-CNN & Mask R-CNN networks. If roi batchid is less\nthan 0, it will be ignored, and the corresponding output will be set to 0.', '\n', 'Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning\nthe extracted features with the input. RoIAlign computes the value of each sampling point\nby bilinear interpolation from the nearby grid points on the feature map. No quantization is\nperformed on any coordinates involved in the RoI, its bins, or the sampling points.\nBilinear interpolation is used to compute the exact values of the\ninput features at four regularly sampled locations in each RoI bin.\nThen the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'He, Kaiming, et al. â\x80\x9cMask R-CNN.â\x80\x9d ICCV, 2017', '\n', 'Defined in src/operator/contrib/roi_align.cc:L558', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.RROIAlign(data=None, rois=None, pooled_size=_Null, spatial_scale=_Null, sampling_ratio=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Performs Rotated ROI Align on the input array.', '\n', 'This operator takes a 4D feature map as an input array and region proposals as ', 'rois', ',\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.', '\n', 'Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.\nRRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby\ngrid points on the rotated feature map. No quantization is performed on any coordinates\ninvolved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to\ncompute the exact values of the input features at four regularly sampled locations in\neach RoI bin. Then the feature map can be aggregated by avgpooling.', '\n', 'References', '\n', 'Ma, Jianqi, et al. â\x80\x9cArbitrary-Oriented Scene Text Detection via Rotation Proposals.â\x80\x9d\nIEEE Transactions on Multimedia, 2018.', '\n', 'Defined in src/operator/contrib/rroi_align.cc:L273', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.SparseEmbedding(data=None, weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Maps integer indices to vector representations (embeddings).', '\n', 'note:: ', 'contrib.SparseEmbedding', ' is deprecated, use ', 'Embedding', ' instead.', '\n', 'This operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.', '\n', 'For an input array of shape (d1, â\x80¦, dK),\nthe shape of an output array is (d1, â\x80¦, dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).', '\n', 'If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).', '\n', 'The storage type of the gradient will be ', 'row_sparse', '.', '\n', '\n', 'Note', '\n', 'SparseEmbedding', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/indexing_op.cc:L674', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.SyncBatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, ndev=_Null, key=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.\nStandard BN ', '1', ' implementation only normalize the data within each device.\nSyncBN normalizes the input within the whole mini-batch.\nWe follow the sync-onece implmentation described in the paper ', '2', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Reference:', '\n', '\n', '\n', 'Defined in src/operator/contrib/sync_batch_norm.cc:L96', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.allclose(a=None, b=None, rtol=_Null, atol=_Null, equal_nan=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)', '\n', '\n\\[f(x) = |aâ\x88\x92b|â\x89¤atol+rtol|b|\\]', '\n', 'where\n', '\\(a, b\\)', ' are the input tensors of equal types an shapes\n', '\\(atol, rtol\\)', ' the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/allclose_op.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.arange_like(data=None, start=_Null, step=_Null, repeat=_Null, ctx=_Null, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Return an array with evenly spaced values. If axis is not given, the output will\nhave the same shape as the input array. Otherwise, the output will be a 1-D array with size of\nthe specified axis in input shape.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.backward_gradientmultiplier(data=None, scalar=_Null, is_int=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.backward_hawkesll(name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'name', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.backward_index_copy(name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'name', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.backward_quadratic(name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', 'name', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.bipartite_matching(data=None, is_ascend=_Null, threshold=_Null, topk=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Compute bipartite matching.', 'The matching is performed on score matrix with shape [B, N, M]\n- B: batch_size\n- N: number of rows to match\n- M: number of columns as reference to be matched against.', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L182', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.boolean_mask(data=None, index=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Given an n-d NDArray data, and a 1-d NDArray index,\nthe operator produces an un-predeterminable shaped n-d NDArray out,\nwhich stands for the rows in x where the corresonding element in index is non-zero.', '\n', None, '\n', '\n', '[[4. 5. 6.]]\n<NDArray 1x3 @cpu(0)>', '\n', 'Defined in src/operator/contrib/boolean_mask.cc:L195', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.box_decode(data=None, anchors=None, std0=_Null, std1=_Null, std2=_Null, std3=_Null, clip=_Null, format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Decode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L233', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.box_encode(samples=None, matches=None, anchors=None, refs=None, means=None, stds=None, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Encode bounding boxes training target with normalized center offsets.', 'Input bounding boxes are using corner type: ', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L210', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.box_iou(lhs=None, rhs=None, format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Bounding box overlap of two arrays.', 'The overlap is defined as Intersection-over-Union, aka, IOU.\n- lhs: (a_1, a_2, â\x80¦, a_n, 4) array\n- rhs: (b_1, b_2, â\x80¦, b_n, 4) array\n- output: (a_1, a_2, â\x80¦, a_n, b_1, b_2, â\x80¦, b_n) array', '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L136', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.box_nms(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.box_non_maximum_suppression(data=None, overlap_thresh=_Null, valid_thresh=_Null, topk=_Null, coord_start=_Null, score_index=_Null, id_index=_Null, background_id=_Null, force_suppress=_Null, in_format=_Null, out_format=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply non-maximum suppression to input.', '\n', 'The output will be sorted in descending order according to ', 'score', '. Boxes with\noverlaps larger than ', 'overlap_thresh', ', smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.', '\n', 'During back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.', '\n', 'Input requirements:', '\n', None, '\n', '\n', 'By default, a box is [id, score, xmin, ymin, xmax, ymax, â\x80¦],\nadditional elements are allowed.', '\n', '\n', 'id_index', '\n', 'background_id', '\n', 'coord_start', '\n', 'score_index', '\n', 'in_format', '\n', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/bounding_box.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.calibrate_entropy(hist=None, hist_edges=None, num_quantized_bins=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Provide calibrated min/max for input histogram.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/calibrate.cc:L196', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.count_sketch(data=None, h=None, s=None, out_dim=_Null, processing_batch_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply CountSketch to input: map a d-dimension data to k-dimension dataâ\x80\x9d', '\n', '\n', 'Note', '\n', 'count_sketch', '\n', '\n', 'Assume input data has shape (N, d), sign hash table s has shape (N, d),\nindex hash table h has shape (N, d) and mapping dimension out_dim = k,\neach element in s is either +1 or -1, each element in h is random integer from 0 to k-1.\nThen the operator computs:', '\n', '\n\\[out[h[i]] += data[i] * s[i]\\]', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/count_sketch.cc:L66', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.ctc_loss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.dequantize(data=None, min_range=None, max_range=None, out_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Dequantize the input tensor into a float tensor.\nmin_range and max_range are scalar floats that specify the range for\nthe output data.', '\n', 'When input data type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = in[i] * (max_range - min_range) / 255.0', ',', '\n', 'When input data type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0', ',', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/dequantize.cc:L80', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.dgl_adjacency(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['This operator converts a CSR matrix whose values are edge Ids\nto an adjacency matrix whose values are ones. The output CSR matrix always has\nthe data value of float32.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1424', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.dgl_csr_neighbor_non_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graph from a csr graph via an\nnon-uniform probability. The operator is designed for DGL.', '\n', 'The operator outputs four sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,\n4) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L911\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.dgl_csr_neighbor_uniform_sample(*seed_arrays, **kwargs)Â¶","['This operator samples sub-graphs from a csr graph via an\nuniform probability. The operator is designed for DGL.', '\n', 'The operator outputs three sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays minus two (csr matrix and probability)):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L801\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.dgl_graph_compact(*graph_data, **kwargs)Â¶","['This operator compacts a CSR matrix generated by\ndgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.\nThe CSR matrices generated by these two operators may have many empty\nrows at the end and many empty columns. This operator removes these\nempty rows and empty columns.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1613\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.dgl_subgraph(*data, **kwargs)Â¶","['This operator constructs an induced subgraph for\na given set of vertices from a graph. The operator accepts multiple\nsets of vertices as input. For each set of vertices, it returns a pair\nof CSR matrices if return_mapping is True: the first matrix contains edges\nwith new edge Ids, the second matrix contains edges with the original\nedge Ids.', '\n', 'Example', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1171\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.div_sqrt_dim(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Rescale the input by the square root of the channel dimension.', '\n', '\n', 'out = data / sqrt(data.shape[-1])', '\n', 'Defined in src/operator/contrib/transformer.cc:L832', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.edge_id(data=None, u=None, v=None, name=None, attr=None, out=None, **kwargs)Â¶","['This operator implements the edge_id function for a graph\nstored in a CSR matrix (the value of the CSR stores the edge Id of the graph).\noutput[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],\notherwise output[i] will be -1. Both u and v should be 1D vectors.', '\n', 'Example', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/dgl_graph.cc:L1352', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.fft(data=None, compute_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply 1D FFT to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'fft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.\nThe output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, â\x80¦].', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/fft.cc:L55', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.getnnz(data=None, axis=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Number of stored values for a sparse tensor, including explicit zeros.', '\n', 'This operator only supports CSR matrix on CPU.', '\n', 'Defined in src/operator/contrib/nnz.cc:L176', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.gradientmultiplier(data=None, scalar=_Null, is_int=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator implements the gradient multiplier function.\nIn forward pass it acts as an identity transform. During backpropagation it\nmultiplies the gradient from the subsequent level by a scalar factor lambda and passes it to\nthe preceding layer.', '\n', 'Defined in src/operator/contrib/gradient_multiplier_op.cc:L78', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.group_adagrad_update(weight=None, grad=None, history=None, lr=_Null, rescale_grad=_Null, clip_gradient=_Null, epsilon=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Update function for Group AdaGrad optimizer.', '\n', 'Referenced from ', 'Adaptive Subgradient Methods for Online Learning and Stochastic Optimization', ',\nand available at ', 'http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf', ' but\nuses only a single learning rate for every row of the parameter array.', '\n', 'Updates are applied by:', '\n', None, '\n', '\n', 'Weights are updated lazily if the gradient is sparse.', '\n', 'Note that non-zero values for the weight decay option are not supported.', '\n', 'Defined in src/operator/contrib/optimizer_op.cc:L70', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.hawkesll(lda=None, alpha=None, beta=None, state=None, lags=None, marks=None, valid_length=None, max_time=None, name=None, attr=None, out=None, **kwargs)Â¶","['Computes the log likelihood of a univariate Hawkes process.', '\n', 'The log likelihood is calculated on point process observations represented\nas ', 'ragged', ' matrices for ', 'lags', ' (interarrival times w.r.t. the previous point),\nand ', 'marks', ' (identifiers for the process ID). Note that each mark is considered independent,\ni.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:', '\n', '\n\\[\\lambda_k^*(t) = \\lambda_k + \\alpha_k \\sum_{\\{t_i < t, y_i = k\\}} \\beta_k \\exp(-\\beta_k (t - t_i))\\]', '\n', 'where ', '\\(\\lambda_k\\)', ' specifies the background intensity ', 'lda', ', ', '\\(\\alpha_k\\)', ' specifies the ', 'branching ratio', ' or ', 'alpha', ', and ', '\\(\\beta_k\\)', ' the delay density parameter ', 'beta', '.', '\n', 'lags', ' and ', 'marks', ' are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are â\x80\x9cleft-alignedâ\x80\x9d ', 'ragged', ' matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ', 'valid_length', ', of shape (N,) where ', 'valid_length[i]', ' corresponds to the number of valid points in ', 'lags[i,', ' and ', 'marks[i,', '.', '\n', 'max_time', ' is the length of the observation period of the point process. That is, specifying ', 'max_time[i]', ' computes the likelihood of the i-th sample as observed on the time interval ', '\\((0, 5]\\)', '. Naturally, the sum of all valid ', 'lags[i,', ' must be less than or equal to 5.', '\n', 'The input ', 'state', ' specifies the ', 'memory', ' of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the ', 'memory', ' as', '\n', '\n\\[s_k(t) = \\sum_{t_i < t} \\exp(-\\beta_k (t - t_i)).\\]', '\n', 'The ', 'state', ' to be provided is ', '\\(s_k(0)\\)', ' and carries the added intensity due to past events before the current batch. ', '\\(s_k(T)\\)', ' is returned from the function where ', '\\(T\\)', ' is ', 'max_time[T]', '.', '\n', 'Example:', '\n', None, '\n', '\n', 'References:', '\n', '\n', 'Bacry, E., Mastromatteo, I., & Muzy, J. F. (2015).\nHawkes processes in finance. Market Microstructure and Liquidity\n, 1(01), 1550005.', '\n', '\n', 'Defined in src/operator/contrib/hawkes_ll.cc:L83', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.ifft(data=None, compute_size=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Apply 1D ifft to inputâ\x80\x9d', '\n', '\n', 'Note', '\n', 'ifft', '\n', '\n', 'Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, â\x80¦].\nLast dimension must be an even number.\nThe output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/ifft.cc:L57', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.index_array(data=None, axes=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Returns an array of indexes of the input array.', '\n', 'For an input array with shape  ', '\\((d_1, d_2, ..., d_n)\\)', ', ', 'index_array', ' returns a\n', '\\((d_1, d_2, ..., d_n, n)\\)', ' array ', 'idx', ', where\n', '\\(idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]\\)', '.', '\n', 'Additionally, when the parameter ', 'axes', ' is specified, ', 'idx', ' will be a\n', '\\((d_1, d_2, ..., d_n, m)\\)', ' array where ', 'm', ' is the length of ', 'axes', ', and the following\nequality will hold: ', '\\(idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}\\)', '.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_array.cc:L118', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.index_copy(old_tensor=None, index_vector=None, new_tensor=None, name=None, attr=None, out=None, **kwargs)Â¶","['Copies the elements of a ', 'new_tensor', ' into the ', 'old_tensor', '.', '\n', 'This operator copies the elements by selecting the indices in the order given in ', 'index', '.\nThe output will be a new tensor containing the rest elements of old tensor and\nthe copied elements of new tensor.\nFor example, if ', 'index[i] == j', ', then the ', 'i', ' th row of ', 'new_tensor', ' is copied to the\n', 'j', ' th row of output.', '\n', 'The ', 'index', ' must be a vector and it must have the same size with the ', '0', ' th dimension of\n', 'new_tensor', '. Also, the ', '0', ' th dimension of old_tensor must ', '>=', ' the ', '0', ' th dimension of\n', 'new_tensor', ', or an error will be raised.', '\n', 'Examples:', '\n', None, '\n', '\n', 'Defined in src/operator/contrib/index_copy.cc:L183', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.interleaved_matmul_encdec_qk(queries=None, keys_values=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of projections of queries following the layout:\n(seq_length, batch_size, num_heads * head_dim)', '\n', 'and a tensor of interleaved projections of values and keys following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'the equivalent code would be:\nq_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\ntmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))\nk_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L753', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.interleaved_matmul_encdec_valatt(keys_values=None, attention=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as encoder-decoder.', '\n', 'the inputs must be a tensor of interleaved projections of\nkeys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 2)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:', '\n', 'tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L799', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.interleaved_matmul_selfatt_qk(queries_keys_values=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nqueries and keys in multihead attention use as self attention.', '\n', 'the input must be a single tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nq_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))\nq_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)\nq_proj = mx.nd.contrib.div_sqrt_dim(q_proj)\nk_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))\nk_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)', '\n', 'Defined in src/operator/contrib/transformer.cc:L665', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.interleaved_matmul_selfatt_valatt(queries_keys_values=None, attention=None, heads=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the matrix multiplication between the projections of\nvalues and the attention weights in multihead attention use as self attention.', '\n', 'the inputs must be a tensor of interleaved projections\nof queries, keys and values following the layout:\n(seq_length, batch_size, num_heads * head_dim * 3)', '\n', 'and the attention weights following the layout:\n(batch_size, seq_length, seq_length)', '\n', 'the equivalent code would be:\ntmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))\nv_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))\nv_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)\noutput = mx.nd.batch_dot(attention, v_proj, transpose_b=True)\noutput = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)\noutput = mx.nd.transpose(output, axes=(0, 2, 1, 3))\noutput = mx.nd.reshape(output, shape=(0, 0, -1))', '\n', 'Defined in src/operator/contrib/transformer.cc:L709', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.intgemm_fully_connected(data=None, weight=None, scaling=None, bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, out_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Multiply matrices using 8-bit integers.  data * weight.', '\n', 'Input tensor arguments are: data weight [scaling] [bias]', '\n', 'data: either float32 or prepared using intgemm_prepare_data (in which case it is int8).', '\n', 'weight: must be prepared using intgemm_prepare_weight.', '\n', 'scaling: present if and only if out_type is float32. If so this is multiplied by the result before adding bias. Typically:\nscaling = (max passed to intgemm_prepare_weight)/127.0 if data is in float32\nscaling = (max_passed to intgemm_prepare_data)/127.0 * (max passed to intgemm_prepare_weight)/127.0 if data is in int8', '\n', 'bias: present if and only if !no_bias. This is added to the output after scaling and has the same number of columns as the output.', '\n', 'out_type: type of the output.', '\n', 'Defined in src/operator/contrib/intgemm/intgemm_fully_connected_op.cc:L283', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.intgemm_maxabsolute(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Compute the maximum absolute value in a tensor of float32 fast on a CPU.  The tensorâ\x80\x99s total size must be a multiple of 16 and aligned to a multiple of 64 bytes.\nmxnet.nd.contrib.intgemm_maxabsolute(arr) == arr.abs().max()', '\n', 'Defined in src/operator/contrib/intgemm/max_absolute_op.cc:L101', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.intgemm_prepare_data(data=None, maxabs=None, name=None, attr=None, out=None, **kwargs)Â¶","['This operator converts quantizes float32 to int8 while also banning -128.', '\n', 'It it suitable for preparing an data matrix for use by intgemmâ\x80\x99s C=data * weights operation.', '\n', 'The float32 values are scaled such that maxabs maps to 127. Typically maxabs = maxabsolute(A).', '\n', 'Defined in src/operator/contrib/intgemm/prepare_data_op.cc:L112', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.intgemm_prepare_weight(weight=None, maxabs=None, already_quantized=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operator converts a weight matrix in column-major format to intgemmâ\x80\x99s internal fast representation of weight matrices.  MXNet customarily stores weight matrices in column-major (transposed) format. This operator is not meant to be fast; it is meant to be run offline to quantize a model.', '\n', 'In other words, it prepares weight for the operation C = data * weight^T.', '\n', 'If the provided weight matrix is float32, it will be quantized first.  The quantization function is (int8_t)(127.0 / max * weight) where multiplier is provided as argument 1 (the weight matrix is argument 0).  Then the matrix will be rearranged into the CPU-dependent format.', '\n', 'If the provided weight matrix is already int8, the matrix will only be rearranged into the CPU-dependent format.  This way one can quantize with intgemm_prepare_data (which just quantizes), store to disk in a consistent format, then at load time convert to CPU-dependent format with intgemm_prepare_weight.', '\n', 'The internal representation depends on register length.  So AVX512, AVX2, and SSSE3 have different formats.  AVX512BW and AVX512VNNI have the same representation.', '\n', 'Defined in src/operator/contrib/intgemm/prepare_weight_op.cc:L153', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.intgemm_take_weight(weight=None, indices=None, name=None, attr=None, out=None, **kwargs)Â¶","['Index a weight matrix stored in intgemmâ\x80\x99s weight format.\nThe indices select the outputs of matrix multiplication, not the inner dot product dimension.', '\n', 'Defined in src/operator/contrib/intgemm/take_weight_op.cc:L128', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quadratic(data=None, a=_Null, b=_Null, c=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['This operators implements the quadratic function.', '\n', '\n\\[f(x) = ax^2+bx+c\\]', '\n', 'where ', '\\(x\\)', ' is an input tensor and all operations\nin the function are element-wise.', '\n', 'Example:', '\n', None, '\n', '\n', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/quadratic_op.cc:L50', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantize(data=None, min_range=None, max_range=None, out_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_range', ' and ', 'max_range', '.', '\n', 'min_range and max_range are scalar floats that specify the range for\nthe input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize.cc:L73', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantize_asym(data=None, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Quantize a input tensor from float to uint8_t.\nOutput ', 'scale', ' and ', 'shift', ' are scalar floats that specify the quantization parameters for the input\ndata.\nThe output is calculated using the following equation:\n', 'out[i] = in[i] * scale + shift + 0.5', ',\nwhere ', 'scale = uint8_range / (max_range - min_range)', ' and\n', 'shift = numeric_limits<T>::max - max_range * scale', '.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantize_asym.cc:L115', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantize_v2(data=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Quantize a input tensor from float to ', 'out_type', ',\nwith user-specified ', 'min_calib_range', ' and ', 'max_calib_range', ' or the input range collected at runtime.', '\n', 'Output ', 'min_range', ' and ', 'max_range', ' are scalar floats that specify the range for the input data.', '\n', 'When out_type is ', 'uint8', ', the output is calculated using the following equation:', '\n', 'out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5', ',', '\n', 'where ', 'range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()', '.', '\n', 'When out_type is ', 'int8', ', the output is calculate using the following equation\nby keep zero centered for the quantized value:', '\n', 'out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)', ',', '\n', 'where\n', 'quantized_range = MinAbs(max(int8), min(int8))', ' and\n', 'scale = quantized_range / MaxAbs(min_range, max_range).', '\n', 'When out_type is ', 'auto', ', the output type is automatically determined by min_calib_range if presented.\nIf min_calib_range < 0.0f, the output type will be int8, otherwise will be uint8.\nIf min_calib_range isnâ\x80\x99t presented, the output type will be int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propagation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantize_v2.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_act(data=None, min_data=None, max_data=None, act_type=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Activation operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_activation.cc:L90', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_batch_norm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, min_data=None, max_data=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['BatchNorm operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_batch_norm.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.\nAll inputs with different min/max will be rescaled by using largest [min, max] pairs.\nIf any input holds int8, then the output will be int8. Otherwise output will be uint8.', '\n', 'Defined in src/operator/quantization/quantized_concat.cc:L107\nThis function support variable length of positional input.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_conv(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Convolution operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_conv.cc:L187', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_elemwise_add(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, name=None, attr=None, out=None, **kwargs)Â¶","['elemwise_add operator for input dataA and input dataB data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_elemwise_mul(lhs=None, rhs=None, lhs_min=None, lhs_max=None, rhs_min=None, rhs_max=None, min_calib_range=_Null, max_calib_range=_Null, enable_float_output=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Multiplies arguments int8 element-wise.', '\n', 'Defined in src/operator/quantization/quantized_elemwise_mul.cc:L221', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_embedding(data=None, weight=None, min_weight=None, max_weight=None, input_dim=_Null, output_dim=_Null, dtype=_Null, sparse_grad=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Maps integer indices to int8 vector representations (embeddings).', '\n', 'Defined in src/operator/quantization/quantized_indexing_op.cc:L133', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_flatten(data=None, min_data=None, max_data=None, name=None, attr=None, out=None, **kwargs)Â¶","['\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_fully_connected(data=None, weight=None, bias=None, min_data=None, max_data=None, min_weight=None, max_weight=None, min_bias=None, max_bias=None, num_hidden=_Null, no_bias=_Null, flatten=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Fully Connected operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/quantized_fully_connected.cc:L312', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_pooling(data=None, min_data=None, max_data=None, kernel=_Null, pool_type=_Null, global_pool=_Null, cudnn_off=_Null, pooling_convention=_Null, stride=_Null, pad=_Null, p_value=_Null, count_include_pad=_Null, layout=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Pooling operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.\nThis operator only supports ', '\n', '\n', 'Defined in src/operator/quantization/quantized_pooling.cc:L186', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.quantized_rnn(data=None, parameters=None, state=None, state_cell=None, data_scale=None, data_shift=None, state_size=_Null, num_layers=_Null, bidirectional=_Null, mode=_Null, p=_Null, state_outputs=_Null, projection_size=_Null, lstm_state_clip_min=_Null, lstm_state_clip_max=_Null, lstm_state_clip_nan=_Null, use_sequence_length=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['RNN operator for input data type of uint8. The weight of each gates is converted\nto int8, while bias is accumulated in type float32. The hidden state and cell state are in type\nfloat32. For the input data, two more arguments of type float32 must be provided representing the\nthresholds of quantizing argument from data type float32 to uint8. The final outputs contain the\nrecurrent result in float32. It only supports quantization for Vanilla LSTM network.\n.. Note:', '\n', None, '\n', '\n', 'Defined in src/operator/quantization/quantized_rnn.cc:L298', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.requantize(data=None, min_range=None, max_range=None, out_type=_Null, min_calib_range=_Null, max_calib_range=_Null, name=None, attr=None, out=None, **kwargs)Â¶","['Given data that is quantized in int32 and the corresponding thresholds,\nrequantize the data into int8 using min and max thresholds either calculated at runtime\nor from calibration. Itâ\x80\x99s highly recommended to pre-calucate the min and max thresholds\nthrough calibration since it is able to save the runtime of the operator and improve the\ninference accuracy.', '\n', '\n', 'Note', '\n', 'This operator only supports forward propogation. DO NOT use it in training.', '\n', '\n', 'Defined in src/operator/quantization/requantize.cc:L59', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.round_ste(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Straight-through-estimator of ', 'round()', '.', '\n', 'In forward pass, returns element-wise rounded value to the nearest integer of the input (same as ', 'round()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'round()', '):\n', '\\(\\frac{d}{dx}{round\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{round(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])\nx.backward()\nx = [-2.,  2., -2.,  2.,  3.]\nx.grad() = [1.,  1., 1.,  1.,  1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L54', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
mxnet.contrib.symbol.sign_ste(data=None, name=None, attr=None, out=None, **kwargs)Â¶","['Straight-through-estimator of ', 'sign()', '.', '\n', 'In forward pass, returns element-wise sign of the input (same as ', 'sign()', ').', '\n', 'In backward pass, returns gradients of ', '1', ' everywhere (instead of ', '0', ' everywhere as in ', 'sign()', '):\n', '\\(\\frac{d}{dx}{sign\\_ste(x)} = 1\\)', ' vs. ', '\\(\\frac{d}{dx}{sign(x)} = 0\\)', '.\nThis is useful for quantized training.', '\n', 'Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.', '\n', '\n', 'Example::', 'x = sign_ste([-2, 0, 3])\nx.backward()\nx = [-1.,  0., 1.]\nx.grad() = [1.,  1., 1.]', '\n', 'The storage type of ', '\n', '\n', '\n', 'Defined in src/operator/contrib/stes_op.cc:L79', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result symbol.', '\n', 'Return type', '\n', 'Symbol', '\n', '\n', '\n']",,,
"
class mxnet.contrib.tensorboard.LogMetricsCallback(logging_dir, prefix=None)[source]Â¶","['Bases: ', 'object', '\n', 'Log metrics periodically in TensorBoard.\nThis callback works almost same as ', 'callback.Speedometer', ', but write TensorBoard event file\nfor visualization. For more usage, please refer ', 'https://github.com/dmlc/tensorboard', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
class mxnet.attribute.AttrScope(**kwargs)[source]Â¶","['Bases: ', 'object', '\n', 'Attribute manager for scoping.', '\n', 'User can also inherit this object to change naming behavior.', '\n', '\n', 'Parameters', '\n', 'kwargs', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Get the attribute dict given the attribute set by the symbol.', '\n', '\n']",,,
"
class mxnet.callback.LogValidationMetricsCallback[source]Â¶","['Bases: ', 'object', '\n', 'Just logs the eval metrics at the end of an epoch.', '\n', '\n']",,,
"
class mxnet.callback.ProgressBar(total, length=80)[source]Â¶","['Bases: ', 'object', '\n', 'Displays a progress bar, indicating the percentage of batches processed within each epoch.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
class mxnet.callback.Speedometer(batch_size, frequent=50, auto_reset=True)[source]Â¶","['Bases: ', 'object', '\n', 'Logs training speed and evaluation metrics periodically.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> # Print training speed and evaluation metrics every ten batches. Batch size is one.
>>> module.fit(iterator,num_epoch=n_epoch,
... batch_end_callback=mx.callback.Speedometer(1,10))
Epoch[0] Batch [10] Speed: 1910.41 samples/sec  Train-accuracy=0.200000
Epoch[0] Batch [20] Speed: 1764.83 samples/sec  Train-accuracy=0.400000
Epoch[0] Batch [30] Speed: 1740.59 samples/sec  Train-accuracy=0.500000
",,
"
mxnet.callback.do_checkpoint(prefix, period=1)[source]Â¶","['A callback that saves a model checkpoint every few epochs.\nEach checkpoint is made up of a couple of binary files: a model description file and a\nparameters (weights and biases) file. The model description file is named\n', 'prefix', 'â\x80\x93symbol.json and the parameters file is named ', 'prefix', '-', 'epoch_number', '.params', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'callback', '\n', 'Return type', '\n', 'function', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> module.fit(iterator,num_epoch=n_epoch,
... epoch_end_callback=mx.callback.do_checkpoint(""mymodel"",1))
Start training with [cpu(0)]
Epoch[0] Resetting Data Iterator
Epoch[0] Time cost=0.100
Saved checkpoint to ""mymodel-0001.params""
Epoch[1] Resetting Data Iterator
Epoch[1] Time cost=0.060
Saved checkpoint to ""mymodel-0002.params""
",,
"
mxnet.callback.log_train_metric(period, auto_reset=False)[source]Â¶","['Callback to log the training evaluation result every period.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'callback', '\n', 'Return type', '\n', 'function', '\n', '\n', '\n']",,,
"
mxnet.callback.module_checkpoint(mod, prefix, period=1, save_optimizer_states=False)[source]Â¶","['Callback to checkpoint Module to prefix every epoch.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'callback', '\n', 'Return type', '\n', 'function', '\n', '\n', '\n']",,,
"
class mxnet.context.Context(device_type, device_id=0)[source]Â¶","['Bases: ', 'object', '\n', 'Constructs a context.', '\n', 'MXNet can run operations on CPU and different GPUs.\nA context describes the device type and ID on which computation should be carried on.', '\n', 'One can use mx.cpu and mx.gpu for short.', '\n', '\n', 'See also', '\n', 'How to run MXNet on multiple CPU/GPUs <http://mxnet.incubator.apache.org/api/faq/distributed_training>', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', 'Note', '\n', 'Context can also be used as a way to change the default context.', '\n', '\n', 'Examples', '\n', None, '\n', '\n', 'One can also explicitly specify the context when creating an array.', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Returns the device type of current context.', '\n', '\n', '\n', '\n', 'Empties the memory cache for the current contexts device.', '\n', '\n']",,,
"
mxnet.context.cpu(device_id=0)[source]Â¶","['Returns a CPU context.', '\n', 'This function is a short cut for ', ""Context('cpu',"", '.\nFor most operations, when no context is specified, the default context is ', 'cpu()', '.', '\n', 'Examples', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', 'device_id', '\n', 'Returns', '\n', 'context', '\n', 'Return type', '\n', 'Context', '\n', '\n', '\n']",,,
"
mxnet.context.cpu_pinned(device_id=0)[source]Â¶","['Returns a CPU pinned memory context. Copying from CPU pinned memory to GPU\nis faster than from normal CPU memory.', '\n', 'This function is a short cut for ', ""Context('cpu_pinned',"", '.', '\n', 'Examples', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', 'device_id', '\n', 'Returns', '\n', 'context', '\n', 'Return type', '\n', 'Context', '\n', '\n', '\n']",,,
"
mxnet.context.current_context()[source]Â¶","['Returns the current context.', '\n', 'By default, ', 'mx.cpu()', ' is used for all the computations\nand it can be overridden by using ', 'with mx.Context(x)', ' statement where\nx can be cpu(device_id) or gpu(device_id).', '\n', 'Examples', '\n', None, '\n', '\n', '\n', 'Returns', '\n', 'default_ctx', '\n', 'Return type', '\n', 'Context', '\n', '\n', '\n']",,,
"
mxnet.context.gpu(device_id=0)[source]Â¶","['Returns a GPU context.', '\n', 'This function is a short cut for Context(â\x80\x98gpuâ\x80\x99, device_id).\nThe K GPUs on a node are typically numbered as 0,â\x80¦,K-1.', '\n', 'Examples', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', 'device_id', '\n', 'Returns', '\n', 'context', '\n', 'Return type', '\n', 'Context', '\n', '\n', '\n']",,,
"
mxnet.context.gpu_memory_info(device_id=0)[source]Â¶","['Query CUDA for the free and total bytes of GPU global memory.', '\n', '\n', 'Parameters', '\n', 'device_id', '\n', 'Raises', '\n', 'Will raise an exception on any CUDA error.', '\n', 'Returns', '\n', '(free, total)', '\n', 'Return type', '\n', '(int, int)', '\n', '\n', '\n']",,,
"
mxnet.context.num_gpus()[source]Â¶","['Query CUDA for the number of GPUs present.', '\n', '\n', 'Raises', '\n', 'Will raise an exception on any CUDA error.', '\n', 'Returns', '\n', 'count', '\n', 'Return type', '\n', 'int', '\n', '\n', '\n']",,,
"
mxnet.engine.bulk(size)[source]Â¶","['Bulk execution bundles many operators to run together.\nThis can improve performance when running a lot of small\noperators sequentially.', '\n', 'Returns a scope for managing bulk size:', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.engine.set_bulk_size(size)[source]Â¶","['Set size limit on bulk execution.', '\n', 'Bulk execution bundles many operators to run together.\nThis can improve performance when running a lot of small\noperators sequentially.', '\n', '\n', 'Parameters', '\n', 'size', '\n', 'Returns', '\n', 'Previous bulk size.', '\n', 'Return type', '\n', 'int', '\n', '\n', '\n']",,,
"
class mxnet.executor.Executor(handle, symbol, ctx, grad_req, group2ctx)[source]Â¶","['Bases: ', 'object', '\n', 'Executor is the object providing efficient symbolic graph execution and optimization.', '\n', 'Examples', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Get dictionary representation of argument arrrays.', '\n', '\n', '\n', '\n', 'Get dictionary representation of auxiliary states arrays.', '\n', '\n', '\n', '\n', 'Do backward pass to get the gradient of arguments.', '\n', '\n', '\n', '\n', 'Copy parameters from arg_params, aux_params into executorâ\x80\x99s internal array.', '\n', '\n', '\n', '\n', 'Get a debug string about internal execution plan.', '\n', '\n', '\n', '\n', 'Calculate the outputs specified by the bound symbol.', '\n', '\n', '\n', '\n', 'Get an optimized version of the symbol from the executor.', '\n', '\n', '\n', '\n', 'Get dictionary representation of gradient arrays.', '\n', '\n', '\n', '\n', 'Get dictionary representation of output arrays.', '\n', '\n', '\n', '\n', 'Return a new executor with the same symbol and shared memory,\nbut different input/output shapes.\nFor runtime reshaping, variable length sequences, etc.\nThe returned executor shares state with the current one,\nand cannot be used in parallel with it.', '\n', '\n', '\n', '\n', 'Install callback for monitor.', '\n', '\n']",,,
"
class mxnet.executor_manager.DataParallelExecutorGroup(sym, arg_names, param_names, ctx, slices, train_data, shared_group=None)[source]Â¶","['Bases: ', 'object', '\n', 'A group of executors living on different devices, for data parallelization.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Perform a backward pass on each executor.', '\n', '\n', '\n', '\n', 'Perform a forward pass on each executor.', '\n', '\n', '\n', '\n', 'Load data and labels into arrays.', '\n', '\n', '\n', '\n', 'Update evaluation metric with label and current outputs.', '\n', '\n']",,,
"
class mxnet.executor_manager.DataParallelExecutorManager(symbol, ctx, train_data, arg_names, param_names, aux_names, work_load_list=None, logger=None, sym_gen=None)[source]Â¶","['Bases: ', 'object', '\n', 'Helper class to manage multiple executors for data parallelism.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Shared aux states.', '\n', '\n', '\n', '\n', 'Run backward on the current executor.', '\n', '\n', '\n', '\n', 'Copy data from each executor to ', '\n', '\n', '\n', '\n', 'Run forward on the current executor.', '\n', '\n', '\n', '\n', 'Shared gradient arrays.', '\n', '\n', '\n', '\n', 'Install monitor on all executors.', '\n', '\n', '\n', '\n', 'Load data and labels into arrays.', '\n', '\n', '\n', '\n', 'Shared parameter arrays.', '\n', '\n', '\n', '\n', 'Set parameter and aux values.', '\n', '\n', '\n', '\n', 'Update metric with the current executor.', '\n', '\n']",,,
"
class mxnet.image.Augmenter(**kwargs)[source]Â¶","['Bases: ', 'object', '\n', 'Image Augmenter base class', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Saves the Augmenter to string', '\n', '\n']",,,
"
class mxnet.image.BrightnessJitterAug(brightness)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Random brightness jitter augmentation.', '\n', '\n', 'Parameters', '\n', 'brightness', '\n', '\n', '\n']",,,
"
class mxnet.image.CastAug(typ='float32')[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Cast to float32', '\n', '\n']",,,
"
class mxnet.image.CenterCropAug(size, interp=2)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Make center crop augmenter.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.ColorJitterAug(brightness, contrast, saturation)[source]Â¶","['Bases: ', 'mxnet.image.image.RandomOrderAug', '\n', 'Apply random brightness, contrast and saturation jitter in random order.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.ColorNormalizeAug(mean, std)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Mean and std normalization.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.ContrastJitterAug(contrast)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Random contrast jitter augmentation.', '\n', '\n', 'Parameters', '\n', 'contrast', '\n', '\n', '\n']",,,
"
mxnet.image.CreateAugmenter(data_shape, resize=0, rand_crop=False, rand_resize=False, rand_mirror=False, mean=None, std=None, brightness=0, contrast=0, saturation=0, hue=0, pca_noise=0, rand_gray=0, inter_method=2)[source]Â¶","['Creates an augmenter list.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.image.CreateDetAugmenter(data_shape, resize=0, rand_crop=0, rand_pad=0, rand_gray=0, rand_mirror=False, mean=None, std=None, brightness=0, contrast=0, saturation=0, pca_noise=0, hue=0, inter_method=2, min_object_covered=0.1, aspect_ratio_range=(0.75, 1.33), area_range=(0.05, 3.0), min_eject_coverage=0.3, max_attempts=50, pad_val=(127, 127, 127))[source]Â¶","['Create augmenters for detection.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.image.CreateMultiRandCropAugmenter(min_object_covered=0.1, aspect_ratio_range=(0.75, 1.33), area_range=(0.05, 1.0), min_eject_coverage=0.3, max_attempts=50, skip_prob=0)[source]Â¶","['Helper function to create multiple random crop augmenters.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
class mxnet.image.DetAugmenter(**kwargs)[source]Â¶","['Bases: ', 'object', '\n', 'Detection base augmenter', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Saves the Augmenter to string', '\n', '\n']",,,
"
class mxnet.image.DetBorrowAug(augmenter)[source]Â¶","['Bases: ', 'mxnet.image.detection.DetAugmenter', '\n', 'Borrow standard augmenter from image classification.\nWhich is good once you know label wonâ\x80\x99t be affected after this augmenter.', '\n', '\n', 'Parameters', '\n', 'augmenter', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Override the default one to avoid duplicate dump.', '\n', '\n']",,,
"
class mxnet.image.DetHorizontalFlipAug(p)[source]Â¶","['Bases: ', 'mxnet.image.detection.DetAugmenter', '\n', 'Random horizontal flipping.', '\n', '\n', 'Parameters', '\n', 'p', '\n', '\n', '\n']",,,
"
class mxnet.image.DetRandomCropAug(min_object_covered=0.1, aspect_ratio_range=(0.75, 1.33), area_range=(0.05, 1.0), min_eject_coverage=0.3, max_attempts=50)[source]Â¶","['Bases: ', 'mxnet.image.detection.DetAugmenter', '\n', 'Random cropping with constraints', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.DetRandomPadAug(aspect_ratio_range=(0.75, 1.33), area_range=(1.0, 3.0), max_attempts=50, pad_val=(128, 128, 128))[source]Â¶","['Bases: ', 'mxnet.image.detection.DetAugmenter', '\n', 'Random padding augmenter.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.DetRandomSelectAug(aug_list, skip_prob=0)[source]Â¶","['Bases: ', 'mxnet.image.detection.DetAugmenter', '\n', 'Randomly select one augmenter to apply, with chance to skip all.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Override default.', '\n', '\n']",,,
"
class mxnet.image.ForceResizeAug(size, interp=2)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Force resize to size regardless of aspect ratio', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.HorizontalFlipAug(p)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Random horizontal flip.', '\n', '\n', 'Parameters', '\n', 'p', '\n', '\n', '\n']",,,
"
class mxnet.image.HueJitterAug(hue)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Random hue jitter augmentation.', '\n', '\n', 'Parameters', '\n', 'hue', '\n', '\n', '\n']",,,
"
class mxnet.image.ImageDetIter(batch_size, data_shape, path_imgrec=None, path_imglist=None, path_root=None, path_imgidx=None, shuffle=False, part_index=0, num_parts=1, aug_list=None, imglist=None, data_name='data', label_name='label', last_batch_handle='pad', **kwargs)[source]Â¶","['Bases: ', 'mxnet.image.image.ImageIter', '\n', 'Image iterator with a large number of augmentation choices for detection.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Override Transforms input data with specified augmentations.', '\n', '\n', '\n', '\n', 'Checks if the new label shape is valid', '\n', '\n', '\n', '\n', 'Display next image with bounding boxes drawn.', '\n', '\n', '\n', '\n', 'Override the function for returning next batch.', '\n', '\n', '\n', '\n', 'Reshape iterator for data_shape or label_shape.', '\n', '\n', '\n', '\n', 'Synchronize label shape with the input iterator. This is useful when\ntrain/validation iterators have different label padding.', '\n', '\n']",,,
"
class mxnet.image.ImageIter(batch_size, data_shape, label_width=1, path_imgrec=None, path_imglist=None, path_root=None, path_imgidx=None, shuffle=False, part_index=0, num_parts=1, aug_list=None, imglist=None, data_name='data', label_name='softmax_label', dtype='float32', last_batch_handle='pad', **kwargs)[source]Â¶","['Bases: ', 'mxnet.io.io.DataIter', '\n', 'Image data iterator with a large number of augmentation choices.\nThis iterator supports reading from both .rec files and raw image files.', '\n', 'To load input images from .rec files, use ', 'path_imgrec', ' parameter and to load from raw image\nfiles, use ', 'path_imglist', ' and ', 'path_root', ' parameters.', '\n', 'To use data partition (for distributed training) or shuffling, specify ', 'path_imgidx', ' parameter.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Transforms input data with specified augmentation.', '\n', '\n', '\n', '\n', 'Checks if the input data shape is valid', '\n', '\n', '\n', '\n', 'Checks if the input data is valid', '\n', '\n', '\n', '\n', 'Resets the iterator and ignore roll over data', '\n', '\n', '\n', '\n', 'Decodes a string or byte string to an NDArray.\nSee mx.img.imdecode for more details.', '\n', '\n', '\n', '\n', 'Returns the next batch of data.', '\n', '\n', '\n', '\n', 'Helper function for reading in next sample.', '\n', '\n', '\n', '\n', 'Final postprocessing step before image is loaded into the batch.', '\n', '\n', '\n', '\n', 'Reads an input image ', '\n', '\n', '\n', '\n', 'Resets the iterator to the beginning of the data.', '\n', '\n']",,,
"
class mxnet.image.LightingAug(alphastd, eigval, eigvec)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Add PCA based noise.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.Number[source]Â¶","['Bases: ', 'object', '\n', 'All numbers inherit from this class.', '\n', 'If you just want to check if an argument x is a number, without\ncaring what kind, use isinstance(x, Number).', '\n', '\n']",,,
"
class mxnet.image.RandomCropAug(size, interp=2)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Make random crop augmenter', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.RandomGrayAug(p)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Randomly convert to gray image.', '\n', '\n', 'Parameters', '\n', 'p', '\n', '\n', '\n']",,,
"
class mxnet.image.RandomOrderAug(ts)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Apply list of augmenters in random order', '\n', '\n', 'Parameters', '\n', 'ts', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Override the default to avoid duplicate dump.', '\n', '\n']",,,
"
class mxnet.image.RandomSizedCropAug(size, area, ratio, interp=2, **kwargs)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Make random crop with random resizing and random aspect ratio jitter augmenter.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.ResizeAug(size, interp=2)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Make resize shorter edge to size augmenter.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.image.SaturationJitterAug(saturation)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Random saturation jitter augmentation.', '\n', '\n', 'Parameters', '\n', 'saturation', '\n', '\n', '\n']",,,
"
class mxnet.image.SequentialAug(ts)[source]Â¶","['Bases: ', 'mxnet.image.image.Augmenter', '\n', 'Composing a sequential augmenter list.', '\n', '\n', 'Parameters', '\n', 'ts', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Override the default to avoid duplicate dump.', '\n', '\n']",,,
"
mxnet.image.center_crop(src, size, interp=2)[source]Â¶","['Crops the image ', 'src', ' to the given ', 'size', ' by trimming on all four\nsides and preserving the center of the image. Upsamples if ', 'src', ' is smaller\nthan ', 'size', '.', '\n', '\n', 'Note', '\n', 'This requires MXNet to be compiled with USE_OPENCV.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> withopen(""flower.jpg"",'rb')asfp:
... str_image=fp.read()
...
>>> image=mx.image.imdecode(str_image)
>>> image
<NDArray 2321x3482x3 @cpu(0)>
>>> cropped_image,(x,y,width,height)=mx.image.center_crop(image,(1000,500))
>>> cropped_image
<NDArray 500x1000x3 @cpu(0)>
>>> x,y,width,height
(1241, 910, 1000, 500)
",,
"
mxnet.image.color_normalize(src, mean, std=None)[source]Â¶","['Normalize src with mean and std.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.image.copyMakeBorder(src=None, top=_Null, bot=_Null, left=_Null, right=_Null, type=_Null, value=_Null, values=_Null, out=None, name=None, **kwargs)Â¶","['Pad image border with OpenCV.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.image.fixed_crop(src, x0, y0, w, h, size=None, interp=2)[source]Â¶","['Crop src at fixed location, and (optionally) resize it to size.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.image.imdecode(buf, *args, **kwargs)[source]Â¶","['Decode an image to an NDArray.', '\n', '\n', 'Note', '\n', 'imdecode', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', None, '\n', '\n', 'Set ', 'flag', ' parameter to 0 to get grayscale output', '\n', None, '\n', '\n', 'Set ', 'to_rgb', ' parameter to 0 to get output in OpenCV format (BGR)', '\n', None, '\n', '\n', '\n']",">>> withopen(""flower.jpg"",'rb')asfp:
... str_image=fp.read()
...
>>> image=mx.img.imdecode(str_image)
>>> image
<NDArray 224x224x3 @cpu(0)>
",">>> withopen(""flower.jpg"",'rb')asfp:
... str_image=fp.read()
...
>>> image=mx.img.imdecode(str_image,flag=0)
>>> image
<NDArray 224x224x1 @cpu(0)>
",">>> withopen(""flower.jpg"",'rb')asfp:
... str_image=fp.read()
...
>>> image=mx.img.imdecode(str_image,to_rgb=0)
>>> image
<NDArray 224x224x3 @cpu(0)>
"
"
mxnet.image.imread(filename, *args, **kwargs)[source]Â¶","['Read and decode an image to an NDArray.', '\n', '\n', 'Note', '\n', 'imread', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', None, '\n', '\n', 'Set ', 'flag', ' parameter to 0 to get grayscale output', '\n', None, '\n', '\n', 'Set ', 'to_rgb', ' parameter to 0 to get output in OpenCV format (BGR)', '\n', None, '\n', '\n', '\n']",">>> mx.img.imread(""flower.jpg"")
<NDArray 224x224x3 @cpu(0)>
",">>> mx.img.imread(""flower.jpg"",flag=0)
<NDArray 224x224x1 @cpu(0)>
",">>> mx.img.imread(""flower.jpg"",to_rgb=0)
<NDArray 224x224x3 @cpu(0)>
"
"
mxnet.image.imresize(src, w, h, *args, **kwargs)[source]Â¶","['Resize image with OpenCV.', '\n', '\n', 'Note', '\n', 'imresize', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> withopen(""flower.jpeg"",'rb')asfp:
... str_image=fp.read()
...
>>> image=mx.img.imdecode(str_image)
>>> image
<NDArray 2321x3482x3 @cpu(0)>
>>> new_image=mx.img.resize(image,240,360)
>>> new_image
<NDArray 240x360x3 @cpu(0)>
",,
"
mxnet.image.imrotate(src, rotation_degrees, zoom_in=False, zoom_out=False)[source]Â¶","['Rotates the input image(s) of a specific rotation degree.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.image.is_np_array()[source]Â¶","['Checks whether the NumPy-array semantics is currently turned on.\nThis is currently used in Gluon for checking whether an array of type ', 'mxnet.numpy.ndarray', '\nor ', 'mx.nd.NDArray', ' should be created. For example, at the time when a parameter\nis created in a ', 'Block', ', an ', 'mxnet.numpy.ndarray', ' is created if this returns true; else\nan ', 'mx.nd.NDArray', ' is created.', '\n', 'Normally, users are not recommended to use this API directly unless you known exactly\nwhat is going on under the hood.', '\n', 'Please note that this is designed as an infrastructure for the incoming\nMXNet-NumPy operators. Legacy operators registered in the modules\n', 'mx.nd', ' and ', 'mx.sym', ' are not guaranteed to behave like their counterparts\nin NumPy within this semantics.', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'A bool value indicating whether the NumPy-array semantics is currently on.', '\n', '\n', '\n']",,,
"
mxnet.image.random_crop(src, size, interp=2)[source]Â¶","['Randomly crop ', 'src', ' with ', 'size', ' (width, height).\nUpsample result if ', 'src', ' is smaller than ', 'size', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> im=mx.nd.array(cv2.imread(""flower.jpg""))
>>> cropped_im,rect=mx.image.random_crop(im,(100,100))
>>> printcropped_im
<NDArray 100x100x1 @cpu(0)>
>>> printrect
(20, 21, 100, 100)
",,
"
mxnet.image.random_rotate(src, angle_limits, zoom_in=False, zoom_out=False)[source]Â¶","['Random rotates ', 'src', ' by an angle included in angle limits.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An ', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.image.random_size_crop(src, size, area, ratio, interp=2, **kwargs)[source]Â¶","['Randomly crop src with size. Randomize area and aspect ratio.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.image.resize_short(src, size, interp=2)[source]Â¶","['Resizes shorter edge to size.', '\n', '\n', 'Note', '\n', 'resize_short', '\n', '\n', 'Resizes the original image by setting the shorter edge to size\nand setting the longer edge accordingly.\nResizing function is called from OpenCV.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'An â\x80\x98NDArrayâ\x80\x99 containing the resized image.', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> withopen(""flower.jpeg"",'rb')asfp:
... str_image=fp.read()
...
>>> image=mx.img.imdecode(str_image)
>>> image
<NDArray 2321x3482x3 @cpu(0)>
>>> size=640
>>> new_image=mx.img.resize_short(image,size)
>>> new_image
<NDArray 2321x3482x3 @cpu(0)>
",,
"
mxnet.image.scale_down(src_size, size)[source]Â¶","['Scales down crop size if itâ\x80\x99s larger than image size.', '\n', 'If width/height of the crop is larger than the width/height of the image,\nsets the width/height to the width/height of the image.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A tuple containing the scaled crop size in (width, height) format.', '\n', 'Return type', '\n', 'tuple of int', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> src_size=(640,480)
>>> size=(720,120)
>>> new_size=mx.img.scale_down(src_size,size)
>>> new_size
(640,106)
",,
"
mxnet.io.CSVIter(*args, **kwargs)Â¶","['bâ\x80\x9dReturns the CSV file iterator.nnIn this function, the ', 'data_shape', ' parameter is used to set the shape of each line of the input data.nIf a row in an input file is ', '1,2,3,4,5,6`', ' and ', 'data_shape', ' is (3,2), that rownwill be reshaped, yielding the array [[1,2],[3,4],[5,6]] of shape (3,2).nnBy default, the ', 'CSVIter', ' has ', 'round_batch', ' parameter set to ', 'True', '. So, if ', 'batch_size', 'nis 3 and there are 4 total rows in CSV file, 2 more examplesnare consumed at the first round. If ', 'reset', ' function is called after first round,nthe call is ignored and remaining examples are returned in the second round.nnIf one wants all the instances in the second round after calling ', 'reset', ', make surento set ', 'round_batch', ' to False.nnIf ', 'data_csv', ' is set, then all the files in this directory will be read.nn``reset()`` is expected to be called only after a complete pass of data.nnBy default, the CSVIter parses all entries in the data file as float32 data type,nif ', 'dtype', ' argument is set to be â\x80\x98int32â\x80\x99 or â\x80\x98int64â\x80\x99 then CSVIter will parse all entries in the filenas int32 or int64 data type accordingly.nnExamples::nn  // Contents of CSV file ', 'data/data.csv', '.n  1,2,3n  2,3,4n  3,4,5n  4,5,6nn  // Creates a ', 'CSVIter', ' with ', 'batch_size`=2 and default `round_batch`=True.n  CSVIter = mx.io.CSVIter(data_csv = â\x80\x98data/data.csvâ\x80\x99, data_shape = (3,),n  batch_size = 2)nn  // Two batches read from the above iterator are as follows:n  [[ 1.  2.  3.]n  [ 2.  3.  4.]]n  [[ 3.  4.  5.]n  [ 4.  5.  6.]]nn  // Creates a `CSVIter', ' with default ', 'round_batch', ' set to True.n  CSVIter = mx.io.CSVIter(data_csv = â\x80\x98data/data.csvâ\x80\x99, data_shape = (3,),n  batch_size = 3)nn  // Two batches read from the above iterator in the first pass are as follows:n  [[1.  2.  3.]n  [2.  3.  4.]n  [3.  4.  5.]]nn  [[4.  5.  6.]n  [1.  2.  3.]n  [2.  3.  4.]]nn  // Now, ', 'reset', ' method is called.n  CSVIter.reset()nn  // Batch read from the above iterator in the second pass is as follows:n  [[ 3.  4.  5.]n  [ 4.  5.  6.]n  [ 1.  2.  3.]]nn  // Creates a ', 'CSVIter', ' with ', 'round_batch`=False.n  CSVIter = mx.io.CSVIter(data_csv = â\x80\x98data/data.csvâ\x80\x99, data_shape = (3,),n  batch_size = 3, round_batch=False)nn  // Contents of two batches read from the above iterator in both passes, after callingn  // `reset', ' method before second pass, is as follows:n  [[1.  2.  3.]n  [2.  3.  4.]n  [3.  4.  5.]]nn  [[4.  5.  6.]n  [2.  3.  4.]n  [3.  4.  5.]]nn  // Creates a â\x80\x98CSVIterâ\x80\x99 with ', 'dtype`=â\x80\x99int32â\x80\x99n  CSVIter = mx.io.CSVIter(data_csv = â\x80\x98data/data.csvâ\x80\x99, data_shape = (3,),n  batch_size = 3, round_batch=False, dtype=â\x80\x99int32â\x80\x99)nn  // Contents of two batches read from the above iterator in both passes, after callingn  // `reset', ' method before second pass, is as follows:n  [[1  2  3]n  [2  3  4]n  [3  4  5]]nn  [[4  5  6]n  [2  3  4]n  [3  4  5]]nnnnDefined in src/io/iter_csv.cc:L307â\x80\x9d', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
class mxnet.io.DataBatch(data, label=None, pad=None, index=None, bucket_key=None, provide_data=None, provide_label=None)[source]Â¶","['Bases: ', 'object', '\n', 'A data batch.', '\n', 'MXNetâ\x80\x99s data iterator returns a batch of data for each ', 'next', ' call.\nThis data contains ', 'batch_size', ' number of examples.', '\n', 'If the input data consists of images, then shape of these images depend on\nthe ', 'layout', ' attribute of ', 'DataDesc', ' object in ', 'provide_data', ' parameter.', '\n', 'If ', 'layout', ' is set to â\x80\x98NCHWâ\x80\x99 then, images should be stored in a 4-D matrix\nof shape ', '(batch_size,', '.\nIf ', 'layout', ' is set to â\x80\x98NHWCâ\x80\x99 then, images should be stored in a 4-D matrix\nof shape ', '(batch_size,', '.\nThe channels are often in RGB order.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
class mxnet.io.DataDesc[source]Â¶","['Bases: ', 'mxnet.io.io.DataDesc', '\n', 'DataDesc is used to store name, shape, type and layout\ninformation of the data or the label.', '\n', 'The ', 'layout', ' describes how the axes in ', 'shape', ' should be interpreted,\nfor example for image data setting ', 'layout=NCHW', ' indicates\nthat the first axis is number of examples in the batch(N),\nC is number of channels, H is the height and W is the width of the image.', '\n', 'For sequential data, by default ', 'layout', ' is set to ', 'NTC', ', where\nN is number of examples in the batch, T the temporal axis representing time\nand C is the number of channels.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Get the dimension that corresponds to the batch size.', '\n', '\n', '\n', '\n', 'Get DataDesc list from attribute lists.', '\n', '\n']",,,
"
class mxnet.io.DataIter(batch_size=0)[source]Â¶","['Bases: ', 'object', '\n', 'The base class for an MXNet data iterator.', '\n', 'All I/O in MXNet is handled by specializations of this class. Data iterators\nin MXNet are similar to standard-iterators in Python. On each call to ', 'next', '\nthey return a ', 'DataBatch', ' which represents the next batch of data. When\nthere is no more data to return, it raises a ', 'StopIteration', ' exception.', '\n', '\n', 'Parameters', '\n', 'batch_size', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'See also', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Get data of current batch.', '\n', '\n', '\n', '\n', 'Get index of the current batch.', '\n', '\n', '\n', '\n', 'Get label of the current batch.', '\n', '\n', '\n', '\n', 'Get the number of padding examples in the current batch.', '\n', '\n', '\n', '\n', 'Move to the next batch.', '\n', '\n', '\n', '\n', 'Get next data batch from iterator.', '\n', '\n', '\n', '\n', 'Reset the iterator to the begin of the data.', '\n', '\n']",,,
"
mxnet.io.ImageDetRecordIter(*args, **kwargs)Â¶","['bâ\x80\x99Create iterator for image detection dataset packed in recordio.â\x80\x99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
mxnet.io.ImageRecordInt8Iter(*args, **kwargs)Â¶","['bâ\x80\x9dIterating on image RecordIO filesnn.. note:: ', 'ImageRecordInt8Iter', ' is deprecated. Use ImageRecordIter(dtype=â\x80\x99int8â\x80\x99) instead.nnThis iterator is identical to ', 'ImageRecordIter', ' except for using ', 'int8', ' asnthe data type instead of ', 'float', '.nnnnDefined in src/io/iter_image_recordio_2.cc:L940â\x80\x9d', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
mxnet.io.ImageRecordIter(*args, **kwargs)Â¶","['bâ\x80\x99Iterates on image RecordIO filesnnReads batches of images from .rec RecordIO files. One can use ', 'im2rec.py', ' tooln(in tools/) to pack raw image files into RecordIO files. This iterator is lessnflexible to customization but is fast and has lot of language bindings. Toniterate over raw images directly use ', 'ImageIter', ' instead (in Python).nnExample::nn  data_iter = mx.io.ImageRecordIter(n    path_imgrec=â\x80\x9d./sample.recâ\x80\x9d, # The target record file.n    data_shape=(3, 227, 227), # Output data shape; 227x227 region will be cropped from the original image.n    batch_size=4, # Number of items per batch.n    resize=256 # Resize the shorter edge to 256 before cropping.n    # You can specify more augmentation options. Use help(mx.io.ImageRecordIter) to see all the options.n    )n  # You can now use the data_iter to access batches of images.n  batch = data_iter.next() # first batch.n  images = batch.data[0] # This will contain 4 (=batch_size) images each of 3x227x227.n  # process the imagesn  â\x80¦n  data_iter.reset() # To restart the iterator from the beginning.nnnnDefined in src/io/iter_image_recordio_2.cc:L903â\x80\x99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
mxnet.io.ImageRecordIter_v1(*args, **kwargs)Â¶","['bâ\x80\x99Iterating on image RecordIO filesnn.. note::nn  ', 'ImageRecordIter_v1', ' is deprecated. Use ', 'ImageRecordIter', ' instead.nnnRead images batches from RecordIO files with a rich of data augmentationnoptions.nnOne can use ', 'tools/im2rec.py', ' to pack individual image files into RecordIOnfiles.nnnnDefined in src/io/iter_image_recordio.cc:L351â\x80\x99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
mxnet.io.ImageRecordUInt8Iter(*args, **kwargs)Â¶","['bâ\x80\x9dIterating on image RecordIO filesnn.. note:: ImageRecordUInt8Iter is deprecated. Use ImageRecordIter(dtype=â\x80\x99uint8â\x80\x99) instead.nnThis iterator is identical to ', 'ImageRecordIter', ' except for using ', 'uint8', ' asnthe data type instead of ', 'float', '.nnnnDefined in src/io/iter_image_recordio_2.cc:L922â\x80\x9d', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
mxnet.io.ImageRecordUInt8Iter_v1(*args, **kwargs)Â¶","['bâ\x80\x99Iterating on image RecordIO filesnn.. note::nn  ', 'ImageRecordUInt8Iter_v1', ' is deprecated. Use ', 'ImageRecordUInt8Iter', ' instead.nnThis iterator is identical to ', 'ImageRecordIter', ' except for using ', 'uint8', ' asnthe data type instead of ', 'float', '.nnnnDefined in src/io/iter_image_recordio.cc:L376â\x80\x99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
mxnet.io.LibSVMIter(*args, **kwargs)Â¶","['bâ\x80\x9dReturns the LibSVM iterator which returns data with ', 'csr', 'nstorage type. This iterator is experimental and should be used with care.nnThe input data is stored in a format similar to LibSVM file format, except that the ', 'indicesnare expected to be zero-based instead of one-based, and the column indices for each row arenexpected to be sorted in ascending order', '. Details of the LibSVM format are availablen`here. <', 'https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/', '>`_nnnThe ', 'data_shape', ' parameter is used to set the shape of each line of the data.nThe dimension of both ', 'data_shape', ' and ', 'label_shape', ' are expected to be 1.nnThe ', 'data_libsvm', ' parameter is used to set the path input LibSVM file.nWhen it is set to a directory, all the files in the directory will be read.nnWhen ', 'label_libsvm', ' is set to ', 'NULL', ', both data and label are read from the file specifiednby ', 'data_libsvm', '. In this case, the data is stored in ', 'csr', ' storage type, while the label is a 1Dndense array.nnThe ', 'LibSVMIter', ' only support ', 'round_batch', ' parameter set to ', 'True', '. Therefore, if ', 'batch_size', 'nis 3 and there are 4 total rows in libsvm file, 2 more examples are consumed at the first round.nnWhen ', 'num_parts', ' and ', 'part_index', ' are provided, the data is split into ', 'num_parts', ' partitions,nand the iterator only reads the ', 'part_index', '-th partition. However, the partitions are notnguaranteed to be even.nn``reset()`` is expected to be called only after a complete pass of data.nnExample::nn  # Contents of libsvm file ', 'data.t', '.n  1.0 0:0.5 2:1.2n  -2.0n  -3.0 0:0.6 1:2.4 2:1.2n  4 2:-1.2nn  # Creates a ', 'LibSVMIter', ' with ', 'batch_size`=3.n  >>> data_iter = mx.io.LibSVMIter(data_libsvm = â\x80\x98data.tâ\x80\x99, data_shape = (3,), batch_size = 3)n  # The data of the first batch is stored in csr storage typen  >>> batch = data_iter.next()n  >>> csr = batch.data[0]n  <CSRNDArray 3x3 @cpu(0)>n  >>> csr.asnumpy()n  [[ 0.5        0.          1.2 ]n  [ 0.          0.          0.  ]n  [ 0.6         2.4         1.2]]n  # The label of first batchn  >>> label = batch.label[0]n  >>> labeln  [ 1. -2. -3.]n  <NDArray 3 @cpu(0)>nn  >>> second_batch = data_iter.next()n  # The data of the second batchn  >>> second_batch.data[0].asnumpy()n  [[ 0.          0.         -1.2 ]n   [ 0.5         0.          1.2 ]n   [ 0.          0.          0. ]]n  # The label of the second batchn  >>> second_batch.label[0].asnumpy()n  [ 4.  1. -2.]nn  >>> data_iter.reset()n  # To restart the iterator for the second pass of the datannWhen `label_libsvm', ' is set to the path to another LibSVM file,ndata is read from ', 'data_libsvm', ' and label from ', 'label_libsvm', '.nIn this case, both data and label are stored in the csr format.nIf the label column in the ', 'data_libsvm', ' file is ignored.nnExample::nn  # Contents of libsvm file ', 'label.t', 'n  1.0n  -2.0 0:0.125n  -3.0 2:1.2n  4 1:1.0 2:-1.2nn  # Creates a ', 'LibSVMIter', ' with specified label filen  >>> data_iter = mx.io.LibSVMIter(data_libsvm = â\x80\x98data.tâ\x80\x99, data_shape = (3,),n                   label_libsvm = â\x80\x98label.tâ\x80\x99, label_shape = (3,), batch_size = 3)nn  # Both data and label are in csr storage typen  >>> batch = data_iter.next()n  >>> csr_data = batch.data[0]n  <CSRNDArray 3x3 @cpu(0)>n  >>> csr_data.asnumpy()n  [[ 0.5         0.          1.2  ]n   [ 0.          0.          0.   ]n   [ 0.6         2.4         1.2 ]]n  >>> csr_label = batch.label[0]n  <CSRNDArray 3x3 @cpu(0)>n  >>> csr_label.asnumpy()n  [[ 0.          0.          0.   ]n   [ 0.125       0.          0.   ]n   [ 0.          0.          1.2 ]]nnnnDefined in src/io/iter_libsvm.cc:L298â\x80\x9d', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
mxnet.io.MNISTIter(*args, **kwargs)Â¶","['bâ\x80\x99Iterating on the MNIST dataset.nnOne can download the dataset from ', 'http://yann.lecun.com/exdb/mnist/nnnnDefined', ' in src/io/iter_mnist.cc:L264â\x80\x99', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The result iterator.', '\n', 'Return type', '\n', 'MXDataIter', '\n', '\n', '\n']",,,
"
class mxnet.io.MXDataIter(handle, data_name='data', label_name='softmax_label', **_)[source]Â¶","['Bases: ', 'mxnet.io.io.DataIter', '\n', 'A python wrapper a C++ data iterator.', '\n', 'This iterator is the Python wrapper to all native C++ data iterators, such\nas ', 'CSVIter', ', ', 'ImageRecordIter', ', ', 'MNISTIter', ', etc. When initializing\n', 'CSVIter', ' for example, you will get an ', 'MXDataIter', ' instance to use in your\nPython code. Calls to ', 'next', ', ', 'reset', ', etc will be delegated to the\nunderlying C++ data iterators.', '\n', 'Usually you donâ\x80\x99t need to interact with ', 'MXDataIter', ' directly unless you are\nimplementing your own data iterators in C++. To do that, please refer to\nexamples under the ', 'src/io', ' folder.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'See also', '\n', 'src', '\n', '\n', '\n', '\n', '\n', 'Get data of current batch.', '\n', '\n', '\n', '\n', 'Get index of the current batch.', '\n', '\n', '\n', '\n', 'Get label of the current batch.', '\n', '\n', '\n', '\n', 'Get the number of padding examples in the current batch.', '\n', '\n', '\n', '\n', 'Move to the next batch.', '\n', '\n', '\n', '\n', 'Get next data batch from iterator.', '\n', '\n', '\n', '\n', 'Reset the iterator to the begin of the data.', '\n', '\n']",,,
"
class mxnet.io.NDArrayIter(data, label=None, batch_size=1, shuffle=False, last_batch_handle='pad', data_name='data', label_name='softmax_label', layout='NCHW')[source]Â¶","['Bases: ', 'mxnet.io.io.DataIter', '\n', 'Returns an iterator for ', 'mx.nd.NDArray', ', ', 'numpy.ndarray', ', ', 'h5py.Dataset', '\n', 'mx.nd.sparse.CSRNDArray', ' or ', 'scipy.sparse.csr_matrix', '.', '\n', 'Examples', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', None, '\n', '\n', 'In the above example, data is shuffled as ', 'shuffle', ' parameter is set to ', 'True', '\nand remaining examples are discarded as ', 'last_batch_handle', ' parameter is set to ', 'discard', '.', '\n', 'Usage of ', 'last_batch_handle', ' parameter:', '\n', None, '\n', '\n', 'NDArrayIter', ' also supports multiple input and labels.', '\n', None, '\n', '\n', 'NDArrayIter', ' also supports ', 'mx.nd.sparse.CSRNDArray', '\nwith ', 'last_batch_handle', ' set to ', 'discard', '.', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Get data.', '\n', '\n', '\n', '\n', 'Get label.', '\n', '\n', '\n', '\n', 'Get pad value of DataBatch.', '\n', '\n', '\n', '\n', 'Ignore roll over data and set to start.', '\n', '\n', '\n', '\n', 'Increments the coursor by batch_size for next batch\nand check current cursor if it exceed the number of data points.', '\n', '\n', '\n', '\n', 'Returns the next batch of data.', '\n', '\n', '\n', '\n', 'The name and shape of data provided by this iterator.', '\n', '\n', '\n', '\n', 'The name and shape of label provided by this iterator.', '\n', '\n', '\n', '\n', 'Resets the iterator to the beginning of the data.', '\n', '\n']",,,
"
class mxnet.io.PrefetchingIter(iters, rename_data=None, rename_label=None)[source]Â¶","['Bases: ', 'mxnet.io.io.DataIter', '\n', 'Performs pre-fetch for other data iterators.', '\n', 'This iterator will create another thread to perform ', 'iter_next', ' and then\nstore the data in memory. It potentially accelerates the data read, at the\ncost of more memory usage.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Get data of current batch.', '\n', '\n', '\n', '\n', 'Get index of the current batch.', '\n', '\n', '\n', '\n', 'Get label of the current batch.', '\n', '\n', '\n', '\n', 'Get the number of padding examples in the current batch.', '\n', '\n', '\n', '\n', 'Move to the next batch.', '\n', '\n', '\n', '\n', 'Get next data batch from iterator.', '\n', '\n', '\n', '\n', 'Reset the iterator to the begin of the data.', '\n', '\n']",,,
"
class mxnet.io.ResizeIter(data_iter, size, reset_internal=True)[source]Â¶","['Bases: ', 'mxnet.io.io.DataIter', '\n', 'Resize a data iterator to a given number of batches.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Get data of current batch.', '\n', '\n', '\n', '\n', 'Get index of the current batch.', '\n', '\n', '\n', '\n', 'Get label of the current batch.', '\n', '\n', '\n', '\n', 'Get the number of padding examples in the current batch.', '\n', '\n', '\n', '\n', 'Move to the next batch.', '\n', '\n', '\n', '\n', 'Reset the iterator to the begin of the data.', '\n', '\n']",,,
"
mxnet.libinfo.find_conf_path(prefix='tvmop')[source]Â¶","['Find TVM op config files.', '\n', '\n', 'Returns', '\n', 'conf_path', '\n', 'Return type', '\n', 'string', '\n', '\n', '\n']",,,
"
mxnet.libinfo.find_include_path()[source]Â¶","['Find MXNet included header files.', '\n', '\n', 'Returns', '\n', 'incl_path', '\n', 'Return type', '\n', 'string', '\n', '\n', '\n']",,,
"
mxnet.libinfo.find_lib_path(prefix='libmxnet')[source]Â¶","['Find MXNet dynamic library files.', '\n', '\n', 'Returns', '\n', 'lib_path', '\n', 'Return type', '\n', 'list(string)', '\n', '\n', '\n']",,,
"
mxnet.log.getLogger(name=None, filename=None, filemode=None, level=30)[source]Â¶","['Gets a customized logger.', '\n', '\n', 'Note', '\n', 'getLogger', '\n', '\n', '\n']",,,
"
mxnet.log.get_logger(name=None, filename=None, filemode=None, level=30)[source]Â¶","['Gets a customized logger.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A customized ', '\n', 'Return type', '\n', 'Logger', '\n', '\n', 'Example', '\n', '## get_logger call with default parameters.\n>>> from mxnet.log import get_logger\n>>> logger = get_logger(â\x80\x9cTestâ\x80\x9d)\n>>> logger.warn(â\x80\x9cHello Worldâ\x80\x9d)\nW0505 00:29:47 3525 <stdin>:<module>:1] Hello World', '\n', '## get_logger call with WARNING level.\n>>> import logging\n>>> logger = get_logger(â\x80\x9cTest2â\x80\x9d, level=logging.WARNING)\n>>> logger.warn(â\x80\x9cHello Worldâ\x80\x9d)\nW0505 00:30:50 3525 <stdin>:<module>:1] Hello World\n>>> logger.debug(â\x80\x9cHello Worldâ\x80\x9d) # This doesnâ\x80\x99t return anything as the level is logging.WARNING.', '\n', '## get_logger call with DEBUG level.\n>>> logger = get_logger(â\x80\x9cTest3â\x80\x9d, level=logging.DEBUG)\n>>> logger.debug(â\x80\x9cHello Worldâ\x80\x9d) # Logs the debug output as the level is logging.DEBUG.\nD0505 00:31:30 3525 <stdin>:<module>:1] Hello World', '\n', '\n']",,,
"
class mxnet.model.FeedForward(symbol, ctx=None, num_epoch=None, epoch_size=None, optimizer='sgd', initializer=<mxnet.initializer.Uniform object>, numpy_batch_size=128, arg_params=None, aux_params=None, allow_extra_params=False, begin_epoch=0, **kwargs)[source]Â¶","['Bases: ', 'object', '\n', 'Model class of MXNet for training and predicting feedforward nets.\nThis class is designed for a single-data single output supervised network.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Functional style to create a model.\nThis function is more consistent with functional\nlanguages such as R, where mutation is not allowed.', '\n', '\n', '\n', '\n', 'Fit the model.', '\n', '\n', '\n', '\n', 'Load model checkpoint from file.', '\n', '\n', '\n', '\n', 'Run the prediction, always only use one device.', '\n', '\n', '\n', '\n', 'Checkpoint the model checkpoint into file.\nYou can also use ', '\n', '\n', '\n', '\n', 'Run the model given an input and calculate the score\nas assessed by an evaluation metric.', '\n', '\n']",,,
"
mxnet.model.load_checkpoint(prefix, epoch)[source]Â¶","['Load model checkpoint from file.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Notes', '\n', '\n', 'Symbol will be loaded from ', '\n', 'Parameters will be loaded from ', '\n', '\n', '\n']",,,
"
mxnet.model.load_params(prefix, epoch)[source]Â¶","['Load params from a file', '\n', '\n']",,,
"
mxnet.model.save_checkpoint(prefix, epoch, symbol, arg_params, aux_params, remove_amp_cast=True)[source]Â¶","['Checkpoint the model data into file.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Notes', '\n', '\n', 'prefix-symbol.json', '\n', 'prefix-epoch.params', '\n', '\n', '\n']",,,
"
class mxnet.monitor.Monitor(interval, stat_func=None, pattern='.*', sort=False, monitor_all=False)[source]Â¶","['Bases: ', 'object', '\n', 'Monitor inputs, outputs, weights, and gradients for debugging.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'install callback to executor.\nSupports installing to multiple exes.', '\n', '\n', '\n', '\n', 'Start collecting stats for current batch.\nCall before calling forward.', '\n', '\n', '\n', '\n', 'End collecting for current batch and return results.\nCall after computation of current batch.', '\n', '\n', '\n', '\n', 'End collecting and print results.', '\n', '\n']",,,
"
class mxnet.name.NameManager[source]Â¶","['Bases: ', 'object', '\n', 'NameManager to do automatic naming.', '\n', 'Developers can also inherit from this class to change naming behavior.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Get the canonical name for a symbol.', '\n', '\n']",,,
"
class mxnet.name.Prefix(prefix)[source]Â¶","['Bases: ', 'mxnet.name.NameManager', '\n', 'A name manager that attaches a prefix to all names.', '\n', 'Examples', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', None, '\n', '\n', '\n', '\n', '\n', 'Get the canonical name for a symbol.', '\n', '\n']",,,
"
class mxnet.operator.CustomOp[source]Â¶","['Bases: ', 'object', '\n', 'Base class for operators implemented in python', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Helper function for assigning into dst depending on requirements.', '\n', '\n', '\n', '\n', 'Backward interface. Can override when creating new operators.', '\n', '\n', '\n', '\n', 'Forward interface. Can override when creating new operators.', '\n', '\n']",,,
"
class mxnet.operator.CustomOpProp(need_top_grad=True)[source]Â¶","['Bases: ', 'object', '\n', 'Base class for operator property class implemented in python.', '\n', '\n', 'Parameters', '\n', 'need_top_grad', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Create an operator that carries out the real computation\ngiven the context, input shapes, and input data types.', '\n', '\n', '\n', '\n', 'Declare dependencies of this operator for backward pass.', '\n', '\n', '\n', '\n', 'infer_shape interface. Can override when creating new operators.', '\n', '\n', '\n', '\n', 'infer_storage_type interface. Used to infer storage type of\ninputs and outputs in the forward pass. When this interface is not implemented,\nall stypes will be inferred as default.', '\n', '\n', '\n', '\n', 'infer_storage_type_backward interface. Used to infer storage\ntype of inputs and outputs in the backward pass.', '\n', '\n', '\n', '\n', 'infer_type interface. override to create new operators', '\n', '\n', '\n', '\n', 'list_arguments interface. Can override when creating new operators.', '\n', '\n', '\n', '\n', 'list_auxiliary_states interface. Can override when creating new operators.', '\n', '\n', '\n', '\n', 'list_outputs interface. Can override when creating new operators.', '\n', '\n']",,,
"
class mxnet.operator.NDArrayOp(need_top_grad=True)[source]Â¶","['Bases: ', 'mxnet.operator.PythonOp', '\n', 'Base class for numpy operators. numpy operators allow parts\nof computation in symbolic graph to be writen in numpy. This feature\nis intended for quickly hacking out a solution for non performance\ncritical parts. Please consider write a c++ implementation if it becomes\na bottleneck.\nNote that if your operator contains internal states (like arrays),\nit cannot be used for multi-gpu training.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Declare dependencies of this operator for backward pass.', '\n', '\n', '\n', '\n', 'Create a symbol from numpy operator.\nThis should only be called once per instance if the operator contains\ninternal states.', '\n', '\n']",,,
"
class mxnet.operator.NumpyOp(need_top_grad=True)[source]Â¶","['Bases: ', 'mxnet.operator.PythonOp', '\n', 'Base class for numpy operators. numpy operators allow parts\nof computation in symbolic graph to be writen in numpy. This feature\nis intended for quickly hacking out a solution for non performance\ncritical parts. Please consider write a c++ implementation if it becomes\na bottleneck.\nNote that if your operator contains internal states (like arrays),\nit cannot be used for multi-gpu training.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Create a symbol from numpy operator.\nThis should only be called once per instance if the operator contains\ninternal states.', '\n', '\n']",,,
"
class mxnet.operator.OperatorArguments(narg, names, types)Â¶","['Bases: ', 'tuple', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Alias for field number 1', '\n', '\n', '\n', '\n', 'Alias for field number 0', '\n', '\n', '\n', '\n', 'Alias for field number 2', '\n', '\n']",,,
"
class mxnet.operator.PythonOp(need_top_grad=True)[source]Â¶","['Bases: ', 'object', '\n', 'Base class for operators implemented in Python.', '\n', '\n', 'Parameters', '\n', 'need_top_grad', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Backward interface. Can override when creating new operators.', '\n', '\n', '\n', '\n', 'Forward interface. Override to create new operators.', '\n', '\n', '\n', '\n', 'Create a symbol from numpy operator.\nThis should only be called once per instance if the operator contains\ninternal states.', '\n', '\n', '\n', '\n', 'Interface for ', '\n', '\n', '\n', '\n', 'Interface for ', '\n', '\n', '\n', '\n', 'Interface for ', '\n', '\n', '\n', '\n', 'Whether this operator needs out_grad for backward.', '\n', '\n']",,,
"
mxnet.operator.get_all_registered_operators()[source]Â¶","['Get all registered MXNet operator names.', '\n', '\n', 'Returns', '\n', 'operator_names', '\n', 'Return type', '\n', 'list of string', '\n', '\n', '\n']",,,
"
mxnet.operator.get_operator_arguments(op_name)[source]Â¶","['Given operator name, fetch operator arguments - number of arguments,\nargument names, argument types.', '\n', '\n', 'Parameters', '\n', 'op_name', '\n', 'Returns', '\n', 'operator_arguments', '\n', 'Return type', '\n', 'OperatorArguments', '\n', '\n', '\n']",,,
"
mxnet.operator.register(reg_name)[source]Â¶","['Register a subclass of CustomOpProp to the registry with name reg_name.', '\n', '\n']",,,
"
class mxnet.profiler.Counter(domain, name, value=None)[source]Â¶","['Bases: ', 'object', '\n', 'Profiling Counter class.', '\n', 'The counter event can track a value as it changes over time.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Decrement counter value.', '\n', '\n', '\n', '\n', 'Increment counter value.', '\n', '\n', '\n', '\n', 'Set counter value.', '\n', '\n']",,,
"
class mxnet.profiler.Domain(name)[source]Â¶","['Bases: ', 'object', '\n', 'Profiling domain, used to group sub-objects like tasks, counters, etc into categories\nServes as part of â\x80\x98categoriesâ\x80\x99 for chrome://tracing', '\n', 'Note: Domain handles are never destroyed.', '\n', '\n', 'Parameters', '\n', 'name', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Create new Counter object owned by this domain', '\n', '\n', '\n', '\n', 'Create new Frame object owned by this domain', '\n', '\n', '\n', '\n', 'Create new Marker object owned by this domain', '\n', '\n', '\n', '\n', 'Create new Task object owned by this domain', '\n', '\n']",,,
"
class mxnet.profiler.Event(name)[source]Â¶","['Bases: ', 'object', '\n', 'Profiling Event class.', '\n', 'The event API is used to observe when demarcated events occur in your application, or to\nidentify how long it takes to execute demarcated regions of code. Set annotations in the\napplication to demarcate areas where events of interest occur.\nAfter running analysis, you can see the events marked in the Timeline pane.\nEvent API is a per-thread function that works in resumed state.\nThis function does not work in paused state.', '\n', '\n', 'Parameters', '\n', 'name', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Start timing scope for this object', '\n', '\n', '\n', '\n', 'Stop timing scope for this object', '\n', '\n']",,,
"
class mxnet.profiler.Frame(domain, name)[source]Â¶","['Bases: ', 'object', '\n', 'Profiling Frame class.', '\n', 'Use the frame API to insert calls to the desired places in your code and analyze\nperformance per frame, where frame is the time period between frame begin and end points.\nWhen frames are displayed in Intel VTune Amplifier, they are displayed in a\nseparate track, so they provide a way to visually separate this data from normal task data.', '\n', 'This is different from Task in that each â\x80\x98Frameâ\x80\x99 duration will be a discretely-numbered\nevent in the VTune output, as well as its rate (frame-rate) shown.  This is analogous to\nprofiling each frame of some visual output, such as rendering a video game frame.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Start timing scope for this object', '\n', '\n', '\n', '\n', 'Stop timing scope for this object', '\n', '\n']",,,
"
class mxnet.profiler.Marker(domain, name)[source]Â¶","['Bases: ', 'object', '\n', 'Set marker for an instant in time.', '\n', 'The marker event marks a particular instant in time across some scope boundaries.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Set up the profiler state to record operator.', '\n', '\n']",,,
"
class mxnet.profiler.Task(domain, name)[source]Â¶","['Bases: ', 'object', '\n', 'Profiling Task class.', '\n', 'A task is a logical unit of work performed by a particular thread.\nTasks can nest; thus, tasks typically correspond to functions, scopes, or a case block\nin a switch statement.\nYou can use the Task API to assign tasks to threads.', '\n', 'This is different from Frame in that all profiling statistics for passes\nthrough the taskâ\x80\x99s begin and endpoints are accumulated together into a single statistical\nanalysys, rather than a separate analysis for each pass (as with a Frame)', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Start timing scope for this object', '\n', '\n', '\n', '\n', 'Stop timing scope for this object', '\n', '\n']",,,
"
mxnet.profiler.dump(finished=True, profile_process='worker')[source]Â¶","['Dump profile and stop profiler. Use this to save profile\nin advance in case your program cannot exit normally.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.profiler.dump_profile()[source]Â¶","['Dump profile and stop profiler. Use this to save profile\nin advance in case your program cannot exit normally.', '\n', '\n']",,,
"
mxnet.profiler.dumps(reset=False, format='table', sort_by='total', ascending=False)[source]Â¶","['Return a printable string of aggregate profile stats.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.profiler.pause(profile_process='worker')[source]Â¶","['Pause profiling.', '\n', '\n', 'Parameters', '\n', 'profile_process', '\n', '\n', '\n']",,,
"
mxnet.profiler.profiler_set_config(mode='symbolic', filename='profile.json')[source]Â¶","['Set up the configure of profiler (Deprecated).', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.profiler.profiler_set_state(state='stop')[source]Â¶","['Set up the profiler state to â\x80\x98runâ\x80\x99 or â\x80\x98stopâ\x80\x99 (Deprecated).', '\n', '\n', 'Parameters', '\n', 'state', '\n', '\n', '\n']",,,
"
mxnet.profiler.resume(profile_process='worker')[source]Â¶","['Resume paused profiling.', '\n', '\n', 'Parameters', '\n', 'profile_process', '\n', '\n', '\n']",,,
"
mxnet.profiler.set_config(**kwargs)[source]Â¶","['Set up the configure of profiler (only accepts keyword arguments).', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.profiler.set_state(state='stop', profile_process='worker')[source]Â¶","['Set up the profiler state to â\x80\x98runâ\x80\x99 or â\x80\x98stopâ\x80\x99.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.random.seed(seed_state, ctx='all')[source]Â¶","['Seeds the random number generators in MXNet.', '\n', 'This affects the behavior of modules in MXNet that uses random number generators,\nlike the dropout operator and ', 'NDArray', 'â\x80\x99s random sampling operators.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Notes', '\n', 'Random number generators in MXNet are device specific.\n', 'mx.random.seed(seed_state)', ' sets the state of each generator using ', 'seed_state', ' and the\ndevice id. Therefore, random numbers generated from different devices can be different\neven if they are seeded using the same seed.', '\n', 'To produce identical random number sequences independent of the device id,\nset optional ', 'ctx', ' argument. This produces the same sequence of random numbers independent\nof the device id, but the sequence can be different on different kind of devices as MXNetâ\x80\x99s\nrandom number generators for CPU and GPU use different algorithms.', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> print(mx.nd.random.normal(shape=(2,2)).asnumpy())
[[ 1.36481571 -0.62203991]
 [-1.4962182  -0.08511394]]
>>> print(mx.nd.random.normal(shape=(2,2)).asnumpy())
[[ 1.09544981 -0.20014545]
 [-0.20808885  0.2527658 ]]
# Same results on the same device with the same seed
>>> mx.random.seed(128)
>>> print(mx.nd.random.normal(shape=(2,2)).asnumpy())
[[ 0.47400656 -0.75213492]
 [ 0.20251541  0.95352972]]
>>> mx.random.seed(128)
>>> print(mx.nd.random.normal(shape=(2,2)).asnumpy())
[[ 0.47400656 -0.75213492]
 [ 0.20251541  0.95352972]]
# Different results on gpu(0) and gpu(1) with the same seed
>>> mx.random.seed(128)
>>> print(mx.nd.random.normal(shape=(2,2),ctx=mx.gpu(0)).asnumpy())
[[ 2.5020072 -1.6884501]
 [-0.7931333 -1.4218881]]
>>> mx.random.seed(128)
>>> print(mx.nd.random.normal(shape=(2,2),ctx=mx.gpu(1)).asnumpy())
[[ 0.24336822 -1.664805  ]
 [-1.0223296   1.253198  ]]
# Seeding with `ctx` argument produces identical results on gpu(0) and gpu(1)
>>> mx.random.seed(128,ctx=mx.gpu(0))
>>> print(mx.nd.random.normal(shape=(2,2),ctx=mx.gpu(0)).asnumpy())
[[ 2.5020072 -1.6884501]
 [-0.7931333 -1.4218881]]
>>> mx.random.seed(128,ctx=mx.gpu(1))
>>> print(mx.nd.random.normal(shape=(2,2),ctx=mx.gpu(1)).asnumpy())
[[ 2.5020072 -1.6884501]
 [-0.7931333 -1.4218881]]
",,
"
class mxnet.recordio.MXIndexedRecordIO(idx_path, uri, flag, key_type=<class 'int'>)[source]Â¶","['Bases: ', 'mxnet.recordio.MXRecordIO', '\n', 'Reads/writes ', 'RecordIO', ' data format, supporting random access.', '\n', 'Examples', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Closes the record file.', '\n', '\n', '\n', '\n', 'Opens the record file.', '\n', '\n', '\n', '\n', 'Returns the record at given index.', '\n', '\n', '\n', '\n', 'Sets the current read pointer position.', '\n', '\n', '\n', '\n', 'Returns the current position of write head.', '\n', '\n', '\n', '\n', 'Inserts input record at given index.', '\n', '\n']",,,
"
class mxnet.recordio.MXRecordIO(uri, flag)[source]Â¶","['Bases: ', 'object', '\n', 'Reads/writes ', 'RecordIO', ' data format, supporting sequential read and write.', '\n', 'Examples', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Closes the record file.', '\n', '\n', '\n', '\n', 'Opens the record file.', '\n', '\n', '\n', '\n', 'Returns record as a string.', '\n', '\n', '\n', '\n', 'Resets the pointer to first item.', '\n', '\n', '\n', '\n', 'Inserts a string buffer as a record.', '\n', '\n']",,,
"
mxnet.recordio.pack(header, s)[source]Â¶","['Pack a string into MXImageRecord.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 's', '\n', 'Return type', '\n', 'str', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.recordio.pack_img(header, img, quality=95, img_fmt='.jpg')[source]Â¶","['Pack an image into ', 'MXImageRecord', '.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 's', '\n', 'Return type', '\n', 'str', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.recordio.unpack(s)[source]Â¶","['Unpack a MXImageRecord to string.', '\n', '\n', 'Parameters', '\n', 's', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.recordio.unpack_img(s, iscolor=-1)[source]Â¶","['Unpack a MXImageRecord to image.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.registry.get_alias_func(base_class, nickname)[source]Â¶","['Get registrator function that allow aliases.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'a registrator function', '\n', '\n', '\n']",,,
"
mxnet.registry.get_create_func(base_class, nickname)[source]Â¶","['Get creator function', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'a creator function', '\n', '\n', '\n']",,,
"
mxnet.registry.get_register_func(base_class, nickname)[source]Â¶","['Get registrator function.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'a registrator function', '\n', '\n', '\n']",,,
"
mxnet.registry.get_registry(base_class)[source]Â¶","['Get a copy of the registry.', '\n', '\n', 'Parameters', '\n', 'base_class', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'a registrator', '\n', '\n', '\n']",,,
"
class mxnet.rtc.CudaKernel(handle, name, is_ndarray, dtypes)[source]Â¶","['Bases: ', 'object', '\n', 'Constructs CUDA kernel. Should be created by ', 'CudaModule.get_kernel', ',\nnot intended to be used by users.', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Launch cuda kernel.', '\n', '\n']",,,
"
class mxnet.rtc.CudaModule(source, options=(), exports=())[source]Â¶","['Bases: ', 'object', '\n', 'Compile and run CUDA code from Python.', '\n', 'In CUDA 7.5, you need to prepend your kernel definitions\nwith â\x80\x98extern â\x80\x9cCâ\x80\x9dâ\x80\x99 to avoid name mangling:', '\n', None, '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Starting from CUDA 8.0, you can instead export functions by name.\nThis also allows you to use templates:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Get CUDA kernel from compiled module.', '\n', '\n']",,,
"
class mxnet.runtime.Feature[source]Â¶","['Bases: ', '_ctypes.Structure', '\n', 'Compile time feature description, member fields: ', 'name', ' and ', 'enabled', '.', '\n', 'Attributes', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'True if MXNet was compiled with the given compile-time feature.', '\n', '\n', '\n', '\n', 'Feature name.', '\n', '\n']",,,
"
class mxnet.runtime.Features[source]Â¶","['Bases: ', 'collections.OrderedDict', '\n', 'OrderedDict of name to Feature', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Check for a particular feature by name', '\n', '\n']",,,
"
mxnet.runtime.feature_list()[source]Â¶","['Check the library for compile-time features. The list of features are maintained in libinfo.h and libinfo.cc', '\n', '\n', 'Returns', '\n', 'List of ', '\n', 'Return type', '\n', 'list', '\n', '\n', '\n']",,,
"
class mxnet.test_utils.DummyIter(real_iter)[source]Â¶","['Bases: ', 'mxnet.io.io.DataIter', '\n', 'A dummy iterator that always returns the same batch of data\n(the first data batch of the real data iter). This is usually used for speed testing.', '\n', '\n', 'Parameters', '\n', 'real_iter', '\n', '\n', 'Methods', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'Get a data batch from iterator. The first data batch of real iter is always returned.\nStopIteration will never be raised.', '\n', '\n']",,,
"
mxnet.test_utils.almost_equal(a, b, rtol=None, atol=None, equal_nan=False, use_broadcast=True)[source]Â¶","['Test if two numpy arrays are almost equal.', '\n', '\n']",,,
"
mxnet.test_utils.assert_almost_equal(a, b, rtol=None, atol=None, names=('a', 'b'), equal_nan=False, use_broadcast=True, mismatches=(10, 10))[source]Â¶","['Test that two numpy arrays are almost equal. Raise exception message if not.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.assert_almost_equal_ignore_nan(a, b, rtol=None, atol=None, names=('a', 'b'))[source]Â¶","['Test that two NumPy arrays are almost equal (ignoring NaN in either array).\nCombines a relative and absolute measure of approximate eqality.\nIf either the relative or absolute check passes, the arrays are considered equal.\nIncluding an absolute check resolves issues with the relative check where all\narray values are close to zero.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.assert_almost_equal_with_err(a, b, rtol=None, atol=None, etol=None, names=('a', 'b'), equal_nan=False, mismatches=(10, 10))[source]Â¶","['Test that two numpy arrays are almost equal within given error rate. Raise exception message if not.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.assert_exception(f, exception_type, *args, **kwargs)[source]Â¶","['Test that function f will throw an exception of type given by ', 'exception_type', '\n', '\n']",,,
"
mxnet.test_utils.assign_each(the_input, function)[source]Â¶","['Return ndarray composed of passing each array value through some function', '\n', '\n']",,,
"
mxnet.test_utils.assign_each2(input1, input2, function)[source]Â¶","['Return ndarray composed of passing two array values through some function', '\n', '\n']",,,
"
mxnet.test_utils.check_consistency(sym, ctx_list, scale=1.0, grad_req='write', arg_params=None, aux_params=None, rtol=None, atol=None, raise_on_err=True, ground_truth=None, equal_nan=False, use_uniform=False, rand_type=<class 'numpy.float64'>)[source]Â¶","['Check symbol gives the same output for different running context', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.test_utils.check_gluon_hybridize_consistency(net_builder, data_l, numpy_func=None, test_grad=True, rtol=0.0001, atol=0.0001)[source]Â¶","['\n', 'Check whether a HybridBlock has consistent output between the hybridized', 'v.s. non-hybridized versions', '\n', '\n', 'The network should not contain any random number generators.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.check_numeric_gradient(sym, location, aux_states=None, numeric_eps=None, rtol=None, atol=None, grad_nodes=None, use_forward_train=True, ctx=None, grad_stype_dict=None, dtype=<class 'numpy.float32'>)[source]Â¶","['Verify an operation by checking backward pass via finite difference method.', '\n', 'Based on Theanoâ\x80\x99s ', 'theano.gradient.verify_grad', ' [1]', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'References', '\n', '[1] ', 'https://github.com/Theano/Theano/blob/master/theano/gradient.py', '\n', '\n']",,,
"
mxnet.test_utils.check_speed(sym, location=None, ctx=None, N=20, grad_req=None, typ='whole', **kwargs)[source]Â¶","['Check the running speed of a symbol.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.check_symbolic_backward(sym, location, out_grads, expected, rtol=None, atol=None, aux_states=None, grad_req='write', ctx=None, grad_stypes=None, equal_nan=False, dtype=<class 'numpy.float32'>)[source]Â¶","['Compares a symbolâ\x80\x99s backward results with the expected ones.\nPrints error messages if the backward results are not the same as the expected results.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> lhs=mx.symbol.Variable('lhs')
>>> rhs=mx.symbol.Variable('rhs')
>>> sym_add=mx.symbol.elemwise_add(lhs,rhs)
>>> mat1=np.array([[1,2],[3,4]])
>>> mat2=np.array([[5,6],[7,8]])
>>> grad1=mx.nd.zeros(shape)
>>> grad2=mx.nd.zeros(shape)
>>> exec_add=sym_add.bind(default_context(),args={'lhs':mat1,'rhs':mat2},
... args_grad={'lhs':grad1,'rhs':grad2},grad_req={'lhs':'write','rhs':'write'})
>>> exec_add.forward(is_train=True)
>>> ograd=mx.nd.ones(shape)
>>> grad_expected=ograd.copy().asnumpy()
>>> check_symbolic_backward(sym_add,[mat1,mat2],[ograd],[grad_expected,grad_expected])
",,
"
mxnet.test_utils.check_symbolic_forward(sym, location, expected, rtol=None, atol=None, aux_states=None, ctx=None, equal_nan=False, dtype=<class 'numpy.float32'>)[source]Â¶","['Compares a symbolâ\x80\x99s forward results with the expected ones.\nPrints error messages if the forward results are not the same as the expected ones.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> shape=(2,2)
>>> lhs=mx.symbol.Variable('lhs')
>>> rhs=mx.symbol.Variable('rhs')
>>> sym_dot=mx.symbol.dot(lhs,rhs)
>>> mat1=np.array([[1,2],[3,4]])
>>> mat2=np.array([[5,6],[7,8]])
>>> ret_expected=np.array([[19,22],[43,50]])
>>> check_symbolic_forward(sym_dot,[mat1,mat2],[ret_expected])
",,
"
mxnet.test_utils.chi_square_check(generator, buckets, probs, nsamples=1000000)[source]Â¶","['Run the chi-square test for the generator. The generator can be both continuous and discrete.', '\n', 'If the generator is continuous, the buckets should contain tuples of (range_min, range_max)     and the probs should be the corresponding ideal probability within the specific ranges.     Otherwise, the buckets should contain all the possible values generated over the discrete distribution and the     probs should be groud-truth probability.', '\n', 'Usually the user is required to specify the probs parameter.', '\n', 'After obtaining the p value, we could further use the standard p > 0.05 (alpha) threshold to get     the final result.', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.collapse_sum_like(a, shape)[source]Â¶","['Given ', 'a', ' as a numpy ndarray, perform reduce_sum on ', 'a', ' over the axes that do not\nexist in ', 'shape', '. Note that an ndarray with ', 'shape', ' must be broadcastable to ', 'a', '.', '\n', '\n']",,,
"
mxnet.test_utils.compare_ndarray_tuple(t1, t2, rtol=None, atol=None)[source]Â¶","['Compare ndarray tuple.', '\n', '\n']",,,
"
mxnet.test_utils.compare_optimizer(opt1, opt2, shape, dtype, w_stype='default', g_stype='default', rtol=0.0001, atol=1e-05, compare_states=True, ntensors=1)[source]Â¶","['Compare opt1 and opt2.', '\n', '\n']",,,
"
mxnet.test_utils.create_sparse_array(shape, stype, data_init=None, rsp_indices=None, dtype=None, modifier_func=None, density=0.5, shuffle_csr_indices=False)[source]Â¶","['Create a sparse array, For Rsp, assure indices are in a canonical format', '\n', '\n']",,,
"
mxnet.test_utils.create_sparse_array_zd(shape, stype, density, data_init=None, rsp_indices=None, dtype=None, modifier_func=None, shuffle_csr_indices=False)[source]Â¶","['Create sparse array, using only rsp_indices to determine density', '\n', '\n']",,,
"
mxnet.test_utils.default_atols()[source]Â¶","['Get default absolute tolerances for data comparisons involving each data type.', '\n', '\n']",,,
"
mxnet.test_utils.default_context()[source]Â¶","['Get default context for regression test.', '\n', '\n']",,,
"
mxnet.test_utils.default_dtype()[source]Â¶","['Get default data type for regression test.', '\n', '\n']",,,
"
mxnet.test_utils.default_numeric_eps()[source]Â¶","['Get default epsilon for finite difference gradient calculations with data type.', '\n', '\n']",,,
"
mxnet.test_utils.default_rtols()[source]Â¶","['Get default relative tolerances for data comparisons involving each data type.', '\n', '\n']",,,
"
mxnet.test_utils.discard_stderr()[source]Â¶","['Discards error output of a routine if invoked as:', '\n', '\n', 'with discard_stderr():', 'â\x80¦', '\n', '\n', '\n']",,,
"
mxnet.test_utils.download(url, fname=None, dirname=None, overwrite=False, retries=5)[source]Â¶","['Download an given URL', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'The filename of the downloaded file', '\n', 'Return type', '\n', 'str', '\n', '\n', '\n']",,,
"
mxnet.test_utils.download_model(model_name, dst_dir='./', meta_info=None)[source]Â¶","['Download a model from data.mxnet.io', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'Two element tuple containing model_name and epoch for the params saved', '\n', '\n', '\n']",,,
"
mxnet.test_utils.effective_dtype(dat)[source]Â¶","['Return the most appropriate dtype for determining the tolerance used in dat comparisons\n:param dat:\n:type dat: np.ndarray or mx.nd.array or mx.np.ndarray', '\n', '\n']",,,
"
mxnet.test_utils.environment(*args)[source]Â¶","['Environment variable setter and unsetter via ', 'with', ' idiom.', '\n', 'Takes a specification of env var names and desired values and adds those\nsettings to the environment in advance of running the body of the ', 'with', '\nstatement.  The original environment state is restored afterwards, even\nif exceptions are raised in the ', 'with', ' body.', '\n', '\n', 'Parameters', '\n', 'args', '\n', '\n', '\n']",,,
"
mxnet.test_utils.gen_buckets_probs_with_ppf(ppf, nbuckets)[source]Â¶","['\n', 'Generate the buckets and probabilities for chi_square test when the ppf (Quantile function)', 'is specified.', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.get_atol(atol=None, dtype=dtype('float64'))[source]Â¶","['Get default numerical threshold for regression test.', '\n', '\n']",,,
"
mxnet.test_utils.get_bz2_data(data_dir, data_name, url, data_origin_name)[source]Â¶","['Download and extract bz2 data.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.test_utils.get_cifar10()[source]Â¶","['Downloads CIFAR10 dataset into a directory in the current directory with the name ', 'data', ',\nand then extracts all files into the directory ', 'data/cifar', '.', '\n', '\n']",,,
"
mxnet.test_utils.get_etol(etol=None)[source]Â¶","['Get default numerical threshold for regression test.', '\n', '\n']",,,
"
mxnet.test_utils.get_im2rec_path(home_env='MXNET_HOME')[source]Â¶","['Get path to the im2rec.py tool', '\n', '\n', 'Parameters', '\n', 'home_env', '\n', 'Returns', '\n', 'The path to im2rec.py', '\n', 'Return type', '\n', 'str', '\n', '\n', '\n']",,,
"
mxnet.test_utils.get_mnist()[source]Â¶","['Download and load the MNIST dataset', '\n', '\n', 'Returns', '\n', 'A dict containing the data', '\n', 'Return type', '\n', 'dict', '\n', '\n', '\n']",,,
"
mxnet.test_utils.get_mnist_iterator(batch_size, input_shape, num_parts=1, part_index=0)[source]Â¶","['Returns training and validation iterators for MNIST dataset', '\n', '\n']",,,
"
mxnet.test_utils.get_mnist_pkl()[source]Â¶","['Downloads MNIST dataset as a pkl.gz into a directory in the current directory\nwith the name ', 'data', '\n', '\n']",,,
"
mxnet.test_utils.get_mnist_ubyte()[source]Â¶","['Downloads ubyte version of the MNIST dataset into a directory in the current directory\nwith the name ', 'data', ' and extracts all files in the zip archive to this directory.', '\n', '\n']",,,
"
mxnet.test_utils.get_rtol(rtol=None, dtype=dtype('float64'))[source]Â¶","['Get default numerical threshold for regression test.', '\n', '\n']",,,
"
mxnet.test_utils.get_tolerance(dat, tol, default_tol)[source]Â¶","['Return the tolerance to be used for dat comparisons based on the given tol, datatype and context.\n:param dat:\n:type dat: np.ndarray or mx.nd.array or mx.np.ndarray\n:param tol:\n:type tol: float, or a dict of dtype->float\n:param default_tol:\n:type default_tol: default dict of dtype->float for all types', '\n', '\n']",,,
"
mxnet.test_utils.get_tols(x, y, rtol, atol)[source]Â¶","['For comparing two datasets â\x80\x98xâ\x80\x99 and â\x80\x98yâ\x80\x99, what relative and absolute tolerances should be used.', '\n', '\n']",,,
"
mxnet.test_utils.get_zip_data(data_dir, url, data_origin_name)[source]Â¶","['Download and extract zip data.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.test_utils.has_tvm_ops()[source]Â¶","['Returns True if MXNet is compiled with TVM generated operators. If current ctx\nis GPU, it only returns True for CUDA compute capability > 52 where FP16 is supported.', '\n', '\n']",,,
"
mxnet.test_utils.is_aarch64_run()[source]Â¶","['Checks if the test is running on aarch64 instance', '\n', '\n']",,,
"
mxnet.test_utils.is_cd_run()[source]Â¶","['Checks if the test is running as part of a Continuous Delivery run', '\n', '\n']",,,
"
mxnet.test_utils.is_op_runnable()[source]Â¶","['Returns True for all CPU tests. Returns True for GPU tests that are either of the following.\n1. Built with USE_TVM_OP=0.\n2. Built with USE_TVM_OP=1, but with compute capability >= 53.', '\n', '\n']",,,
"
mxnet.test_utils.list_gpus()[source]Â¶","['Return a list of GPUs', '\n', '\n', 'Returns', '\n', 'If there are n GPUs, then return a list [0,1,â\x80¦,n-1]. Otherwise returns\n[].', '\n', 'Return type', '\n', 'list of int', '\n', '\n', '\n']",,,
"
mxnet.test_utils.locationError(a, b, index, names, maxError=False)[source]Â¶","['Create element mismatch comment', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.mean_check(generator, mu, sigma, nsamples=1000000)[source]Â¶","['Test the generator by matching the mean.', '\n', '\n', 'We test the sample mean by checking if it falls inside the range', '(mu - 3 * sigma / sqrt(n), mu + 3 * sigma / sqrt(n))', '\n', '\n', 'References:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'ret', '\n', 'Return type', '\n', 'bool', '\n', '\n', '\n']",,,
"
mxnet.test_utils.new_matrix_with_real_eigvals_2d(n)[source]Â¶","['Generate a well-conditioned matrix with small real eigenvalues.', '\n', '\n']",,,
"
mxnet.test_utils.new_matrix_with_real_eigvals_nd(shape)[source]Â¶","['Generate well-conditioned matrices with small real eigenvalues.', '\n', '\n']",,,
"
mxnet.test_utils.new_orthonormal_matrix_2d(n)[source]Â¶","['Generate a orthonormal matrix.', '\n', '\n']",,,
"
mxnet.test_utils.new_sym_matrix_with_real_eigvals_2d(n)[source]Â¶","['Generate a sym matrix with real eigenvalues.', '\n', '\n']",,,
"
mxnet.test_utils.new_sym_matrix_with_real_eigvals_nd(shape)[source]Â¶","['Generate sym matrices with real eigenvalues.', '\n', '\n']",,,
"
mxnet.test_utils.np_reduce(dat, axis, keepdims, numpy_reduce_func)[source]Â¶","['Compatible reduce for old version of NumPy.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.numeric_grad(executor, location, aux_states=None, eps=0.0001, use_forward_train=True, dtype=<class 'numpy.float32'>)[source]Â¶","['Calculates a numeric gradient via finite difference method.', '\n', 'Class based on Theanoâ\x80\x99s ', 'theano.gradient.numeric_grad', ' [1]', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'References', '\n', '..[1] ', 'https://github.com/Theano/Theano/blob/master/theano/gradient.py', '\n', '\n']",,,
"
mxnet.test_utils.rand_ndarray(shape, stype='default', density=None, dtype=None, modifier_func=None, shuffle_csr_indices=False, distribution=None, ctx=None)[source]Â¶","['Generate a random sparse ndarray. Returns the generated ndarray.', '\n', '\n']",,,
"
mxnet.test_utils.rand_sparse_ndarray(shape, stype, density=None, dtype=None, distribution=None, data_init=None, rsp_indices=None, modifier_func=None, shuffle_csr_indices=False, ctx=None)[source]Â¶","['Generate a random sparse ndarray. Returns the ndarray, value(np) and indices(np)', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'Result of type CSRNDArray or ', '\n', '\n', 'Examples', '\n', 'Below is an example of the powerlaw distribution with csr as the stype.\nIt calculates the nnz using the shape and density.\nIt fills up the ndarray with exponentially increasing number of elements.\nIf there are enough unused_nnzs, n+1th row will have twice more nnzs compared to nth row.\nelse, remaining unused_nnzs will be used in n+1th row\nIf number of cols is too small and we have already reached column size it will fill up\nall following columns in all followings rows until we reach the required density.', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.test_utils.random_arrays(*shapes)[source]Â¶","['Generate some random numpy arrays.', '\n', '\n']",,,
"
mxnet.test_utils.random_sample(population, k)[source]Â¶","['Return a k length list of the elements chosen from the population sequence.', '\n', '\n']",,,
"
mxnet.test_utils.random_uniform_arrays(*shapes, **kwargs)[source]Â¶","['Generate some random numpy arrays.', '\n', '\n']",,,
"
mxnet.test_utils.retry(n)[source]Â¶","['Retry n times before failing for stochastic test cases.', '\n', '\n']",,,
"
mxnet.test_utils.same(a, b)[source]Â¶","['Test if two NumPy arrays are the same.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.same_array(array1, array2)[source]Â¶","['Check whether two NDArrays sharing the same memory block', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'Whether two NDArrays share the same memory', '\n', 'Return type', '\n', 'bool', '\n', '\n', '\n']",,,
"
mxnet.test_utils.same_symbol_structure(sym1, sym2)[source]Â¶","['Compare two symbols to check if they have the same computation graph structure.\nReturns true if operator corresponding to a particular node id is same in both\nsymbols for all nodes', '\n', '\n']",,,
"
mxnet.test_utils.set_default_context(ctx)[source]Â¶","['Set default context.', '\n', '\n']",,,
"
mxnet.test_utils.shuffle_csr_column_indices(csr)[source]Â¶","['Shuffle CSR column indices per row\nThis allows validation of unordered column indices, which is not a requirement\nfor a valid CSR matrix', '\n', '\n']",,,
"
mxnet.test_utils.simple_forward(sym, ctx=None, is_train=False, **inputs)[source]Â¶","['A simple forward function for a symbol.', '\n', 'Primarily used in doctest to test the functionality of a symbol.\nTakes NumPy arrays as inputs and outputs are also converted to NumPy arrays.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.test_utils.var_check(generator, sigma, nsamples=1000000)[source]Â¶","['Test the generator by matching the variance.\nIt will need a large number of samples and is not recommended to use', '\n', '\n', 'We test the sample variance by checking if it falls inside the range', '(sigma^2 - 3 * sqrt(2 * sigma^4 / (n-1)), sigma^2 + 3 * sqrt(2 * sigma^4 / (n-1)))', '\n', '\n', 'References:', '\n', None, '\n', '\n', 'Examples:', '\n', None, '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'ret', '\n', 'Return type', '\n', 'bool', '\n', '\n', '\n']",,,
"
mxnet.test_utils.verify_generator(generator, buckets, probs, nsamples=1000000, nrepeat=5, success_rate=0.2, alpha=0.05)[source]Â¶","['Verify whether the generator is correct using chi-square testing.', '\n', '\n', 'The test is repeated for â\x80\x9cnrepeatâ\x80\x9d times and we check if the success rate is', 'above the threshold (25% by default).', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'cs_ret_l', '\n', 'Return type', '\n', 'list', '\n', '\n', '\n']",,,
"
mxnet.util.get_cuda_compute_capability(ctx)[source]Â¶","['Returns the cuda compute capability of the input ', 'ctx', '.', '\n', '\n', 'Parameters', '\n', 'ctx', '\n', 'Returns', '\n', 'cuda_compute_capability', '\n', 'Return type', '\n', 'int', '\n', '\n', 'References', '\n', 'https://gist.github.com/f0k/63a664160d016a491b2cbea15913d549#file-cuda_check-py', '\n', '\n']",,,
"
mxnet.util.getenv(name)[source]Â¶","['Get the setting of an environment variable from the C Runtime.', '\n', '\n', 'Parameters', '\n', 'name', '\n', 'Returns', '\n', 'value', '\n', 'Return type', '\n', 'string', '\n', '\n', '\n']",,,
"
mxnet.util.is_np_array()[source]Â¶","['Checks whether the NumPy-array semantics is currently turned on.\nThis is currently used in Gluon for checking whether an array of type ', 'mxnet.numpy.ndarray', '\nor ', 'mx.nd.NDArray', ' should be created. For example, at the time when a parameter\nis created in a ', 'Block', ', an ', 'mxnet.numpy.ndarray', ' is created if this returns true; else\nan ', 'mx.nd.NDArray', ' is created.', '\n', 'Normally, users are not recommended to use this API directly unless you known exactly\nwhat is going on under the hood.', '\n', 'Please note that this is designed as an infrastructure for the incoming\nMXNet-NumPy operators. Legacy operators registered in the modules\n', 'mx.nd', ' and ', 'mx.sym', ' are not guaranteed to behave like their counterparts\nin NumPy within this semantics.', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'A bool value indicating whether the NumPy-array semantics is currently on.', '\n', '\n', '\n']",,,
"
mxnet.util.is_np_shape()[source]Â¶","['Checks whether the NumPy shape semantics is currently turned on.\nIn NumPy shape semantics, ', '()', ' represents the shape of scalar tensors,\nand tuples with ', '0', ' elements, for example, ', '(0,)', ', ', '(1, 0, 2)', ', represent\nthe shapes of zero-size tensors. This is turned off by default for keeping\nbackward compatibility.', '\n', 'In the NumPy shape semantics, ', '-1', ' indicates an unknown size. For example,\n', '(-1, 2, 2)', ' means that the size of the first dimension is unknown. Its size\nmay be inferred during shape inference.', '\n', 'Please note that this is designed as an infrastructure for the incoming\nMXNet-NumPy operators. Legacy operators registered in the modules\n', 'mx.nd', ' and ', 'mx.sym', ' are not guaranteed to behave like their counterparts\nin NumPy within this semantics.', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'A bool value indicating whether the NumPy shape semantics is currently on.', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> importmxnetasmx
>>> prev_state=mx.set_np_shape(True)
>>> print(prev_state)
False
>>> print(mx.is_np_shape())
True
",,
"
mxnet.util.np_array(active=True)[source]Â¶","['Returns an activated/deactivated NumPy-array scope to be used in â\x80\x98withâ\x80\x99 statement\nand captures code that needs the NumPy-array semantics.', '\n', 'Currently, this is used in Gluon to enforce array creation in ', 'Block`s as type\n`mxnet.numpy.ndarray', ', instead of ', 'mx.nd.NDArray', '.', '\n', 'It is recommended to use the decorator ', 'use_np_array', ' to decorate the classes\nthat need this semantics, instead of using this function in a ', 'with', ' statement\nunless you know exactly what has been scoped by this semantics.', '\n', 'Please note that this is designed as an infrastructure for the incoming\nMXNet-NumPy operators. Legacy operators registered in the modules\n', 'mx.nd', ' and ', 'mx.sym', ' are not guaranteed to behave like their counterparts\nin NumPy even within this scope.', '\n', '\n', 'Parameters', '\n', 'active', '\n', 'Returns', '\n', 'A scope object for wrapping the code w/ or w/o NumPy-shape semantics.', '\n', 'Return type', '\n', '_NumpyShapeScope', '\n', '\n', '\n']",,,
"
mxnet.util.np_shape(active=True)[source]Â¶","['Returns an activated/deactivated NumPy shape scope to be used in â\x80\x98withâ\x80\x99 statement\nand captures code that needs the NumPy shape semantics, i.e. support of scalar and\nzero-size tensors.', '\n', 'Please note that this is designed as an infrastructure for the incoming\nMXNet-NumPy operators. Legacy operators registered in the modules\n', 'mx.nd', ' and ', 'mx.sym', ' are not guaranteed to behave like their counterparts\nin NumPy even within this scope.', '\n', '\n', 'Parameters', '\n', 'active', '\n', 'Returns', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.util.np_ufunc_legal_option(key, value)[source]Â¶","['Checking if ufunc arguments are legal inputs', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'legal', '\n', 'Return type', '\n', 'boolean', '\n', '\n', '\n']",,,
"
mxnet.util.reset_np()[source]Â¶","['Deactivate NumPy shape and array semantics at the same time.', '\n', '\n']",,,
"
mxnet.util.set_module(module)[source]Â¶","['Decorator for overriding __module__ on a function or class.', '\n', 'Example usage:', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.util.set_np(shape=True, array=True)[source]Â¶","['Setting NumPy shape and array semantics at the same time.\nIt is required to keep NumPy shape semantics active while activating NumPy array semantics.\nDeactivating NumPy shape semantics while NumPy array semantics is still active is not allowed.\nIt is highly recommended to set these two flags to ', 'True', ' at the same time to fully enable\nNumPy-like behaviors. Please refer to the Examples section for a better understanding.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', 'Examples', '\n', None, '\n', '\n', 'Creating zero-dim ndarray in legacy mode would fail at shape inference.', '\n', None, '\n', '\n', None, '\n', '\n', 'In legacy mode, Gluon layers would create parameters and outputs of type ', 'mx.nd.NDArray', '.', '\n', None, '\n', '\n', None, '\n', '\n', 'When the ', 'shape', ' flag is ', 'True', ', both shape inferences are successful.', '\n', None, '\n', '\n', None, '\n', '\n', 'When the ', 'array', ' flag is ', 'True', ', Gluon layers would create parameters and outputs of type ', 'mx.np.ndarray', '.', '\n', None, '\n', '\n', None, '\n', '\n', '\n']",,,
"
mxnet.util.set_np_shape(active)[source]Â¶","['Turns on/off NumPy shape semantics, in which ', '()', ' represents the shape of scalar tensors,\nand tuples with ', '0', ' elements, for example, ', '(0,)', ', ', '(1, 0, 2)', ', represent the shapes\nof zero-size tensors. This is turned off by default for keeping backward compatibility.', '\n', 'Please note that this is designed as an infrastructure for the incoming\nMXNet-NumPy operators. Legacy operators registered in the modules\n', 'mx.nd', ' and ', 'mx.sym', ' are not guaranteed to behave like their counterparts\nin NumPy within this semantics.', '\n', '\n', 'Parameters', '\n', 'active', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'A bool value indicating the previous state of NumPy shape semantics.', '\n', '\n', 'Example', '\n', None, '\n', '\n', '\n']",">>> importmxnetasmx
>>> prev_state=mx.set_np_shape(True)
>>> print(prev_state)
False
>>> print(mx.is_np_shape())
True
",,
"
mxnet.util.setenv(name, value)[source]Â¶","['Set an environment variable in the C Runtime.', '\n', '\n', 'Parameters', '\n', '\n', '\n', '\n', '\n']",,,
"
mxnet.util.use_np(func)[source]Â¶","['A convenience decorator for wrapping user provided functions and classes in the scope of\nboth NumPy-shape and NumPy-array semantics, which means that (1) empty tuples ', '()', ' and tuples\nwith zeros, such as ', '(0, 1)', ', ', '(1, 0, 2)', ', will be treated as scalar tensorsâ\x80\x99 shapes and\nzero-size tensorsâ\x80\x99 shapes in shape inference functions of operators, instead of as unknown\nin legacy mode; (2) ndarrays of type ', 'mxnet.numpy.ndarray', ' should be created instead of\n', 'mx.nd.NDArray', '.', '\n', '\n', 'Example::', 'import mxnet as mx\nfrom mxnet import gluon, np', '\n', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'A function or class wrapped in the Numpy-shape and NumPy-array scope.', '\n', 'Return type', '\n', 'Function', '\n', '\n', '\n']",,,
"
mxnet.util.use_np_array(func)[source]Â¶","['A decorator wrapping Gluon ', 'Block`s and all its methods, properties, and static functions\nwith the semantics of NumPy-array, which means that where ndarrays are created,\n`mxnet.numpy.ndarray`s should be created, instead of legacy ndarrays of type `mx.nd.NDArray', '.\nFor example, at the time when a parameter is created in a ', 'Block', ', an ', 'mxnet.numpy.ndarray', '\nis created if itâ\x80\x99s decorated with this decorator.', '\n', '\n', 'Example::', 'import mxnet as mx\nfrom mxnet import gluon, np', '\n', '\n', '\n', 'Parameters', '\n', 'func', '\n', 'Returns', '\n', 'A function or class wrapped in the NumPy-array scope.', '\n', 'Return type', '\n', 'Function', '\n', '\n', '\n']",,,
"
mxnet.util.use_np_shape(func)[source]Â¶","['A decorator wrapping a function or class with activated NumPy-shape semantics.\nWhen ', 'func', ' is a function, this ensures that the execution of the function is scoped with NumPy\nshape semantics, such as the support for zero-dim and zero size tensors. When\n', 'func', ' is a class, it ensures that all the methods, static functions, and properties\nof the class are executed with the NumPy shape semantics.', '\n', '\n', 'Example::', 'import mxnet as mx\n@mx.use_np_shape\ndef scalar_one():', '\n', '\n', '\n', 'Parameters', '\n', 'func', '\n', 'Returns', '\n', 'A function or class wrapped in the NumPy-shape scope.', '\n', 'Return type', '\n', 'Function', '\n', '\n', '\n']",,,
"
mxnet.util.wrap_np_binary_func(func)[source]Â¶","['A convenience decorator for wrapping numpy-compatible binary ufuncs to provide uniform\nerror handling.', '\n', '\n', 'Parameters', '\n', 'func', '\n', 'Returns', '\n', 'A function wrapped with proper error handling.', '\n', 'Return type', '\n', 'Function', '\n', '\n', '\n']",,,
"
mxnet.util.wrap_np_unary_func(func)[source]Â¶","['A convenience decorator for wrapping numpy-compatible unary ufuncs to provide uniform\nerror handling.', '\n', '\n', 'Parameters', '\n', 'func', '\n', 'Returns', '\n', 'A function wrapped with proper error handling.', '\n', 'Return type', '\n', 'Function', '\n', '\n', '\n']",,,
"
mxnet.visualization.plot_network(symbol, title='plot', save_format='pdf', shape=None, dtype=None, node_attrs={}, hide_weights=True)[source]Â¶","['Creates a visualization (Graphviz digraph object) of the given computation graph.\nGraphviz must be installed for this function to work.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'dot', '\n', 'Return type', '\n', 'Digraph', '\n', '\n', 'Example', '\n', None, '\n', '\n', 'Notes', '\n', 'If ', 'mxnet', ' is imported, the visualization module can be used in its short-form.\nFor example, if we ', 'import', ' as follows:', '\n', None, '\n', '\n', 'this method in visualization module can be used in its short-form as:', '\n', None, '\n', '\n', '\n']",">>> net=mx.sym.Variable('data')
>>> net=mx.sym.FullyConnected(data=net,name='fc1',num_hidden=128)
>>> net=mx.sym.Activation(data=net,name='relu1',act_type=""relu"")
>>> net=mx.sym.FullyConnected(data=net,name='fc2',num_hidden=10)
>>> net=mx.sym.SoftmaxOutput(data=net,name='out')
>>> digraph=mx.viz.plot_network(net,shape={'data':(100,200)},
... node_attrs={""fixedsize"":""false""})
>>> digraph.view()
","importmxnet
","mxnet.viz.plot_network(...)
"
"
mxnet.visualization.print_summary(symbol, shape=None, line_length=120, positions=[0.44, 0.64, 0.74, 1.0])[source]Â¶","['Convert symbol for detail information.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', None, '\n', 'Return type', '\n', 'None', '\n', '\n', 'Notes', '\n', 'If ', 'mxnet', ' is imported, the visualization module can be used in its short-form.\nFor example, if we ', 'import', ' as follows:', '\n', None, '\n', '\n', 'this method in visualization module can be used in its short-form as:', '\n', None, '\n', '\n', '\n']",,,
"
class mxnet.ndarray.CachedOp(sym, flags=())[source]Â¶","['Bases: ', 'object', '\n', 'Cached operator handle.', '\n', '\n']",,,
"
mxnet.ndarray.Activation(data=None, act_type=_Null, out=None, name=None, **kwargs)Â¶","['Applies an activation function element-wise to the input.', '\n', 'The following activation functions are supported:', '\n', '\n', 'relu', '\n', 'sigmoid', '\n', 'tanh', '\n', 'softrelu', '\n', 'softsign', '\n', '\n', 'Defined in src/operator/nn/activation.cc:L164', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BatchNorm(data=None, gamma=None, beta=None, moving_mean=None, moving_var=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, axis=_Null, cudnn_off=_Null, min_calib_range=_Null, max_calib_range=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\nthe inverse of ', 'data_var', ', which are needed for the backward pass. Note that gradient of these\ntwo outputs are blocked.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'The parameter ', 'axis', ' specifies which axis of the input shape denotes\nthe â\x80\x98channelâ\x80\x99 (separately normalized groups).  The default is 1.  Specifying -1 sets the channel\naxis to be the last item in the input shape.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', '\n', 'Note', '\n', 'When ', '\n', '\n', 'Defined in src/operator/nn/batch_norm.cc:L608', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BatchNorm_v1(data=None, gamma=None, beta=None, eps=_Null, momentum=_Null, fix_gamma=_Null, use_global_stats=_Null, output_mean_var=_Null, out=None, name=None, **kwargs)Â¶","['Batch normalization.', '\n', 'This operator is DEPRECATED. Perform BatchNorm on the input.', '\n', 'Normalizes a data batch by mean and variance, and applies a scale ', 'gamma', ' as\nwell as offset ', 'beta', '.', '\n', 'Assume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:', '\n', '\n\\[\\begin{split}data\\_mean[i] = mean(data[:,i,:,...]) \\\\\ndata\\_var[i] = var(data[:,i,:,...])\\end{split}\\]', '\n', 'Then compute the normalized output, which has the same shape as input, as following:', '\n', '\n\\[out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\\]', '\n', 'Both ', 'mean', ' and ', 'var', ' returns a scalar by treating the input as a vector.', '\n', 'Assume the input has size ', 'k', ' on axis 1, then both ', 'gamma', ' and ', 'beta', '\nhave shape ', '(k,)', '. If ', 'output_mean_var', ' is set to be true, then outputs both ', 'data_mean', ' and\n', 'data_var', ' as well, which are needed for the backward pass.', '\n', 'Besides the inputs and the outputs, this operator accepts two auxiliary\nstates, ', 'moving_mean', ' and ', 'moving_var', ', which are ', 'k', '-length\nvectors. They are global statistics for the whole dataset, which are updated\nby:', '\n', None, '\n', '\n', 'If ', 'use_global_stats', ' is set to be true, then ', 'moving_mean', ' and\n', 'moving_var', ' are used instead of ', 'data_mean', ' and ', 'data_var', ' to compute\nthe output. It is often used during inference.', '\n', 'Both ', 'gamma', ' and ', 'beta', ' are learnable parameters. But if ', 'fix_gamma', ' is true,\nthen set ', 'gamma', ' to 1 and its gradient to 0.', '\n', 'Thereâ\x80\x99s no sparse support for this operator, and it will exhibit problematic behavior if used with\nsparse tensors.', '\n', 'Defined in src/operator/batch_norm_v1.cc:L94', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BilinearSampler(data=None, grid=None, cudnn_off=_Null, out=None, name=None, **kwargs)Â¶","['Applies bilinear sampling to input feature map.', '\n', 'Bilinear Sampling is the key of  [NIPS2015] â\x80\x9cSpatial Transformer Networksâ\x80\x9d. The usage of the operator is very similar to remap function in OpenCV,\nexcept that the operator has the backward pass.', '\n', 'Given ', '\\(data\\)', ' and ', '\\(grid\\)', ', then the output is computed by', '\n', '\n\\[\\begin{split}x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\\\\ny_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\\\\noutput[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})\\end{split}\\]', '\n', '\\(x_{dst}\\)', ', ', '\\(y_{dst}\\)', ' enumerate all spatial locations in ', '\\(output\\)', ', and ', '\\(G()\\)', ' denotes the bilinear interpolation kernel.\nThe out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).', '\n', 'The operator assumes that ', '\\(data\\)', ' has â\x80\x98NCHWâ\x80\x99 layout and ', '\\(grid\\)', ' has been normalized to [-1, 1].', '\n', 'BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.\nGridGenerator supports two kinds of transformation: ', 'affine', ' and ', 'warp', '.\nIf users want to design a CustomOp to manipulate ', '\\(grid\\)', ', please firstly refer to the code of GridGenerator.', '\n', 'Example 1:', '\n', None, '\n', '\n', 'Example 2:', '\n', None, '\n', '\n', 'Defined in src/operator/bilinear_sampler.cc:L255', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.BlockGrad(data=None, out=None, name=None, **kwargs)Â¶","['Stops gradient computation.', '\n', 'Stops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L325', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.CTCLoss(data=None, label=None, data_lengths=None, label_lengths=None, use_data_lengths=_Null, use_label_lengths=_Null, blank_label=_Null, out=None, name=None, **kwargs)Â¶","['Connectionist Temporal Classification Loss.', '\n', '\n', 'Note', '\n', 'The existing alias ', '\n', '\n', 'The shapes of the inputs and outputs:', '\n', '\n', 'data', '\n', 'label', '\n', 'out', '\n', '\n', 'The ', 'data', ' tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen ', 'blank_label', ' is ', '""first""', ', the ', '0', '-th channel is be reserved for\nactivation of blank label, or otherwise if it is â\x80\x9clastâ\x80\x9d, ', '(alphabet_size-1)', '-th channel should be\nreserved for blank label.', '\n', 'label', ' is an index matrix of integers. When ', 'blank_label', ' is ', '""first""', ',\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen ', 'blank_label', ' is ', '""last""', ', the value ', '(alphabet_size-1)', ' is reserved for blank label.', '\n', 'If a sequence of labels is shorter than ', 'label_sequence_length', ', use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is ', '0', ' when ', 'blank_label', ' is ', '""first""', ', and ', '-1', ' otherwise.', '\n', 'For example, suppose the vocabulary is ', '[a, b, c]', ', and in one batch we have three sequences\nâ\x80\x98baâ\x80\x99, â\x80\x98cbbâ\x80\x99, and â\x80\x98abacâ\x80\x99. When ', 'blank_label', ' is ', '""first""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 1, â\x80\x98bâ\x80\x99: 2, â\x80\x98câ\x80\x99: 3}', ', and we reserve the 0-th channel for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'When ', 'blank_label', ' is ', '""last""', ', we can index the labels as\n', '{â\x80\x98aâ\x80\x99: 0, â\x80\x98bâ\x80\x99: 1, â\x80\x98câ\x80\x99: 2}', ', and we reserve the channel index 3 for blank label in data tensor.\nThe resulting ', 'label', ' tensor should be padded to be:', '\n', None, '\n', '\n', 'out', ' is a list of CTC loss values, one per example in the batch.', '\n', 'See ', 'Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks', ', A. Graves ', 'et al', '. for more\ninformation on the definition and the algorithm.', '\n', 'Defined in src/operator/nn/ctc_loss.cc:L100', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Cast(data=None, dtype=_Null, out=None, name=None, **kwargs)Â¶","['Casts all elements of the input to a new type.', '\n', '\n', 'Note', '\n', 'Cast', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L664', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Concat(*data, **kwargs)Â¶","['Joins input arrays along a given axis.', '\n', '\n', 'Note', '\n', 'Concat', '\n', '\n', 'The dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.', '\n', 'The storage type of ', 'concat', ' output depends on storage types of inputs', '\n', '\n', 'concat(csr, csr, â\x80¦, csr, dim=0) = csr', '\n', 'otherwise, ', '\n', '\n', 'Example:', '\n', None, '\n', '\n', 'Defined in src/operator/nn/concat.cc:L384', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Convolution(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['Compute ', 'N', '-D convolution on ', '(N+2)', '-D input.', '\n', 'In the 2-D convolution, given input data with shape ', '(batch_size,\nchannel, height, width)', ', the output is computed by', '\n', '\n\\[out[n,i,:,:] = bias[i] + \\sum_{j=0}^{channel} data[n,j,:,:] \\star\nweight[i,j,:,:]\\]', '\n', 'where ', '\\(\\star\\)', ' is the 2-D cross-correlation operator.', '\n', 'For general 2-D convolution, the shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Define:', '\n', None, '\n', '\n', 'then we have:', '\n', None, '\n', '\n', 'If ', 'no_bias', ' is set to be true, then the ', 'bias', ' term is ignored.', '\n', 'The default data ', 'layout', ' is ', 'NCHW', ', namely ', '(batch_size, channel, height,\nwidth)', '. We can choose other layouts such as ', 'NWC', '.', '\n', 'If ', 'num_group', ' is larger than 1, denoted by ', 'g', ', then split the input ', 'data', '\nevenly into ', 'g', ' parts along the channel axis, and also evenly split ', 'weight', '\nalong the first dimension. Next compute the convolution on the ', 'i', '-th part of\nthe data with the ', 'i', '-th weight part. The output is obtained by concatenating all\nthe ', 'g', ' results.', '\n', '1-D convolution does not have ', 'height', ' dimension but only ', 'width', ' in space.', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', '3-D convolution adds an additional ', 'depth', ' dimension besides ', 'height', ' and\n', 'width', '. The shapes are', '\n', '\n', 'data', '\n', 'weight', '\n', 'bias', '\n', 'out', '\n', '\n', 'Both ', 'weight', ' and ', 'bias', ' are learnable parameters.', '\n', 'There are other options to tune the performance.', '\n', '\n', 'cudnn_tune', '\n', 'workspace', '\n', '\n', 'Defined in src/operator/nn/convolution.cc:L475', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Convolution_v1(data=None, weight=None, bias=None, kernel=_Null, stride=_Null, dilate=_Null, pad=_Null, num_filter=_Null, num_group=_Null, workspace=_Null, no_bias=_Null, cudnn_tune=_Null, cudnn_off=_Null, layout=_Null, out=None, name=None, **kwargs)Â¶","['This operator is DEPRECATED. Apply convolution to input then add a bias.', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Correlation(data1=None, data2=None, kernel_size=_Null, max_displacement=_Null, stride1=_Null, stride2=_Null, pad_size=_Null, is_multiply=_Null, out=None, name=None, **kwargs)Â¶","['Applies correlation to inputs.', '\n', 'The correlation layer performs multiplicative patch comparisons between two feature maps.', '\n', 'Given two multi-channel feature maps ', '\\(f_{1}, f_{2}\\)', ', with ', '\\(w\\)', ', ', '\\(h\\)', ', and ', '\\(c\\)', ' being their width, height, and number of channels,\nthe correlation layer lets the network compare each patch from ', '\\(f_{1}\\)', ' with each patch from ', '\\(f_{2}\\)', '.', '\n', 'For now we consider only a single comparison of two patches. The â\x80\x98correlationâ\x80\x99 of two patches centered at ', '\\(x_{1}\\)', ' in the first map and\n', '\\(x_{2}\\)', ' in the second map is then defined as:', '\n', '\n\\[c(x_{1}, x_{2}) = \\sum_{o \\in [-k,k] \\times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\\]', '\n', 'for a square patch of size ', '\\(K:=2k+1\\)', '.', '\n', 'Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other\ndata. For this reason, it has no training weights.', '\n', 'Computing ', '\\(c(x_{1}, x_{2})\\)', ' involves ', '\\(c * K^{2}\\)', ' multiplications. Comparing all patch combinations involves ', '\\(w^{2}*h^{2}\\)', ' such computations.', '\n', 'Given a maximum displacement ', '\\(d\\)', ', for each location ', '\\(x_{1}\\)', ' it computes correlations ', '\\(c(x_{1}, x_{2})\\)', ' only in a neighborhood of size ', '\\(D:=2d+1\\)', ',\nby limiting the range of ', '\\(x_{2}\\)', '. We use strides ', '\\(s_{1}, s_{2}\\)', ', to quantize ', '\\(x_{1}\\)', ' globally and to quantize ', '\\(x_{2}\\)', ' within the neighborhood\ncentered around ', '\\(x_{1}\\)', '.', '\n', 'The final output is defined by the following expression:', '\n', '\n\\[out[n, q, i, j] = c(x_{i, j}, x_{q})\\]', '\n', 'where ', '\\(i\\)', ' and ', '\\(j\\)', ' enumerate spatial locations in ', '\\(f_{1}\\)', ', and ', '\\(q\\)', ' denotes the ', '\\(q^{th}\\)', ' neighborhood of ', '\\(x_{i,j}\\)', '.', '\n', 'Defined in src/operator/correlation.cc:L197', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
"
mxnet.ndarray.Crop(*data, **kwargs)Â¶","['\n', 'Note', '\n', 'Crop', '\n', '\n', 'Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or\nwith width and height of the second input symbol, i.e., with one input, we need h_w to\nspecify the crop height and width, otherwise the second input symbolâ\x80\x99s size will be used', '\n', 'Defined in src/operator/crop.cc:L49', '\n', '\n', 'Parameters', '\n', '\n', '\n', 'Returns', '\n', 'out', '\n', 'Return type', '\n', 'NDArray', '\n', '\n', '\n']",,,
